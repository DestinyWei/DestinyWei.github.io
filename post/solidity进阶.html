<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Solidity学习笔记(二) | 浩烬的博客</title><meta name="keywords" content="Solidity"><meta name="author" content="浩烬"><meta name="copyright" content="浩烬"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Solidity进阶学习链接：https:&#x2F;&#x2F;wtf.academy&#x2F;solidity-advanced&#x2F; 14.重载solidity中允许函数进行重载（overloading），即名字相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。注意，**solidity不允许修饰器（modifier）重载**。 函数重载举个例子，我们可以定义两个都叫saySomething()的函数，一个没">
<meta property="og:type" content="article">
<meta property="og:title" content="Solidity学习笔记(二)">
<meta property="og:url" content="https://destinywei.github.io/post/solidity%E8%BF%9B%E9%98%B6.html">
<meta property="og:site_name" content="浩烬的博客">
<meta property="og:description" content="Solidity进阶学习链接：https:&#x2F;&#x2F;wtf.academy&#x2F;solidity-advanced&#x2F; 14.重载solidity中允许函数进行重载（overloading），即名字相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。注意，**solidity不允许修饰器（modifier）重载**。 函数重载举个例子，我们可以定义两个都叫saySomething()的函数，一个没">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/Solidity进阶.jpg">
<meta property="article:published_time" content="2023-04-10T11:17:41.354Z">
<meta property="article:modified_time" content="2023-04-10T11:21:06.298Z">
<meta property="article:author" content="浩烬">
<meta property="article:tag" content="Solidity">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/Solidity进阶.jpg"><link rel="shortcut icon" href="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/头像3.jpg"><link rel="canonical" href="https://destinywei.github.io/post/solidity%E8%BF%9B%E9%98%B6"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Solidity学习笔记(二)',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-04-10 19:21:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_1.css" ><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_2.css" ><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-clock/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head><body>
    <div id='loader'>
        
            <div class="outer_box">
                <div class='loader_overlay'></div>
                <div class='loader_cogs'>
                    <div class='loader_cogs__top'>
                        <div class='top_part'></div>
                        <div class='top_part'></div>
                        <div class='top_part'></div>
                        <div class='top_hole'></div>
                    </div>
                    <div class='loader_cogs__left'>
                        <div class='left_part'></div>
                        <div class='left_part'></div>
                        <div class='left_part'></div>
                        <div class='left_hole'></div>
                    </div>
                    <div class='loader_cogs__bottom'>
                        <div class='bottom_part'></div>
                        <div class='bottom_part'></div>
                        <div class='bottom_part'></div>
                        <div class='bottom_hole'></div>
                    </div>
                    <p style="text-align:center">&nbsp;&nbsp;&nbsp;loading...</p>
                </div>
            </div>
        
    </div>

    <script>
        var endLoading = function () {
            document.body.style.overflow = 'auto';
            document.getElementById('loader').classList.add("loading");
        }
        window.addEventListener('load',endLoading);
    </script>

<div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/头像3.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/Solidity进阶.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">浩烬的博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Solidity学习笔记(二)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-10T11:17:41.354Z" title="发表于 2023-04-10 19:17:41">2023-04-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-10T11:21:06.298Z" title="更新于 2023-04-10 19:21:06">2023-04-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>47分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Solidity学习笔记(二)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Solidity进阶"><a href="#Solidity进阶" class="headerlink" title="Solidity进阶"></a>Solidity进阶</h1><p>学习链接：<a target="_blank" rel="noopener" href="https://wtf.academy/solidity-advanced/">https://wtf.academy/solidity-advanced/</a></p>
<h2 id="14-重载"><a href="#14-重载" class="headerlink" title="14.重载"></a>14.重载</h2><p><code>solidity</code>中允许函数进行重载（<code>overloading</code>），即<strong>名字相同但输入参数类型不同</strong>的函数可以同时存在，他们被视为不同的函数。注意，**<code>solidity</code>不允许修饰器（<code>modifier</code>）重载**。</p>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>举个例子，我们可以定义两个都叫<code>saySomething()</code>的函数，一个没有任何参数，输出<code>&quot;Nothing&quot;</code>；另一个接收一个<code>string</code>参数，输出这个<code>string</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function saySomething() public pure returns(string memory)&#123;</span><br><span class="line">    return(&quot;Nothing&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function saySomething(string memory something) public pure returns(string memory)&#123;</span><br><span class="line">    return(something);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终重载函数在经过编译器编译后，由于不同的参数类型，都变成了不同的函数选择器（selector）。关于函数选择器的具体内容可参考<a target="_blank" rel="noopener" href="https://github.com/AmazingAng/WTFSolidity/tree/main/29_Selector">Solidity极简入门: 29. 函数选择器Selector</a>。</p>
<h3 id="实参匹配（Argument-Matching）"><a href="#实参匹配（Argument-Matching）" class="headerlink" title="实参匹配（Argument Matching）"></a>实参匹配（Argument Matching）</h3><p>在调用重载函数时，会把输入的实际参数和函数参数的变量类型做匹配。 <strong>如果出现多个匹配的重载函数，则会报错。</strong>下面这个例子有两个叫<code>f()</code>的函数，一个参数为<code>uint8</code>，另一个为<code>uint256</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f(uint8 _in) public pure returns (uint8 out) &#123;</span><br><span class="line">    out = _in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f(uint256 _in) public pure returns (uint256 out) &#123;</span><br><span class="line">    out = _in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们调用<code>f(50)</code>，因为<code>50</code>既可以被转换为<code>uint8</code>，也可以被转换为<code>uint256</code>，因此会报错。</p>
<h2 id="15-库合约"><a href="#15-库合约" class="headerlink" title="15.库合约"></a>15.库合约</h2><p>他和普通合约主要有以下几点不同：</p>
<ol>
<li>不能存在状态变量</li>
<li>不能够继承或被继承</li>
<li>不能接收以太币</li>
<li>不可以被销毁</li>
</ol>
<h3 id="示例：String库合约"><a href="#示例：String库合约" class="headerlink" title="示例：String库合约"></a>示例：String库合约</h3><p><code>String库合约</code>是将<code>uint256</code>类型转换为相应的<code>string</code>类型的代码库，样例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">library Strings &#123;</span><br><span class="line">    bytes16 private constant _HEX_SYMBOLS = &quot;0123456789abcdef&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Converts a `uint256` to its ASCII `string` decimal representation.</span><br><span class="line">     */</span><br><span class="line">    function toString(uint256 value) public pure returns (string memory) &#123;</span><br><span class="line">        // Inspired by OraclizeAPI&#x27;s implementation - MIT licence</span><br><span class="line">        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol</span><br><span class="line"></span><br><span class="line">        if (value == 0) &#123;</span><br><span class="line">            return &quot;0&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        uint256 temp = value;</span><br><span class="line">        uint256 digits;</span><br><span class="line">        while (temp != 0) &#123;</span><br><span class="line">            digits++;</span><br><span class="line">            temp /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        bytes memory buffer = new bytes(digits);</span><br><span class="line">        while (value != 0) &#123;</span><br><span class="line">            digits -= 1;</span><br><span class="line">            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));</span><br><span class="line">            value /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return string(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.</span><br><span class="line">     */</span><br><span class="line">    function toHexString(uint256 value) public pure returns (string memory) &#123;</span><br><span class="line">        if (value == 0) &#123;</span><br><span class="line">            return &quot;0x00&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        uint256 temp = value;</span><br><span class="line">        uint256 length = 0;</span><br><span class="line">        while (temp != 0) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            temp &gt;&gt;= 8;</span><br><span class="line">        &#125;</span><br><span class="line">        return toHexString(value, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.</span><br><span class="line">     */</span><br><span class="line">    function toHexString(uint256 value, uint256 length) public pure returns (string memory) &#123;</span><br><span class="line">        bytes memory buffer = new bytes(2 * length + 2);</span><br><span class="line">        buffer[0] = &quot;0&quot;;</span><br><span class="line">        buffer[1] = &quot;x&quot;;</span><br><span class="line">        for (uint256 i = 2 * length + 1; i &gt; 1; --i) &#123;</span><br><span class="line">            buffer[i] = _HEX_SYMBOLS[value &amp; 0xf];</span><br><span class="line">            value &gt;&gt;= 4;</span><br><span class="line">        &#125;</span><br><span class="line">        require(value == 0, &quot;Strings: hex length insufficient&quot;);</span><br><span class="line">        return string(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他主要包含两个函数，<code>toString()</code>将<code>uint256</code>转为<code>string</code>，<code>toHexString()</code>将<code>uint256</code>转换为<code>16进制</code>，在转换为<code>string</code>。</p>
<h3 id="如何使用库合约"><a href="#如何使用库合约" class="headerlink" title="如何使用库合约"></a>如何使用库合约</h3><p>我们用String库函数的toHexString()来演示两种使用库合约中函数的办法。</p>
<p><strong>1. 利用using for指令</strong></p>
<p>指令<code>using A for B;</code>可用于附加库函数（从库 A）到任何类型（B）。添加完指令后，库<code>A</code>中的函数会自动添加为<code>B</code>类型变量的成员，可以直接调用。注意：在调用的时候，这个变量会被当作第一个参数传递给函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 利用using for指令</span><br><span class="line">using Strings for uint256;</span><br><span class="line">function getString1(uint256 _number) public pure returns(string memory)&#123;</span><br><span class="line">    // 库函数会自动添加为uint256型变量的成员</span><br><span class="line">    return _number.toHexString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 通过库合约名称调用库函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 直接通过库合约名调用</span><br><span class="line">function getString2(uint256 _number) public pure returns(string memory)&#123;</span><br><span class="line">    return Strings.toHexString(_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-import"><a href="#16-import" class="headerlink" title="16.import"></a>16.import</h2><h3 id="import用法"><a href="#import用法" class="headerlink" title="import用法"></a><code>import</code>用法</h3><ul>
<li>通过源文件相对位置导入，例子：</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">文件结构</span><br><span class="line">├── Import.sol</span><br><span class="line">└── Yeye.sol</span><br><span class="line"></span><br><span class="line">// 通过文件相对位置import</span><br><span class="line">import &#x27;./Yeye.sol&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过源文件网址导入网上的合约，例子：</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 通过网址引用</span><br><span class="line">import &#x27;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过<code>npm</code>的目录导入，例子：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;@openzeppelin/contracts/access/Ownable.sol&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>通过<code>全局符号</code>导入特定的合约</strong>，例子：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Yeye&#125; from &#x27;./Yeye.sol&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li>引用(<code>import</code>)在代码中的位置为：在声明版本号之后，在其余代码之前。</li>
</ul>
<p>问题：被导入文件中的全局符号想要被其他合约单独导入，应该怎么编写？</p>
<p>将合约结构包含</p>
<p>包含在合约结构中</p>
<p>与合约并列在文件结构中 √</p>
<h3 id="测试导入结果"><a href="#测试导入结果" class="headerlink" title="测试导入结果"></a>测试导入结果</h3><p>我们可以用下面这段代码测试是否成功导入了外部源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract Import &#123;</span><br><span class="line">    // 成功导入Address库</span><br><span class="line">    using Address for address;</span><br><span class="line">    // 声明yeye变量</span><br><span class="line">    Yeye yeye = new Yeye();</span><br><span class="line"></span><br><span class="line">    // 测试是否能调用yeye的函数</span><br><span class="line">    function test() external&#123;</span><br><span class="line">        yeye.hip();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221017194250364.png" alt="测试导入结果"></p>
<h2 id="17-接收ETH"><a href="#17-接收ETH" class="headerlink" title="17.接收ETH"></a>17.接收ETH</h2><p><code>Solidity</code>支持两种特殊的回调函数，<code>receive()</code>和<code>fallback()</code>，他们主要在两种情况下被使用：</p>
<ol>
<li>接收ETH</li>
<li>处理合约中不存在的函数调用（代理合约proxy contract）</li>
</ol>
<p>注意⚠️：在solidity 0.6.x版本之前，语法上只有 <code>fallback()</code> 函数，用来接收用户发送的ETH时调用以及在被调用函数签名没有匹配到时，来调用。 0.6版本之后，solidity才将 <code>fallback()</code> 函数拆分成 <code>receive()</code> 和 <code>fallback()</code> 两个函数。</p>
<h3 id="接收ETH函数-receive"><a href="#接收ETH函数-receive" class="headerlink" title="接收ETH函数 receive"></a>接收ETH函数 receive</h3><p><code>receive()</code>只用于处理接收<code>ETH</code>。一个合约最多有一个<code>receive()</code>函数，声明方式与一般函数不一样，不需要<code>function</code>关键字：<code>receive() external payable &#123; ... &#125;</code>。<code>receive()</code>函数**不能有任何的参数，不能返回任何值，必须包含<code>external</code>和<code>payable</code>**。</p>
<p>当合约接收ETH的时候，<code>receive()</code>会被触发。<code>receive()</code>最好不要执行太多的逻辑因为如果别人用<code>send</code>和<code>transfer</code>方法发送<code>ETH</code>的话，<code>gas</code>会限制在<code>2300</code>，<code>receive()</code>太复杂可能会触发<code>Out of Gas</code>报错；如果用<code>call</code>就可以自定义<code>gas</code>执行更复杂的逻辑（这三种发送ETH的方法我们之后会讲到）。</p>
<p>我们可以在<code>receive()</code>里发送一个<code>event</code>，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 定义事件</span><br><span class="line">event Received(address Sender, uint Value);</span><br><span class="line">// 接收ETH时释放Received事件</span><br><span class="line">receive() external payable &#123;</span><br><span class="line">    emit Received(msg.sender, msg.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有些恶意合约，会在<code>receive()</code> 函数（老版本的话，就是 <code>fallback()</code> 函数）嵌入恶意消耗<code>gas</code>的内容或者使得执行故意失败的代码，导致一些包含退款和转账逻辑的合约不能正常工作，因此写包含退款等逻辑的合约时候，一定要注意这种情况。</p>
<h3 id="回退函数-fallback"><a href="#回退函数-fallback" class="headerlink" title="回退函数 fallback"></a>回退函数 fallback</h3><p><code>fallback()</code>函数会在调用合约不存在的函数时被触发。可用于接收ETH，也可以用于代理合约<code>proxy contract</code>。<code>fallback()</code>声明时不需要<code>function</code>关键字，必须由<code>external</code>修饰，一般也会用<code>payable</code>修饰，用于接收ETH:<code>fallback() external payable &#123; ... &#125;</code>。</p>
<p>我们定义一个<code>fallback()</code>函数，被触发时候会释放<code>fallbackCalled</code>事件，并输出<code>msg.sender</code>，<code>msg.value</code>和<code>msg.data</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// fallback</span><br><span class="line">fallback() external payable&#123;</span><br><span class="line">    emit fallbackCalled(msg.sender, msg.value, msg.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="receive和fallback的区别"><a href="#receive和fallback的区别" class="headerlink" title="receive和fallback的区别"></a>receive和fallback的区别</h3><p><code>receive</code>和<code>fallback</code>都能够用于接收<code>ETH</code>，他们触发的规则如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">触发fallback() 还是 receive()?</span><br><span class="line">           接收ETH</span><br><span class="line">              |</span><br><span class="line">         msg.data是空？</span><br><span class="line">            /  \</span><br><span class="line">          是    否</span><br><span class="line">          /      \</span><br><span class="line">receive()存在?   fallback()</span><br><span class="line">        / \</span><br><span class="line">       是  否</span><br><span class="line">      /     \</span><br><span class="line">receive()   fallback()</span><br></pre></td></tr></table></figure>

<p>简单来说，合约接收<code>ETH</code>时，<code>msg.data</code>为空且存在<code>receive()</code>时，会触发<code>receive()</code>；<code>msg.data</code>不为空或不存在<code>receive()</code>时，会触发<code>fallback()</code>，此时<code>fallback()</code>必须为<code>payable</code>。</p>
<p><code>receive()</code>和<code>payable fallback()</code>均不存在的时候，向合约发送<code>ETH</code>将会报错。</p>
<h2 id="18-发送ETH"><a href="#18-发送ETH" class="headerlink" title="18.发送ETH"></a>18.发送ETH</h2><p><code>Solidity</code>有三种方法向其他合约发送<code>ETH</code>，他们是：<code>transfer()</code>，<code>send()</code>和<code>call()</code>，其中<code>call()</code>是被鼓励的用法。</p>
<h3 id="接收ETH合约"><a href="#接收ETH合约" class="headerlink" title="接收ETH合约"></a>接收ETH合约</h3><p>我们先部署一个接收<code>ETH</code>合约<code>ReceiveETH</code>。<code>ReceiveETH</code>合约里有一个事件<code>Log</code>，记录收到的<code>ETH</code>数量和<code>gas</code>剩余。还有两个函数，一个是<code>receive()</code>函数，收到<code>ETH</code>被触发，并发送<code>Log</code>事件；另一个是查询合约<code>ETH</code>余额的<code>getBalance()</code>函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">contract ReceiveETH &#123;</span><br><span class="line">    // 收到eth事件，记录amount和gas</span><br><span class="line">    event Log(uint amount, uint gas);</span><br><span class="line">    </span><br><span class="line">    // receive方法，接收eth时被触发</span><br><span class="line">    receive() external payable&#123;</span><br><span class="line">        emit Log(msg.value, gasleft());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 返回合约ETH余额</span><br><span class="line">    function getBalance() view public returns(uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>部署<code>ReceiveETH</code>合约后，运行<code>getBalance()</code>函数，可以看到当前合约的<code>ETH</code>余额为<code>0</code>。</p>
<h3 id="发送ETH合约"><a href="#发送ETH合约" class="headerlink" title="发送ETH合约"></a>发送ETH合约</h3><p>我们将实现三种方法向<code>ReceiveETH</code>合约发送<code>ETH</code>。首先，先在发送ETH合约<code>SendETH</code>中实现<code>payable</code>的<code>构造函数</code>和<code>receive()</code>，让我们能够在部署时和部署后向合约转账。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">contract SendETH &#123;</span><br><span class="line">    // 构造函数，payable使得部署的时候可以转eth进去</span><br><span class="line">    constructor() payable&#123;&#125;</span><br><span class="line">    // receive方法，接收eth时被触发</span><br><span class="line">    receive() external payable&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h4><ul>
<li>用法是<code>接收方地址.transfer(发送ETH数额)</code>。</li>
<li><code>transfer()</code>的<code>gas</code>限制是<code>2300</code>，足够用于转账，但对方合约的<code>fallback()</code>或<code>receive()</code>函数不能实现太复杂的逻辑。</li>
<li><code>transfer()</code>如果转账失败，<strong>会自动<code>revert</code>（回滚交易</strong>）。</li>
</ul>
<p>代码样例，注意里面的<code>_to</code>填<code>ReceiveETH</code>合约的地址，<code>amount</code>是<code>ETH</code>转账金额：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 用transfer()发送ETH</span><br><span class="line">function transferETH(address payable _to, uint256 amount) external payable&#123;</span><br><span class="line">    _to.transfer(amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>部署<code>SendETH</code>合约后，对<code>ReceiveETH</code>合约发送ETH，此时<code>amount</code>为10，<code>value</code>为0，<code>amount</code>&gt;<code>value</code>，转账失败，发生<code>revert</code>。</p>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221018104248901.png" alt="image-20221018104248901"></p>
<p>此时<code>amount</code>为10，<code>value</code>为10，<code>amount</code>&lt;&#x3D;<code>value</code>，转账成功。</p>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221018104310260.png" alt="image-20221018104310260"></p>
<p>在<code>ReceiveETH</code>合约中，运行<code>getBalance()</code>函数，可以看到当前合约的<code>ETH</code>余额为<code>10</code>。<img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221018104330257.png"></p>
<h4 id="send"><a href="#send" class="headerlink" title="send"></a>send</h4><ul>
<li>用法是<code>接收方地址.send(发送ETH数额)</code>。</li>
<li><code>send()</code>的<code>gas</code>限制是<code>2300</code>，足够用于转账，但对方合约的<code>fallback()</code>或<code>receive()</code>函数不能实现太复杂的逻辑。</li>
<li><code>send()</code>如果转账失败，**不会<code>revert</code>**。</li>
<li><code>send()</code>的返回值是<code>bool</code>，代表着转账成功或失败，需要额外代码处理一下。</li>
</ul>
<p>代码样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// send()发送ETH</span><br><span class="line">function sendETH(address payable _to, uint256 amount) external payable&#123;</span><br><span class="line">    // 处理下send的返回值，如果失败，revert交易并发送error</span><br><span class="line">    bool success = _to.send(amount);</span><br><span class="line">    if(!success)&#123;</span><br><span class="line">        revert SendFailed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对<code>ReceiveETH</code>合约发送ETH，此时<code>amount</code>为10，<code>value</code>为0，<code>amount</code>&gt;<code>value</code>，转账失败，因为经过处理，所以发生<code>revert</code>。</p>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221018104536026.png" alt="image-20221018104536026"></p>
<p>此时<code>amount</code>为10，<code>value</code>为11，<code>amount</code>&lt;&#x3D;<code>value</code>，转账成功。</p>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221018104552963.png" alt="image-20221018104552963"></p>
<h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><ul>
<li>用法是<code>接收方地址.call&#123;value: 发送ETH数额&#125;(&quot;&quot;)</code>。</li>
<li><code>call()</code><strong>没有<code>gas</code>限制</strong>，可以支持对方合约<code>fallback()</code>或<code>receive()</code>函数实现复杂逻辑。</li>
<li><code>call()</code>如果转账失败，**不会<code>revert</code>**。</li>
<li><code>call()</code>的返回值是<code>(bool, data)</code>，其中<code>bool</code>代表着转账成功或失败，需要额外代码处理一下。</li>
</ul>
<p>代码样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// call()发送ETH</span><br><span class="line">function callETH(address payable _to, uint256 amount) external payable&#123;</span><br><span class="line">    // 处理下call的返回值，如果失败，revert交易并发送error</span><br><span class="line">    (bool success,) = _to.call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line">    if(!success)&#123;</span><br><span class="line">        revert CallFailed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对<code>ReceiveETH</code>合约发送ETH，此时<code>amount</code>为10，<code>value</code>为0，<code>amount</code>&gt;<code>value</code>，转账失败，因为经过处理，所以发生<code>revert</code>。</p>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221018104624385.png" alt="image-20221018104624385"></p>
<p>此时<code>amount</code>为10，<code>value</code>为11，<code>amount</code>&lt;&#x3D;<code>value</code>，转账成功。</p>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221018104640160.png" alt="image-20221018104640160"></p>
<p>运行三种方法，可以看到，他们都可以成功地向<code>ReceiveETH</code>合约发送<code>ETH</code>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>call</code>没有<code>gas</code>限制，最为灵活，是最提倡的方法；</li>
<li><code>transfer</code>有<code>2300 gas</code>限制，但是发送失败会自动<code>revert</code>交易，是次优选择；</li>
<li><code>send</code>有<code>2300 gas</code>限制，而且发送失败不会自动<code>revert</code>交易，几乎没有人用它。</li>
</ul>
<p>问题：vitalik写了一个合约，并且该合约在被部署时可以转ETH进去，那么该合约的构造函数可能为？</p>
<p>constructor() payable{} √</p>
<p>constructor(uint256 _amount) payable{ (address(this)).transfer(_amount); }</p>
<p>constructor() {}</p>
<h2 id="19-调用其它合约"><a href="#19-调用其它合约" class="headerlink" title="19.调用其它合约"></a>19.调用其它合约</h2><h3 id="目标合约"><a href="#目标合约" class="headerlink" title="目标合约"></a>目标合约</h3><p>我们先写一个简单的合约<code>OtherContract</code>来调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">contract OtherContract &#123;</span><br><span class="line">    uint256 private _x = 0; // 状态变量_x</span><br><span class="line">    // 收到eth的事件，记录amount和gas</span><br><span class="line">    event Log(uint amount, uint gas);</span><br><span class="line">    </span><br><span class="line">    // 返回合约ETH余额</span><br><span class="line">    function getBalance() view public returns(uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable)</span><br><span class="line">    function setX(uint256 x) external payable&#123;</span><br><span class="line">        _x = x;</span><br><span class="line">        // 如果转入ETH，则释放Log事件</span><br><span class="line">        if(msg.value &gt; 0)&#123;</span><br><span class="line">            emit Log(msg.value, gasleft());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 读取_x</span><br><span class="line">    function getX() external view returns(uint x)&#123;</span><br><span class="line">        x = _x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个合约包含一个状态变量<code>_x</code>，一个事件<code>Log</code>在收到<code>ETH</code>时触发，三个函数：</p>
<ul>
<li><code>getBalance()</code>: 返回合约<code>ETH</code>余额。</li>
<li><code>setX()</code>: <code>external payable</code>函数，可以设置<code>_x</code>的值，并向合约发送<code>ETH</code>。</li>
<li><code>getX()</code>: 读取<code>_x</code>的值。</li>
</ul>
<h3 id="调用OtherContract合约"><a href="#调用OtherContract合约" class="headerlink" title="调用OtherContract合约"></a>调用<code>OtherContract</code>合约</h3><p>我们可以利用合约的地址和合约代码（或接口）来创建合约的引用：<code>_Name(_Address)</code>，其中<code>_Name</code>是合约名，<code>_Address</code>是合约地址。然后用合约的引用来调用它的函数：<code>_Name(_Address).f()</code>，其中<code>f()</code>是要调用的函数。</p>
<p>下面我们介绍4个调用合约的例子，在remix中编译合约后，分别部署<code>OtherContract</code>和<code>CallContract</code>：</p>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221018105502349.png" alt="image-20221018105502349"></p>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221018105511485.png" alt="image-20221018105511485"></p>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221018105524064.png" alt="image-20221018105524064"></p>
<h4 id="1-传入合约地址"><a href="#1-传入合约地址" class="headerlink" title="1. 传入合约地址"></a>1. 传入合约地址</h4><p>我们可以在函数里传入目标合约地址，生成目标合约的引用，然后调用目标函数。以调用<code>OtherContract</code>合约的<code>setX</code>函数为例，我们在新合约中写一个<code>callSetX</code>函数，传入已部署好的<code>OtherContract</code>合约地址<code>_Address</code>和<code>setX</code>的参数<code>x</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function callSetX(address _Address, uint256 x) external&#123;</span><br><span class="line">    OtherContract(_Address).setX(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制<code>OtherContract</code>合约的地址，填入<code>callSetX</code>函数的参数中，成功调用后，调用<code>OtherContract</code>合约中的<code>getX</code>验证<code>x</code>变为123</p>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221018105546892.png"></p>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221018105610605.png" alt="image-20221018105610605"></p>
<h4 id="2-传入合约变量"><a href="#2-传入合约变量" class="headerlink" title="2. 传入合约变量"></a>2. 传入合约变量</h4><p>我们可以直接在函数里传入合约的引用，只需要把上面参数的<code>address</code>类型改为目标合约名，比如<code>OtherContract</code>。下面例子实现了调用目标合约的<code>getX()</code>函数。</p>
<p><strong>注意</strong>该函数参数<code>OtherContract _Address</code>底层类型仍然是<code>address</code>，生成的<code>ABI</code>中、调用<code>callGetX</code>时传入的参数都是<code>address</code>类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function callGetX(OtherContract _Address) external view returns(uint x)&#123;</span><br><span class="line">    x = _Address.getX();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制<code>OtherContract</code>合约的地址，填入<code>callGetX</code>函数的参数中，调用后成功获取<code>x</code>的值</p>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221018105636665.png" alt="image-20221018105636665"></p>
<h4 id="3-创建合约变量"><a href="#3-创建合约变量" class="headerlink" title="3. 创建合约变量"></a>3. 创建合约变量</h4><p>我们可以创建合约变量，然后通过它来调用目标函数。下面例子，我们给变量<code>oc</code>存储了<code>OtherContract</code>合约的引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function callGetX2(address _Address) external view returns(uint x)&#123;</span><br><span class="line">    OtherContract oc = OtherContract(_Address);</span><br><span class="line">    x = oc.getX();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制<code>OtherContract</code>合约的地址，填入<code>callGetX2</code>函数的参数中，调用后成功获取<code>x</code>的值</p>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221018105659353.png" alt="image-20221018105659353"></p>
<h4 id="4-调用合约并发送ETH"><a href="#4-调用合约并发送ETH" class="headerlink" title="4. 调用合约并发送ETH"></a>4. 调用合约并发送<code>ETH</code></h4><p>如果目标合约的函数是<code>payable</code>的，那么我们可以通过调用它来给合约转账：<code>_Name(_Address).f&#123;value: _Value&#125;()</code>，其中<code>_Name</code>是合约名，<code>_Address</code>是合约地址，<code>f</code>是目标函数名，<code>_Value</code>是要转的<code>ETH</code>数额（以<code>wei</code>为单位）。</p>
<p><code>OtherContract</code>合约的<code>setX</code>函数是<code>payable</code>的，在下面这个例子中我们通过调用<code>setX</code>来往目标合约转账。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function setXTransferETH(address otherContract, uint256 x) payable external&#123;</span><br><span class="line">    OtherContract(otherContract).setX&#123;value: msg.value&#125;(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制<code>OtherContract</code>合约的地址，填入<code>setXTransferETH</code>函数的参数中，并转入10ETH</p>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221018105723578.png" alt="image-20221018105723578"></p>
<p>转账后，我们可以通过<code>Log</code>事件和<code>getBalance()</code>函数观察目标合约<code>ETH</code>余额的变化。</p>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221018105735706.png" alt="image-20221018105735706"></p>
<p>练习题：</p>
<p>首先<strong>定义了一个接口</strong> <strong>IOtherContract</strong>，然后基于此接口<strong>实现了一个具体合约</strong> <strong>OtherContract</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.6;</span><br><span class="line"></span><br><span class="line">interface IOtherContract &#123;</span><br><span class="line">    function getBalance() external returns(uint);</span><br><span class="line">    function setX(uint256 x) external payable;</span><br><span class="line">    function getX() external view returns(uint x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract OtherContract is IOtherContract&#123;</span><br><span class="line">    uint256 private _x = 0;</span><br><span class="line">    event Log(uint amount, uint gas);</span><br><span class="line">    </span><br><span class="line">    function getBalance() external view override returns(uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setX(uint256 x) external override payable&#123;</span><br><span class="line">        _x = x;</span><br><span class="line">        if(msg.value &gt; 0)&#123;</span><br><span class="line">            emit Log(msg.value, gasleft());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getX() external view override returns(uint x)&#123;</span><br><span class="line">        x = _x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设我们部署了上述合约 OtherContract，其合约地址为 <strong>0xd9145CCE52D386f254917e481eB44e9943F39138</strong>。</p>
<p>我们希望在另一个合约中调用该合约，考虑如下两种方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1) OtherContract other = OtherContract(0xd9145CCE52D386f254917e481eB44e9943F39138)</span><br><span class="line"></span><br><span class="line">(2) IOtherContract other = IOtherContract(0xd9145CCE52D386f254917e481eB44e9943F39138)</span><br></pre></td></tr></table></figure>

<p>1.下列说法正确的是：</p>
<ul>
<li><p>(1)(2) 两种写法均会报错</p>
</li>
<li><p>仅 (1) 是调用其他合约的正确写法，(2) 会报错</p>
</li>
<li><p>仅(2) 是调用其他合约的正确写法，(1) 会报错</p>
</li>
<li><p>(1)(2) 均是调用其他合约的正确写法  √</p>
</li>
</ul>
<p>我们新写了一个合约，并在合约中调用上述已部署的合约 0xd9145CCE52D386f254917e481eB44e9943F39138，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">contract MyContract &#123;</span><br><span class="line">    OtherContract other = OtherContract(0xd9145CCE52D386f254917e481eB44e9943F39138);</span><br><span class="line">    function call_getX() external view returns(uint x)&#123;</span><br><span class="line">        x = other.getX();</span><br><span class="line">    &#125;</span><br><span class="line">    function call_setX(uint256 x) external&#123;</span><br><span class="line">        other.setX(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.部署该合约，其地址为 <strong>0x9D7f74d0C41E726EC95884E0e97Fa6129e3b5E99</strong>。下列说法正确的是：</p>
<ul>
<li><p>MyContract 可以算作 OtherContract 的子类</p>
</li>
<li><p>MyContract 可以算作接口 IOtherContract 的一个实现</p>
</li>
<li><p>MyContract 需要 0xd9145CCE52D386f254917e481eB44e9943F39138 的某种许可，才可以调用其中的函数</p>
</li>
<li><p>MyContract 的函数 call_setX 可以实现，这意味着 OtherContract 中 setX 的权限没有门槛，是很大安全隐患  √</p>
</li>
</ul>
<p>3.我们尝试<strong>依次进行如下操作</strong>：<br>(1) 在0xd9145CCE52D386f254917e481eB44e9943F39138 调用函数 setX(10);</p>
<p>(2) 在 0xd9145CCE52D386f254917e481eB44e9943F39138 调用函数 getX();</p>
<p>(3) 在 0x9D7f74d0C41E726EC95884E0e97Fa6129e3b5E99 调用函数 call_setX(20);</p>
<p>(4) 在 0x9D7f74d0C41E726EC95884E0e97Fa6129e3b5E99 调用函数 call_getX();</p>
<p>下列说法正确的是：</p>
<ul>
<li><p>(2)(4) 的返回结果分别是 10, 10</p>
</li>
<li><p>(2)(4) 的返回结果分别是 10, 20  √</p>
</li>
<li><p>运行 (3) 的时候会报错，因此无法继续运行 (4)</p>
</li>
<li><p>(3) 可以顺利运行，但是运行 (4) 的时候会报错</p>
</li>
</ul>
<p>4.我们可以看到，OtherContract 中 setX 函数是 payable 的。如果我们想在已部署的合约 0xd9145CCE52D386f254917e481eB44e9943F39138 中调用 setX 的时候向合约转账 50 wei，那么正确的写法是：</p>
<ul>
<li><p>payable(0xd9145CCE52D386f254917e481eB44e9943F39138).setX(x, value&#x3D;50);</p>
</li>
<li><p>payable(0xd9145CCE52D386f254917e481eB44e9943F39138).setX{value: 50}(x);</p>
</li>
<li><p>OtherContract(0xd9145CCE52D386f254917e481eB44e9943F39138).setX(x, value&#x3D;50);</p>
</li>
<li><p>OtherContract(0xd9145CCE52D386f254917e481eB44e9943F39138).setX{value: 50}(x);  √</p>
</li>
</ul>
<h2 id="20-Call"><a href="#20-Call" class="headerlink" title="20.Call"></a>20.Call</h2><p><code>call</code> 是**<code>address</code>类型的低级成员函数**，它用来与其他合约交互。它的返回值为<code>(bool, data)</code>，分别对应<code>call</code>是否成功以及目标函数的返回值。</p>
<ul>
<li><code>call</code>是<code>solidity</code>官方推荐的通过触发<code>fallback</code>或<code>receive</code>函数发送<code>ETH</code>的方法。</li>
<li><strong>不推荐用<code>call</code>来调用另一个合约</strong>，因为当你调用不安全合约的函数时，你就把主动权交给了它。推荐的方法仍是声明合约变量后调用函数，见<a target="_blank" rel="noopener" href="https://github.com/AmazingAng/WTFSolidity/tree/main/21_CallContract">第21讲：调用其他合约</a></li>
<li>当我们不知道对方合约的源代码或<code>ABI</code>，就没法生成合约变量；这时，我们仍可以通过<code>call</code>调用对方合约的函数。</li>
</ul>
<h3 id="call的使用规则"><a href="#call的使用规则" class="headerlink" title="call的使用规则"></a><code>call</code>的使用规则</h3><p><code>call</code>的使用规则如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标合约地址.call(二进制编码);</span><br></pre></td></tr></table></figure>

<p>其中<code>二进制编码</code>利用结构化编码函数<code>abi.encodeWithSignature</code>获得：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abi.encodeWithSignature(&quot;函数签名&quot;, 逗号分隔的具体参数)</span><br></pre></td></tr></table></figure>

<p><code>函数签名</code>为<code>&quot;函数名（逗号分隔的参数类型)&quot;</code>。例如<code>abi.encodeWithSignature(&quot;f(uint256,address)&quot;, _x, _addr)</code>。</p>
<p>另外<code>call</code>在调用合约时**可以指定交易发送的<code>ETH</code>数额和<code>gas</code>**：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标合约地址.call&#123;value:发送数额, gas:gas数额&#125;(二进制编码);</span><br></pre></td></tr></table></figure>

<p>看起来有点复杂，下面我们举个<code>call</code>应用的例子。</p>
<h3 id="目标合约-1"><a href="#目标合约-1" class="headerlink" title="目标合约"></a>目标合约</h3><p>我们先写一个简单的目标合约<code>OtherContract</code>并部署，代码与“接收ETH”章节中基本相同，只是多了<code>fallback</code>函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">contract OtherContract &#123;</span><br><span class="line">    uint256 private _x = 0; // 状态变量x</span><br><span class="line">    // 收到eth的事件，记录amount和gas</span><br><span class="line">    event Log(uint amount, uint gas);</span><br><span class="line">    </span><br><span class="line">    fallback() external payable&#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 返回合约ETH余额</span><br><span class="line">    function getBalance() view public returns(uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable)</span><br><span class="line">    function setX(uint256 x) external payable&#123;</span><br><span class="line">        _x = x;</span><br><span class="line">        // 如果转入ETH，则释放Log事件</span><br><span class="line">        if(msg.value &gt; 0)&#123;</span><br><span class="line">            emit Log(msg.value, gasleft());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 读取x</span><br><span class="line">    function getX() external view returns(uint x)&#123;</span><br><span class="line">        x = _x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个合约包含一个状态变量<code>x</code>，一个在收到<code>ETH</code>时触发的事件<code>Log</code>，三个函数：</p>
<ul>
<li><code>getBalance()</code>: 返回合约<code>ETH</code>余额。</li>
<li><code>setX()</code>: <code>external payable</code>函数，可以设置<code>x</code>的值，并向合约发送<code>ETH</code>。</li>
<li><code>getX()</code>: 读取<code>x</code>的值。</li>
</ul>
<h3 id="利用call调用目标合约"><a href="#利用call调用目标合约" class="headerlink" title="利用call调用目标合约"></a>利用<code>call</code>调用目标合约</h3><p><strong>1. Response事件</strong></p>
<p>我们写一个<code>Call</code>合约来调用目标合约函数。首先定义一个<code>Response</code>事件，输出<code>call</code>返回的<code>success</code>和<code>data</code>，方便我们观察返回值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 定义Response事件，输出call返回的结果success和data</span><br><span class="line">event Response(bool success, bytes data);</span><br></pre></td></tr></table></figure>

<p><strong>2. 调用setX函数</strong></p>
<p>我们定义<code>callSetX</code>函数来调用目标合约的<code>setX()</code>，转入<code>msg.value</code>数额的<code>ETH</code>，并释放<code>Response</code>事件输出<code>success</code>和<code>data</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function callSetX(address payable _addr, uint256 x) public payable &#123;</span><br><span class="line">    // call setX()，同时可以发送ETH</span><br><span class="line">    (bool success, bytes memory data) = _addr.call&#123;value: msg.value&#125;(</span><br><span class="line">        abi.encodeWithSignature(&quot;setX(uint256)&quot;, x)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    emit Response(success, data); //释放事件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们调用<code>callSetX</code>把状态变量<code>_x</code>改为5，参数为<code>OtherContract</code>地址和<code>5</code>，由于目标函数<code>setX()</code>没有返回值，因此<code>Response</code>事件输出的<code>data</code>为<code>0x</code>，也就是空。</p>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221025101551773.png" alt="image-20221025101551773"></p>
<p><strong>3. 调用getX函数</strong></p>
<p>下面我们调用<code>getX()</code>函数，它将返回目标合约<code>_x</code>的值，类型为<code>uint256</code>。我们可以利用<code>abi.decode</code>来解码<code>call</code>的返回值<code>data</code>，并读出数值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function callGetX(address _addr) external returns(uint256)&#123;</span><br><span class="line">    // call getX()</span><br><span class="line">    (bool success, bytes memory data) = _addr.call(</span><br><span class="line">        abi.encodeWithSignature(&quot;getX()&quot;)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    emit Response(success, data); //释放事件</span><br><span class="line">    return abi.decode(data, (uint256));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<code>Response</code>事件的输出，我们可以看到<code>data</code>为<code>0x0000000000000000000000000000000000000000000000000000000000000005</code>。而经过<code>abi.decode</code>，最终返回值为<code>5</code>。</p>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221025101533665.png" alt="image-20221025101533665"></p>
<p><strong>4. 调用不存在的函数</strong></p>
<p>如果我们给<code>call</code>输入的函数不存在于目标合约，那么目标合约的<code>fallback</code>函数会被触发。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function callNonExist(address _addr) external&#123;</span><br><span class="line">    // call getX()</span><br><span class="line">    (bool success, bytes memory data) = _addr.call(</span><br><span class="line">        abi.encodeWithSignature(&quot;foo(uint256)&quot;)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    emit Response(success, data); //释放事件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子中，我们<code>call</code>了不存在的<code>foo</code>函数。<code>call</code>仍能执行成功，并返回<code>success</code>，但其实调用的目标合约<code>fallback</code>函数。</p>
<h2 id="21-Delegatecall"><a href="#21-Delegatecall" class="headerlink" title="21.Delegatecall"></a>21.Delegatecall</h2><h3 id="delegatecall"><a href="#delegatecall" class="headerlink" title="delegatecall"></a><code>delegatecall</code></h3><p><code>delegatecall</code>与<code>call</code>类似，是<code>solidity</code>中地址类型的低级成员函数。<code>delegate</code>中是委托&#x2F;代表的意思，那么<code>delegatecall</code>委托了什么？</p>
<p>当用户<code>A</code>通过合约<code>B</code>来<code>call</code>合约<code>C</code>的时候，执行的是合约<code>C</code>的函数，<code>语境</code>(<code>Context</code>，可以理解为包含变量和状态的环境)也是合约<code>C</code>的：<code>msg.sender</code>是<code>B</code>的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约<code>C</code>的变量上。</p>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221025101655586.png" alt="image-20221025101655586"></p>
<p>而当用户<code>A</code>通过合约<code>B</code>来<code>delegatecall</code>合约<code>C</code>的时候，执行的是合约<code>C</code>的函数，但是<code>语境</code>仍是合约<code>B</code>的：<code>msg.sender</code>是<code>A</code>的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约<code>B</code>的变量上。</p>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221025101708281.png" alt="image-20221025101708281"></p>
<p>大家可以这样理解：一个<code>富商</code>把它的资产（<code>状态变量</code>）都交给一个<code>VC</code>代理（<code>目标合约</code>的函数）来打理。执行的是<code>VC</code>的函数，但是改变的是<code>富商</code>的状态。</p>
<p><code>delegatecall</code>语法和<code>call</code>类似，也是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标合约地址.delegatecall(二进制编码);</span><br></pre></td></tr></table></figure>

<p>其中<code>二进制编码</code>利用结构化编码函数<code>abi.encodeWithSignature</code>获得：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abi.encodeWithSignature(&quot;函数签名&quot;, 逗号分隔的具体参数)</span><br></pre></td></tr></table></figure>

<p><code>函数签名</code>为<code>&quot;函数名（逗号分隔的参数类型)&quot;</code>。例如<code>abi.encodeWithSignature(&quot;f(uint256,address)&quot;, _x, _addr)</code>。</p>
<p>和<code>call</code>不一样，<code>delegatecall</code>在调用合约时<strong>可以指定交易发送的<code>gas</code>，但不能指定发送的<code>ETH</code>数额</strong></p>
<blockquote>
<p><strong>注意</strong>：<code>delegatecall</code>有安全隐患，使用时要保证当前合约和目标合约的状态变量存储结构相同，并且目标合约安全，不然会造成资产损失。</p>
</blockquote>
<h3 id="什么情况下会用到delegatecall"><a href="#什么情况下会用到delegatecall" class="headerlink" title="什么情况下会用到delegatecall?"></a>什么情况下会用到<code>delegatecall</code>?</h3><p>目前<code>delegatecall</code>主要有两个应用场景：</p>
<ol>
<li>代理合约（<code>Proxy Contract</code>）：将智能合约的存储合约和逻辑合约分开：<strong>代理合约（<code>Proxy Contract</code>）存储所有相关的变量，并且保存逻辑合约的地址；所有函数存在逻辑合约（<code>Logic Contract</code>）里，通过<code>delegatecall</code>执行。</strong>当升级时，只需要将代理合约指向新的逻辑合约即可。</li>
<li>EIP-2535 Diamonds（钻石）：钻石是一个支持构建可在生产中扩展的模块化智能合约系统的标准。钻石是具有多个实施合同的代理合同。 更多信息请查看：<a target="_blank" rel="noopener" href="https://eip2535diamonds.substack.com/p/introduction-to-the-diamond-standard">钻石标准简介</a>。</li>
</ol>
<h3 id="delegatecall例子"><a href="#delegatecall例子" class="headerlink" title="delegatecall例子"></a><code>delegatecall</code>例子</h3><p>调用结构：你（<code>A</code>）通过合约<code>B</code>调用目标合约<code>C</code>。</p>
<h4 id="被调用的合约C"><a href="#被调用的合约C" class="headerlink" title="被调用的合约C"></a>被调用的合约C</h4><p>我们先写一个简单的目标合约<code>C</code>：有两个<code>public</code>变量：<code>num</code>和<code>sender</code>，分别是<code>uint256</code>和<code>address</code>类型；有一个函数，可以将<code>num</code>设定为传入的<code>_num</code>，并且将<code>sender</code>设为<code>msg.sender</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 被调用的合约C</span><br><span class="line">contract C &#123;</span><br><span class="line">    uint public num;</span><br><span class="line">    address public sender;</span><br><span class="line"></span><br><span class="line">    function setVars(uint _num) public payable &#123;</span><br><span class="line">        num = _num;</span><br><span class="line">        sender = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="发起调用的合约B"><a href="#发起调用的合约B" class="headerlink" title="发起调用的合约B"></a>发起调用的合约B</h4><p>首先，合约<code>B</code>必须和目标合约<code>C</code>的变量存储布局必须相同，两个变量，并且顺序为<code>num</code>和<code>sender</code></p>
<p><strong>注意：使用delegatecall对当前合约和目标合约的状态变量的要求：变量名可以不同，变量类型、声明顺序必须相同</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract B &#123;</span><br><span class="line">    uint public num;</span><br><span class="line">    address public sender;</span><br></pre></td></tr></table></figure>

<p>接下来，我们分别用<code>call</code>和<code>delegatecall</code>来调用合约<code>C</code>的<code>setVars</code>函数，更好的理解它们的区别。</p>
<p><code>callSetVars</code>函数通过<code>call</code>来调用<code>setVars</code>。它有两个参数<code>_addr</code>和<code>_num</code>，分别对应合约<code>C</code>的地址和<code>setVars</code>的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 通过call来调用C的setVars()函数，将改变合约C里的状态变量</span><br><span class="line">function callSetVars(address _addr, uint _num) external payable&#123;</span><br><span class="line">    // call setVars()</span><br><span class="line">    (bool success, bytes memory data) = _addr.call(</span><br><span class="line">        abi.encodeWithSignature(&quot;setVars(uint256)&quot;, _num)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>delegatecallSetVars</code>函数通过<code>delegatecall</code>来调用<code>setVars</code>。与上面的<code>callSetVars</code>函数相同，有两个参数<code>_addr</code>和<code>_num</code>，分别对应合约<code>C</code>的地址和<code>setVars</code>的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    // 通过delegatecall来调用C的setVars()函数，将改变合约B里的状态变量</span><br><span class="line">    function delegatecallSetVars(address _addr, uint _num) external payable&#123;</span><br><span class="line">        // delegatecall setVars()</span><br><span class="line">        (bool success, bytes memory data) = _addr.delegatecall(</span><br><span class="line">            abi.encodeWithSignature(&quot;setVars(uint256)&quot;, _num)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：在调用时需要写明具体的类型，如上“面abi.encodeWithSignature(“setVars(uint256)”, _num)”中的uint256必须写完整，若只写uint则无法成功赋值</strong></p>
<h2 id="22-create和create2"><a href="#22-create和create2" class="headerlink" title="22.create和create2"></a>22.<code>create</code>和<code>create2</code></h2><h3 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h3><p>有两种方法可以在合约中创建新合约，<code>create</code>和<code>create2</code>，这里我们讲<code>create</code>，下一讲会介绍<code>create2</code>。</p>
<p><code>create</code>的用法很简单，就是<code>new</code>一个合约，并传入新合约构造函数所需的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Contract x = new Contract&#123;value: _value&#125;(params)</span><br></pre></td></tr></table></figure>

<p>其中<code>Contract</code>是要创建的合约名，<code>x</code>是合约对象（地址），如果构造函数是<code>payable</code>，可以创建时转入<code>_value</code>数量的<code>ETH</code>（当前合约发送给新创建合约），**<code>params</code>是新合约构造函数的参数**。</p>
<h4 id="极简Uniswap"><a href="#极简Uniswap" class="headerlink" title="极简Uniswap"></a>极简Uniswap</h4><p><code>Uniswap V2</code><a target="_blank" rel="noopener" href="https://github.com/Uniswap/v2-core/tree/master/contracts">核心合约</a>中包含两个合约：</p>
<ol>
<li>UniswapV2Pair: 币对合约，用于管理币对地址、流动性、买卖。</li>
<li>UniswapV2Factory: 工厂合约，用于创建新的币对，并管理币对地址。</li>
</ol>
<p>下面我们用<code>create</code>方法实现一个极简版的<code>Uniswap</code>：<code>Pair</code>币对合约负责管理币对地址，<code>PairFactory</code>工厂合约用于创建新的币对，并管理币对地址。</p>
<h5 id="Pair合约"><a href="#Pair合约" class="headerlink" title="Pair合约"></a><code>Pair</code>合约</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">contract Pair&#123;</span><br><span class="line">    address public factory; // 工厂合约地址</span><br><span class="line">    address public token0; // 代币1</span><br><span class="line">    address public token1; // 代币2</span><br><span class="line"></span><br><span class="line">    constructor() payable &#123;</span><br><span class="line">        factory = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // called once by the factory at time of deployment</span><br><span class="line">    function initialize(address _token0, address _token1) external &#123;</span><br><span class="line">        require(msg.sender == factory, &#x27;UniswapV2: FORBIDDEN&#x27;); // sufficient check</span><br><span class="line">        token0 = _token0;</span><br><span class="line">        token1 = _token1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Pair</code>合约很简单，包含3个状态变量：<code>factory</code>，<code>token0</code>和<code>token1</code>。</p>
<p>构造函数<code>constructor</code>在部署时将<code>factory</code>赋值为工厂合约地址。<code>initialize</code>函数会在<code>Pair</code>合约创建的时候被工厂合约调用一次，将<code>token0</code>和<code>token1</code>更新为币对中两种代币的地址。</p>
<blockquote>
<p><strong>提问</strong>：为什么<code>uniswap</code>不在<code>constructor</code>中将<code>token0</code>和<code>token1</code>地址更新好？</p>
<p><strong>答</strong>：因为<code>uniswap</code>使用的是**<code>create2</code>创建合约，限制构造函数不能有参数<strong>。当</strong>使用<code>create</code>时，<code>Pair</code>合约允许构造函数有参数**，可以在<code>constructor</code>中将<code>token0</code>和<code>token1</code>地址更新好。</p>
</blockquote>
<h5 id="PairFactory"><a href="#PairFactory" class="headerlink" title="PairFactory"></a><code>PairFactory</code></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">contract PairFactory&#123;</span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; address)) public getPair; // 通过两个代币地址查Pair地址</span><br><span class="line">    address[] public allPairs; // 保存所有Pair地址</span><br><span class="line"></span><br><span class="line">    function createPair(address tokenA, address tokenB) external returns (address pairAddr) &#123;</span><br><span class="line">        // 创建新合约</span><br><span class="line">        Pair pair = new Pair(); </span><br><span class="line">        // 调用新合约的initialize方法</span><br><span class="line">        pair.initialize(tokenA, tokenB);</span><br><span class="line">        // 更新地址map</span><br><span class="line">        pairAddr = address(pair);</span><br><span class="line">        allPairs.push(pairAddr);</span><br><span class="line">        getPair[tokenA][tokenB] = pairAddr;</span><br><span class="line">        getPair[tokenB][tokenA] = pairAddr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工厂合约（<code>PairFactory</code>）有两个状态变量<code>getPair</code>是两个代币地址到币对地址的<code>map</code>，方便根据代币找到币对地址；<code>allPairs</code>是币对地址的数组，存储了所有代币地址。</p>
<p><code>PairFactory</code>合约只有一个<code>createPair</code>函数，根据输入的两个代币地址<code>tokenA</code>和<code>tokenB</code>来创建新的<code>Pair</code>合约。其中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair pair = new Pair(); </span><br></pre></td></tr></table></figure>

<p>就是创建合约的代码，非常简单。大家可以部署好<code>PairFactory</code>合约，然后用下面两个地址作为参数调用<code>createPair</code>，看看创建的币对地址是什么：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WBNB地址: 0x2c44b726ADF1963cA47Af88B284C06f30380fC78</span><br><span class="line">BSC链上的PEOPLE地址:</span><br><span class="line">0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c</span><br></pre></td></tr></table></figure>

<p>1.使用<code>WBNB</code>和<code>PEOPLE</code>的地址作为参数调用<code>createPair</code>,得到<code>Pair</code>合约地址：0xD3e2008b4Da2cD6DEAF73471590fF30C86778A48</p>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221025104304134.png" alt="image-20221025104304134"></p>
<p>2.查看<code>Pair</code>合约变量</p>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221025104319106.png" alt="image-20221025104319106"></p>
<p>练习题：</p>
<p>1.Contract x &#x3D; new Contract{value: _value}(params)，表达式中value代表什么？</p>
<ul>
<li><p>当前合约发送给新创建合约的ETH  √</p>
</li>
<li><p>当前合约发送给新创建合约的Token</p>
</li>
<li><p>当前合约调用者发送给当前合约的ETH</p>
</li>
<li><p>当前合约调用者发送给当前合约的Token</p>
</li>
</ul>
<p>2.1个工厂合约PairFactory创建Pair合约的最大数量一般由什么决定？</p>
<ul>
<li><p>1个PairFactory只能创建1个pari合约</p>
</li>
<li><p>Pair合约逻辑</p>
</li>
<li><p>PairFactory合约逻辑  √</p>
</li>
</ul>
<h3 id="CREATE2"><a href="#CREATE2" class="headerlink" title="CREATE2"></a>CREATE2</h3><p><code>CREATE2</code> 操作码使我们在智能合约部署在以太坊网络之前就能预测合约的地址。<code>Uniswap</code>创建<code>Pair</code>合约用的就是<code>CREATE2</code>而不是<code>CREATE</code>。这一讲，我将介绍<code>CREATE2</code>的用法</p>
<h4 id="CREATE如何计算地址"><a href="#CREATE如何计算地址" class="headerlink" title="CREATE如何计算地址"></a>CREATE如何计算地址</h4><p>智能合约可以由其他合约和普通账户利用<code>CREATE</code>操作码创建。 在这两种情况下，新合约的地址都以相同的方式计算：创建者的地址(通常为部署的钱包地址或者合约地址)和<code>nonce</code>(该地址发送交易的总数,对于合约账户是创建的合约总数,每创建一个合约nonce+1))的哈希。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">新地址 = hash(创建者地址, nonce)</span><br></pre></td></tr></table></figure>

<p>创建者地址不会变，但<code>nonce</code>可能会随时间而改变，因此用<code>CREATE</code>创建的合约地址不好预测。</p>
<h4 id="CREATE2如何计算地址"><a href="#CREATE2如何计算地址" class="headerlink" title="CREATE2如何计算地址"></a>CREATE2如何计算地址</h4><p><code>CREATE2</code>的目的是为了让合约地址独立于未来的事件。不管未来区块链上发生了什么，你都可以把合约部署在事先计算好的地址上。用<code>CREATE2</code>创建的合约地址<strong>由4个部分决定</strong>：</p>
<ul>
<li><code>0xFF</code>：一个常数，避免和<code>CREATE</code>冲突</li>
<li>创建者地址</li>
<li><code>salt</code>（盐）：一个创建者给定的数值</li>
<li>待部署合约的字节码（<code>bytecode</code>）</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">新地址 = hash(&quot;0xFF&quot;,创建者地址, salt, bytecode)</span><br></pre></td></tr></table></figure>

<p><code>CREATE2</code> 确保，如果创建者使用 <code>CREATE2</code> 和提供的 <code>salt</code> 部署给定的合约<code>bytecode</code>，它将存储在 <code>新地址</code> 中。</p>
<h4 id="如何使用CREATE2"><a href="#如何使用CREATE2" class="headerlink" title="如何使用CREATE2"></a>如何使用<code>CREATE2</code></h4><p><code>CREATE2</code>的用法和之前讲的<code>Create</code>类似，同样是<code>new</code>一个合约，并传入新合约构造函数所需的参数，只不过要<strong>多传一个<code>salt</code>参数</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Contract x = new Contract&#123;salt: _salt, value: _value&#125;(params)</span><br></pre></td></tr></table></figure>

<p>其中<code>Contract</code>是要创建的合约名，<code>x</code>是合约对象（地址），<code>_salt</code>是指定的盐；如果构造函数是<code>payable</code>，可以创建时转入<code>_value</code>数量的<code>ETH</code>，<code>params</code>是新合约构造函数的参数。</p>
<h4 id="极简Uniswap2"><a href="#极简Uniswap2" class="headerlink" title="极简Uniswap2"></a>极简Uniswap2</h4><p>跟<a target="_blank" rel="noopener" href="https://mirror.xyz/dashboard/edit/kojopp2CgDK3ehHxXc_2fkZe87uM0O5OmsEU6y83eJs">上一讲</a>类似，我们用<code>Create2</code>来实现极简<code>Uniswap</code>。</p>
<h5 id="Pair"><a href="#Pair" class="headerlink" title="Pair"></a><code>Pair</code></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">contract Pair&#123;</span><br><span class="line">    address public factory; // 工厂合约地址</span><br><span class="line">    address public token0; // 代币1</span><br><span class="line">    address public token1; // 代币2</span><br><span class="line"></span><br><span class="line">    constructor() payable &#123;</span><br><span class="line">        factory = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // called once by the factory at time of deployment</span><br><span class="line">    function initialize(address _token0, address _token1) external &#123;</span><br><span class="line">        require(msg.sender == factory, &#x27;UniswapV2: FORBIDDEN&#x27;); // sufficient check</span><br><span class="line">        token0 = _token0;</span><br><span class="line">        token1 = _token1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Pair</code>合约很简单，包含3个状态变量：<code>factory</code>，<code>token0</code>和<code>token1</code>。</p>
<p>构造函数<code>constructor</code>在部署时将<code>factory</code>赋值为工厂合约地址。<code>initialize</code>函数会在<code>Pair</code>合约创建的时候被工厂合约调用一次，将<code>token0</code>和<code>token1</code>更新为币对中两种代币的地址。</p>
<h5 id="PairFactory2"><a href="#PairFactory2" class="headerlink" title="PairFactory2"></a><code>PairFactory2</code></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">contract PairFactory2&#123;</span><br><span class="line">        mapping(address =&gt; mapping(address =&gt; address)) public getPair; // 通过两个代币地址查Pair地址</span><br><span class="line">        address[] public allPairs; // 保存所有Pair地址</span><br><span class="line"></span><br><span class="line">        function createPair2(address tokenA, address tokenB) external returns (address pairAddr) &#123;</span><br><span class="line">            require(tokenA != tokenB, &#x27;IDENTICAL_ADDRESSES&#x27;); //避免tokenA和tokenB相同产生的冲突</span><br><span class="line">            // 计算用tokenA和tokenB地址计算salt</span><br><span class="line">            (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); //将tokenA和tokenB按大小排序</span><br><span class="line">            bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span><br><span class="line">            // 用create2部署新合约</span><br><span class="line">            Pair pair = new Pair&#123;salt: salt&#125;(); </span><br><span class="line">            // 调用新合约的initialize方法</span><br><span class="line">            pair.initialize(tokenA, tokenB);</span><br><span class="line">            // 更新地址map</span><br><span class="line">            pairAddr = address(pair);</span><br><span class="line">            allPairs.push(pairAddr);</span><br><span class="line">            getPair[tokenA][tokenB] = pairAddr;</span><br><span class="line">            getPair[tokenB][tokenA] = pairAddr;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>工厂合约（<code>PairFactory2</code>）有两个状态变量<code>getPair</code>是两个代币地址到币对地址的<code>map</code>，方便根据代币找到币对地址；<code>allPairs</code>是币对地址的数组，存储了所有币对地址。</p>
<p><code>PairFactory2</code>合约只有一个<code>createPair2</code>函数，使用<code>CREATE2</code>根据输入的两个代币地址<code>tokenA</code>和<code>tokenB</code>来创建新的<code>Pair</code>合约。其中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair pair = new Pair&#123;salt: salt&#125;(); </span><br></pre></td></tr></table></figure>

<p>就是利用<code>CREATE2</code>创建合约的代码，非常简单，而<code>salt</code>为<code>token1</code>和<code>token2</code>的<code>hash</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span><br></pre></td></tr></table></figure>

<h4 id="事先计算Pair地址"><a href="#事先计算Pair地址" class="headerlink" title="事先计算Pair地址"></a>事先计算<code>Pair</code>地址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 提前计算pair合约地址</span><br><span class="line">function calculateAddr(address tokenA, address tokenB) public view returns(address predictedAddress)&#123;</span><br><span class="line">    require(tokenA != tokenB, &#x27;IDENTICAL_ADDRESSES&#x27;); //避免tokenA和tokenB相同产生的冲突</span><br><span class="line">    // 计算用tokenA和tokenB地址计算salt</span><br><span class="line">    (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); //将tokenA和tokenB按大小排序</span><br><span class="line">    bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span><br><span class="line">    // 计算合约地址方法 hash()</span><br><span class="line">    predictedAddress = address(uint160(uint(keccak256(abi.encodePacked(</span><br><span class="line">        bytes1(0xff),</span><br><span class="line">        address(this),</span><br><span class="line">        salt,</span><br><span class="line">        keccak256(type(Pair).creationCode)</span><br><span class="line">    )))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们写了一个<code>calculateAddr</code>函数来事先计算<code>tokenA</code>和<code>tokenB</code>将会生成的<code>Pair</code>地址。通过它，我们可以验证我们事先计算的地址和实际地址是否相同。</p>
<p>大家可以部署好<code>PairFactory2</code>合约，然后用下面两个地址作为参数调用<code>createPair2</code>，看看创建的币对地址是什么，是否与事先计算的地址一样：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WBNB地址: 0x2c44b726ADF1963cA47Af88B284C06f30380fC78</span><br><span class="line">BSC链上的PEOPLE地址:</span><br><span class="line">0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c</span><br></pre></td></tr></table></figure>

<ol>
<li>首先用<code>WBNB</code>和<code>PEOPLE</code>的地址哈希作为<code>salt</code>来计算出<code>Pair</code>合约的地址</li>
<li>调用<code>PairFactory2.createPair2</code>传入参数为<code>WBNB</code>和<code>PEOPLE</code>的地址，获取出创建的<code>pair</code>合约地址</li>
<li>对比合约地址</li>
</ol>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221026110308665.png" alt="image-20221026110308665"></p>
<h4 id="create2的实际应用场景"><a href="#create2的实际应用场景" class="headerlink" title="create2的实际应用场景"></a>create2的实际应用场景</h4><ol>
<li>交易所为新用户预留创建钱包合约地址。</li>
<li>由 <code>CREATE2</code> 驱动的 <code>factory</code> 合约，在<code>uniswapV2</code>中交易对的创建是在 <code>Factory</code>中调用<code>create2</code>完成。这样做的好处是: 它可以得到一个确定的<code>pair</code>地址, 使得 <code>Router</code>中就可以通过 <code>(tokenA, tokenB)</code> 计算出<code>pair</code>地址, 不再需要执行一次 <code>Factory.getPair(tokenA, tokenB)</code> 的跨合约调用。</li>
</ol>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>这一讲，我们介绍了<code>CREATE2</code>操作码的原理，使用方法，并用它完成了极简版的<code>Uniswap</code>并提前计算币对合约地址。<code>CREATE2</code>让我们可以在部署合约前确定它的合约地址，这也是 一些<code>layer2</code>项目的基础。</p>
<h2 id="23-删除合约"><a href="#23-删除合约" class="headerlink" title="23.删除合约"></a>23.删除合约</h2><h3 id="selfdestruct"><a href="#selfdestruct" class="headerlink" title="selfdestruct"></a><code>selfdestruct</code></h3><p><code>selfdestruct</code>命令可以用来删除智能合约，并将该合约剩余<code>ETH</code>转到指定地址。<code>selfdestruct</code>是为了应对合约出错的极端情况而设计的。它最早被命名为<code>suicide</code>（自杀），但是这个词太敏感。为了保护抑郁的程序员，改名为<code>selfdestruct</code>。</p>
<h3 id="如何使用selfdestruct"><a href="#如何使用selfdestruct" class="headerlink" title="如何使用selfdestruct"></a>如何使用<code>selfdestruct</code></h3><p><code>selfdestruct</code>使用起来非常简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selfdestruct(_addr)；</span><br></pre></td></tr></table></figure>

<p><strong>其中<code>_addr</code>是接收合约中剩余<code>ETH</code>的地址。</strong></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">contract DeleteContract &#123;</span><br><span class="line"></span><br><span class="line">    uint public value = 10;</span><br><span class="line"></span><br><span class="line">    constructor() payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function deleteContract() external &#123;</span><br><span class="line">        // 调用selfdestruct销毁合约，并把剩余的ETH转给msg.sender</span><br><span class="line">        selfdestruct(payable(msg.sender));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalance() external view returns(uint balance)&#123;</span><br><span class="line">        balance = address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>DeleteContract</code>合约中，我们写了一个<code>public</code>状态变量<code>value</code>，两个函数：<code>getBalance()</code>用于获取合约<code>ETH</code>余额，<code>deleteContract()</code>用于自毁合约，并把<code>ETH</code>转入给发起人。</p>
<p>部署好合约后，我们向<code>DeleteContract</code>合约转入1 <code>ETH</code>。这时，<code>getBalance()</code>会返回1 <code>ETH</code>，<code>value</code>变量是10。</p>
<p>当我们调用<code>deleteContract()</code>函数，合约将自毁，所有变量都清空，此时<code>value</code>变为默认值<code>0</code>，<code>getBalance()</code>也返回空值。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>对外提供合约销毁接口时，最好设置为只有合约所有者可以调用，可以使用函数修饰符<code>onlyOwner</code>进行函数声明。</li>
<li>当合约<strong>被销毁后与智能合约的交互也能成功</strong>，并且返回0。</li>
<li>当合约中有<code>selfdestruct</code>功能时常常会带来安全问题和信任问题，合约中的Selfdestruct功能会为攻击者打开攻击向量(例如使用<code>selfdestruct</code>向一个合约频繁转入token进行攻击，这将大大节省了GAS的费用，虽然很少人这么做)，此外，此功能还会降低用户对合约的信心。</li>
</ol>
<h2 id="24-ABI编码解码"><a href="#24-ABI编码解码" class="headerlink" title="24.ABI编码解码"></a>24.ABI编码解码</h2><p><code>ABI</code> (Application Binary Interface，应用二进制接口)是与以太坊智能合约交互的标准。数据基于他们的类型编码；并且由于编码后不包含类型信息，解码时需要注明它们的类型。</p>
<p><code>Solidity</code>中，<code>ABI编码</code>有4个函数：<code>abi.encode</code>, <code>abi.encodePacked</code>, <code>abi.encodeWithSignature</code>, <code>abi.encodeWithSelector</code>。而<code>ABI解码</code>有1个函数：<code>abi.decode</code>，用于解码<code>abi.encode</code>的数据。这一讲，我们将学习如何使用这些函数。</p>
<h3 id="ABI编码"><a href="#ABI编码" class="headerlink" title="ABI编码"></a>ABI编码</h3><p>我们将用编码4个变量，他们的类型分别是<code>uint256</code>, <code>address</code>, <code>string</code>, <code>uint256[2]</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uint x = 10;</span><br><span class="line">address addr = 0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71;</span><br><span class="line">string name = &quot;0xAA&quot;;</span><br><span class="line">uint[2] array = [5, 6]; </span><br></pre></td></tr></table></figure>

<h4 id="abi-encode"><a href="#abi-encode" class="headerlink" title="abi.encode"></a><code>abi.encode</code></h4><p>将给定参数利用<a target="_blank" rel="noopener" href="https://learnblockchain.cn/docs/solidity/abi-spec.html">ABI规则</a>编码。<code>ABI</code>被设计出来跟智能合约交互，他将每个参数填充为32字节的数据，并拼接在一起。**如果你要和合约交互，你要用的就是<code>abi.encode</code>**。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function encode() public view returns(bytes memory result) &#123;</span><br><span class="line">    result = abi.encode(x, addr, name, array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编码的结果为<code>0x000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a58c0be72be218b41c608b7fe7c5bb630736c7100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000043078414100000000000000000000000000000000000000000000000000000000</code>，由于<code>abi.encode</code>将每个数据都填充为32字节，中间有很多<code>0</code>。</p>
<h4 id="abi-encodePacked"><a href="#abi-encodePacked" class="headerlink" title="abi.encodePacked"></a><code>abi.encodePacked</code></h4><p>将给定参数根据其所需最低空间编码。它类似 <code>abi.encode</code>，但是会把其中填充的很多<code>0</code>省略。比如，只用1字节来编码<code>uint</code>类型。当你想省空间，并且**不与合约交互的时候，可以使用<code>abi.encodePacked</code>**，例如算一些数据的<code>hash</code>时。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function encodePacked() public view returns(bytes memory result) &#123;</span><br><span class="line">    result = abi.encodePacked(x, addr, name, array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编码的结果为<code>0x000000000000000000000000000000000000000000000000000000000000000a7a58c0be72be218b41c608b7fe7c5bb630736c713078414100000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000006</code>，由于<code>abi.encodePacked</code>对编码进行了压缩，长度比<code>abi.encode</code>短很多。</p>
<h4 id="abi-encodeWithSignature"><a href="#abi-encodeWithSignature" class="headerlink" title="abi.encodeWithSignature"></a><code>abi.encodeWithSignature</code></h4><p>与<code>abi.encode</code>功能类似，只不过第一个参数为<code>函数签名</code>，比如<code>&quot;foo(uint256,address)&quot;</code>。当调用其他合约的时候可以使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function encodeWithSignature() public view returns(bytes memory result) &#123;</span><br><span class="line">    result = abi.encodeWithSignature(&quot;foo(uint256,address,string,uint256[2])&quot;, x, addr, name, array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编码的结果为<code>0xe87082f1000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a58c0be72be218b41c608b7fe7c5bb630736c7100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000043078414100000000000000000000000000000000000000000000000000000000</code>，等同于在<code>abi.encode</code>编码结果前加上了4字节的<code>函数选择器</code><a target="_blank" rel="noopener" href="https://wtf.academy/solidity-advanced/ABIEncode/#fn-%E8%AF%B4%E6%98%8E">说明</a>。 <a target="_blank" rel="noopener" href="https://wtf.academy/solidity-advanced/ABIEncode/#fn-%E8%AF%B4%E6%98%8E">说明</a>: 函数选择器就是通过函数名和参数进行签名处理(Keccak–Sha3)来标识函数，可以用于不同合约之间的函数调用</p>
<h4 id="abi-encodeWithSelector"><a href="#abi-encodeWithSelector" class="headerlink" title="abi.encodeWithSelector"></a><code>abi.encodeWithSelector</code></h4><p>与<code>abi.encodeWithSignature</code>功能类似，只不过第一个参数为<code>函数选择器</code>，为<code>函数签名</code>Keccak哈希的前4个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function encodeWithSelector() public view returns(bytes memory result) &#123;</span><br><span class="line">    result = abi.encodeWithSelector(bytes4(keccak256(&quot;foo(uint256,address,string,uint256[2])&quot;)), x, addr, name, array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编码的结果为<code>0xe87082f1000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a58c0be72be218b41c608b7fe7c5bb630736c7100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000043078414100000000000000000000000000000000000000000000000000000000</code>，与<code>abi.encodeWithSignature</code>结果一样。</p>
<p><strong>注意：abi.encodeWithSignature和abi.encodeWithSelector的函数表达无需将参数名称写入，只需写入参数类型即可，如“foo(uint256,address,string,uint256[2])”</strong></p>
<h3 id="ABI解码"><a href="#ABI解码" class="headerlink" title="ABI解码"></a>ABI解码</h3><h4 id="abi-decode"><a href="#abi-decode" class="headerlink" title="abi.decode"></a><code>abi.decode</code></h4><p><strong><code>abi.decode</code>用于解码<code>abi.encode</code>生成的二进制编码，将它还原成原本的参数。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function decode(bytes memory data) public pure returns(uint dx, address daddr, string memory dname, uint[2] memory darray) &#123;</span><br><span class="line">    (dx, daddr, dname, darray) = abi.decode(data, (uint, address, string, uint[2]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将<code>abi.encode</code>的二进制编码输入给<code>decode</code>，将解码出原来的参数：</p>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221026111130062.png" alt="image-20221026111130062"></p>
<ul>
<li>对比验证四种编码方法的异同点</li>
</ul>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221026111248322.png" alt="image-20221026111248322"></p>
<h3 id="ABI的使用场景"><a href="#ABI的使用场景" class="headerlink" title="ABI的使用场景"></a>ABI的使用场景</h3><ol>
<li>在合约开发中，ABI常配合call来实现对合约的底层调用。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bytes4 selector = contract.getValue.selector;</span><br><span class="line"></span><br><span class="line">bytes memory data = abi.encodeWithSelector(selector, _x);</span><br><span class="line">(bool success, bytes memory returnedData) = address(contract).staticcall(data);</span><br><span class="line">require(success);</span><br><span class="line"></span><br><span class="line">return abi.decode(returnedData, (uint256));</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>ethers.js中常用ABI实现合约的导入和函数调用。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const wavePortalContract = new ethers.Contract(contractAddress, contractABI, signer);</span><br><span class="line">/*</span><br><span class="line">    * Call the getAllWaves method from your Smart Contract</span><br><span class="line">    */</span><br><span class="line">const waves = await wavePortalContract.getAllWaves();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>对不开源合约进行反编译后，某些函数无法查到函数签名，可通过ABI进行调用。</li>
</ol>
<ul>
<li>0x533ba33a() 是一个反编译后显示的函数，只有函数编码后的结果，并且无法查到函数签名</li>
</ul>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221026111726848.png" alt="image-20221026111726848"></p>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221026111742852.png" alt="image-20221026111742852"></p>
<ul>
<li>这种情况无法通过构造interface接口或contract来进行调用</li>
</ul>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221026111808990.png" alt="image-20221026111808990"></p>
<p>这种情况下，就可以通过ABI函数选择器来调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bytes memory data = abi.encodeWithSelector(bytes4(0x533ba33a));</span><br><span class="line"></span><br><span class="line">(bool success, bytes memory returnedData) = address(contract).staticcall(data);</span><br><span class="line">require(success);</span><br><span class="line"></span><br><span class="line">return abi.decode(returnedData, (uint256));</span><br></pre></td></tr></table></figure>

<p>练习题：</p>
<p>1.当我们调用智能合约时，传递给合约的数据的前若干个字节被称为“函数选择器 (Selector)”，它告诉合约我们想要调用哪个函数。假设我们想要调用的函数在智能合约中定义声明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function foo(uint256 n, address sender, string s) public view returns(bool b)</span><br></pre></td></tr></table></figure>

<p>那么该函数对应的函数选择器为：</p>
<ul>
<li><p>“foo(uint256,address,string)”</p>
</li>
<li><p>“foo(uint256 n, address sender, string s)”</p>
</li>
<li><p>keccak(“foo(uint256,address,string)”)</p>
</li>
<li><p>keccak(“foo(uint256 n, address sender, string s)”)</p>
</li>
<li><p>bytes4(keccak(“foo(uint256,address,string)”))  √  ABI解码上方的<strong>注意</strong>做出了解释</p>
</li>
<li><p>bytes4(keccak(“foo(uint256 n, address sender, string s)”))</p>
</li>
</ul>
<p>2.已知函数foo在智能合约中定义声明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function foo(uint256 a) public view</span><br></pre></td></tr></table></figure>

<p>而字符串”foo(uint256)”的keccak256哈希值为：</p>
<p>0x2fbebd3821c4e005fbe0a9002cc1bd25dc266d788dba1dbcb39cc66a07e7b38b</p>
<p>那么，当我们希望调用函数foo()时，以下生成调用数据的写法中，<strong>正确且最节省gas</strong>的一项是：</p>
<ul>
<li><p>abi.encodeWithSignature(“foo(uint256)”, a)</p>
</li>
<li><p>abi.encodeWithSelector(“foo(uint256)”, a)</p>
</li>
<li><p>abi.encodeWithSelector(bytes(keccak256(“foo(uint256)”)), a)</p>
</li>
<li><p>abi.encodeWithSelector(bytes4(0x2fbebd38), a)   √   疑问：这里需把 a 写进来，但是上面的讲解却没有放入 a，个人感觉上面写错，因为写 a 进去的目的是确定你所截取的4个字节来源</p>
</li>
</ul>
<h2 id="25-Hash"><a href="#25-Hash" class="headerlink" title="25.Hash"></a>25.Hash</h2><p>哈希函数（hash function）是一个密码学概念，它可以将任意长度的消息转换为一个固定长度的值，这个值也称作哈希（hash）。这一讲，我们简单介绍一下哈希函数及在<code>solidity</code>的应用</p>
<h3 id="Hash的性质"><a href="#Hash的性质" class="headerlink" title="Hash的性质"></a>Hash的性质</h3><p>一个好的哈希函数应该具有以下几个特性：</p>
<ul>
<li>单向性：从输入的消息到它的哈希的正向运算简单且唯一确定，而反过来非常难，只能靠暴力枚举。</li>
<li>灵敏性：输入的消息改变一点对它的哈希改变很大。</li>
<li>高效性：从输入的消息到哈希的运算高效。</li>
<li>均一性：每个哈希值被取到的概率应该基本相等。</li>
<li>抗碰撞性：<ul>
<li>弱抗碰撞性：给定一个消息<code>x</code>，找到另一个消息<code>x&#39;</code>使得<code>hash(x) = hash(x&#39;)</code>是困难的。</li>
<li>强抗碰撞性：找到任意<code>x</code>和<code>x&#39;</code>，使得<code>hash(x) = hash(x&#39;)</code>是困难的。</li>
</ul>
</li>
</ul>
<h3 id="Hash的应用"><a href="#Hash的应用" class="headerlink" title="Hash的应用"></a>Hash的应用</h3><ul>
<li>生成数据唯一标识</li>
<li>加密签名</li>
<li>安全加密</li>
</ul>
<h3 id="Keccak256"><a href="#Keccak256" class="headerlink" title="Keccak256"></a>Keccak256</h3><p><code>Keccak256</code>函数是<code>solidity</code>中最常用的哈希函数，用法非常简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">哈希 = keccak256(数据);</span><br></pre></td></tr></table></figure>

<h4 id="Keccak256和sha3"><a href="#Keccak256和sha3" class="headerlink" title="Keccak256和sha3"></a>Keccak256和sha3</h4><p>这是一个很有趣的事情：</p>
<ol>
<li>sha3由keccak标准化而来，在很多场合下Keccak和SHA3是同义词，但在2015年8月SHA3最终完成标准化时，NIST调整了填充算法。<strong>所以SHA3就和keccak计算的结果不一样</strong>，这点在实际开发中要注意。</li>
<li>以太坊在开发的时候sha3还在标准化中，所以采用了keccak，所以<strong>Ethereum和Solidity智能合约代码中的SHA3是指Keccak256</strong>，而不是标准的NIST-SHA3，为了避免混淆，直接在合约代码中写成Keccak256是最清晰的。</li>
</ol>
<h4 id="生成数据唯一标识"><a href="#生成数据唯一标识" class="headerlink" title="生成数据唯一标识"></a>生成数据唯一标识</h4><p>我们可以利用<code>keccak256</code>来生成一些数据的唯一标识。比如我们有几个不同类型的数据：<code>uint</code>，<code>string</code>，<code>address</code>，我们可以先用<code>abi.encodePacked</code>方法将他们打包编码，然后再用<code>keccak256</code>来生成唯一标识：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function hash(uint _num,string memory _string,address _addr</span><br><span class="line">) public pure returns (bytes32) &#123;</span><br><span class="line">    return keccak256(abi.encodePacked(_num, _string, _addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="弱抗碰撞性"><a href="#弱抗碰撞性" class="headerlink" title="弱抗碰撞性"></a>弱抗碰撞性</h4><p>我们用<code>keccak256</code>演示一下之前讲到的弱抗碰撞性，即给定一个消息<code>x</code>，找到另一个消息<code>x&#39;</code>使得<code>hash(x) = hash(x&#39;)</code>是困难的。</p>
<p>我们给定一个消息<code>0xAA</code>，试图去找另一个消息，使得它们的哈希值相等：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 弱抗碰撞性</span><br><span class="line">function weak(string memory string1)public view returns (bool)&#123;</span><br><span class="line">    return keccak256(abi.encodePacked(string1)) == _msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家可以试个10次，看看能不能幸运的碰撞上。</p>
<h4 id="强抗碰撞性"><a href="#强抗碰撞性" class="headerlink" title="强抗碰撞性"></a>强抗碰撞性</h4><p>我们用<code>keccak256</code>演示一下之前讲到的强抗碰撞性，即找到任意不同的<code>x</code>和<code>x&#39;</code>，使得<code>hash(x) = hash(x&#39;)</code>是困难的。</p>
<p>我们构造一个函数<code>strong</code>，接收两个不同的<code>string</code>参数<code>string1</code>和<code>string2</code>，然后判断它们的哈希是否相同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 强抗碰撞性</span><br><span class="line">function strong(string memory string1,string memory string2)public pure returns (bool)&#123;</span><br><span class="line">    return keccak256(abi.encodePacked(string1)) == keccak256(abi.encodePacked(string2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家可以试个10次，看看能不能幸运的碰撞上。</p>
<p>练习题：</p>
<p>一个好的哈希函数应当包含以下几种特性：单向性、灵敏性、高效性、均一性、抗碰撞性。下列关于这些特性中，描述<strong>不正确</strong>的一项是：</p>
<p>单向性意味着哈希函数的正向运算易于计算且结果唯一，而逆向运算只能靠暴力枚举</p>
<p>灵敏性意味着哈希函数输入的小幅改变应当对应着输出的大幅改变</p>
<p>强抗碰撞性意味着哈希函数的任意两个输入对应的输出都不同  √  <strong>应该为任意两个不同的输入</strong></p>
<p>对于一个哈希函数而言，强抗碰撞性比弱抗碰撞性更难满足</p>
<h2 id="26-选择器"><a href="#26-选择器" class="headerlink" title="26.选择器"></a>26.选择器</h2><h3 id="selector"><a href="#selector" class="headerlink" title="selector"></a><code>selector</code></h3><p>当我们调用智能合约时，本质上是向目标合约发送了一段<code>calldata</code>，在remix中发送一次交易后，可以在详细信息中看见<code>input</code>即为此次交易的<code>calldata</code></p>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221027112003162.png" alt="image-20221027112003162"></p>
<p>发送的<code>calldata</code>中前4个字节是<code>selector</code>（函数选择器）。</p>
<h4 id="msg-data"><a href="#msg-data" class="headerlink" title="msg.data"></a><code>msg.data</code></h4><p><code>msg.data</code>是<code>solidity</code>中的一个全局变量，值为<strong>完整的</strong><code>calldata</code>（调用函数时传入的数据）。</p>
<p>在下面的代码中，我们可以通过<code>Log</code>事件来输出调用<code>mint</code>函数的<code>calldata</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// event 返回msg.data</span><br><span class="line">event Log(bytes data);</span><br><span class="line"></span><br><span class="line">function mint(address to) external&#123;</span><br><span class="line">    emit Log(msg.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当参数为<code>0x2c44b726ADF1963cA47Af88B284C06f30380fC78</code>时，输出的<code>calldata</code>为</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x6a6278420000000000000000000000002c44b726adf1963ca47af88b284c06f30380fc78</span><br></pre></td></tr></table></figure>

<p>这段很乱的字节码可以分成两部分：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">前4个字节为函数选择器selector：</span><br><span class="line">0x6a627842</span><br><span class="line"></span><br><span class="line">后面32个字节为输入的参数：</span><br><span class="line">0x0000000000000000000000002c44b726adf1963ca47af88b284c06f30380fc78</span><br></pre></td></tr></table></figure>

<p>其实<code>calldata</code>就是告诉智能合约，我要调用哪个函数，以及参数是什么。</p>
<h4 id="method-id、selector和函数签名"><a href="#method-id、selector和函数签名" class="headerlink" title="method id、selector和函数签名"></a><code>method id</code>、<code>selector</code>和<code>函数签名</code></h4><p><code>method id</code>定义为<code>函数签名</code>的<code>Keccak</code>哈希后的<strong>前4个字节</strong>，当<code>selector</code>与<code>method id</code>相匹配时，即表示调用该函数，那么<code>函数签名</code>是什么？</p>
<p>其实在调用其他合约章节中，我们简单介绍了函数签名，为<code>&quot;函数名（逗号分隔的参数类型)&quot;</code>。举个例子，上面代码中<code>mint</code>的函数签名为<code>&quot;mint(address)&quot;</code>。在同一个智能合约中，不同的函数有不同的函数签名，因此我们可以通过函数签名来确定要调用哪个函数。</p>
<p><strong>注意，在函数签名中，<code>uint</code>和<code>int</code>要写为<code>uint256</code>和<code>int256</code>。</strong></p>
<p>我们写一个函数，来验证<code>mint</code>函数的<code>method id</code>是否为<code>0x6a627842</code>。大家可以运行下面的函数，看看结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function mintSelector() external pure returns(bytes4 mSelector)&#123;</span><br><span class="line">    return bytes4(keccak256(&quot;mint(address)&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果正是<code>0x6a627842</code>：</p>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221027112030677.png" alt="image-20221027112030677"></p>
<h4 id="使用selector"><a href="#使用selector" class="headerlink" title="使用selector"></a>使用<code>selector</code></h4><p>我们可以利用<code>selector</code>来调用目标函数。例如我想调用<code>mint</code>函数，我只需要利用<code>abi.encodeWithSelector</code>将<code>mint</code>函数的<code>method id</code>作为<code>selector</code>和参数打包编码，传给<code>call</code>函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function callWithSignature() external returns(bool, bytes memory)&#123;</span><br><span class="line">    (bool success, bytes memory data) = address(this).call(abi.encodeWithSelector(0x6a627842, &quot;0x2c44b726ADF1963cA47Af88B284C06f30380fC78&quot;));</span><br><span class="line">    return(success, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在日志中，我们可以看到<code>mint</code>函数被成功调用，并输出<code>Log</code>事件。</p>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221027112047366.png" alt="image-20221027112047366"></p>
<p>练习题：</p>
<p>transfer函数的函数签名是？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function transfer(address recipient, uint amount) external override returns (bool) &#123;</span><br><span class="line">        balanceOf[msg.sender] -= amount;</span><br><span class="line">        balanceOf[recipient] += amount;</span><br><span class="line">        emit Transfer(msg.sender, recipient, amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>“transfer()”</li>
<li>“transfer(address,uint)”</li>
<li>“transfer(address,uint256)”   √   类型需写完整</li>
<li>“function transfer(address,uint256)”</li>
</ul>
<h2 id="27-Try-Catch"><a href="#27-Try-Catch" class="headerlink" title="27.Try Catch"></a>27.Try Catch</h2><p><code>try-catch</code>是现代编程语言几乎都有的处理异常的一种标准方式，<code>solidity</code>0.6版本也添加了它。</p>
<h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a><code>try-catch</code></h3><p>在<code>solidity</code>中，<code>try-catch</code><strong>只能被用于<code>external</code>函数或创建合约时<code>constructor</code>（被视为<code>external</code>函数）的调用</strong>。基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try externalContract.f() &#123;</span><br><span class="line">    // call成功的情况下 运行一些代码</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    // call失败的情况下 运行一些代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>externalContract.f()</code>是某个外部合约的函数调用，<code>try</code>模块在调用成功的情况下运行，而<code>catch</code>模块则在调用失败时运行。</p>
<p>同样可以使用<code>this.f()</code>来替代<code>externalContract.f()</code>，<code>this.f()</code>也被视作为外部调用，但不可在构造函数中使用，因为此时合约还未创建。</p>
<p><strong>如果调用的函数有返回值，那么必须在<code>try</code>之后声明<code>returns(returnType val)</code>，并且在<code>try</code>模块中可以使用返回的变量；如果是创建合约，那么返回值是新创建的合约变量。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try externalContract.f() returns(returnType val)&#123;</span><br><span class="line">    // call成功的情况下 运行一些代码</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    // call失败的情况下 运行一些代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，<code>catch</code>模块支持捕获特殊的异常原因：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try externalContract.f() returns(returnType)&#123;</span><br><span class="line">    // call成功的情况下 运行一些代码</span><br><span class="line">&#125; catch Error(string memory reason) &#123;</span><br><span class="line">    // 捕获失败的 revert() 和 require()</span><br><span class="line">&#125; catch (bytes memory reason) &#123;</span><br><span class="line">    // 捕获失败的 assert()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="try-catch实战"><a href="#try-catch实战" class="headerlink" title="try-catch实战"></a><code>try-catch</code>实战</h3><h4 id="OnlyEven"><a href="#OnlyEven" class="headerlink" title="OnlyEven"></a><code>OnlyEven</code></h4><p>我们创建一个外部合约<code>OnlyEven</code>，并使用<code>try-catch</code>来处理异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">contract OnlyEven&#123;</span><br><span class="line">    constructor(uint a)&#123;</span><br><span class="line">        require(a != 0, &quot;invalid number&quot;);</span><br><span class="line">        assert(a != 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function onlyEven(uint256 b) external pure returns(bool success)&#123;</span><br><span class="line">        // 输入奇数时revert</span><br><span class="line">        require(b % 2 == 0, &quot;Ups! Reverting&quot;);</span><br><span class="line">        success = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>OnlyEven</code>合约包含一个构造函数和一个<code>onlyEven</code>函数。</p>
<ul>
<li>构造函数有一个参数<code>a</code>，当<code>a=0</code>时，<code>require</code>会抛出异常；当<code>a=1</code>时，<code>assert</code>会抛出异常；其他情况均正常。</li>
<li><code>onlyEven</code>函数有一个参数<code>b</code>，当<code>b</code>为奇数时，<code>require</code>会抛出异常。</li>
</ul>
<h4 id="处理外部函数调用异常"><a href="#处理外部函数调用异常" class="headerlink" title="处理外部函数调用异常"></a>处理外部函数调用异常</h4><p>首先，在<code>TryCatch</code>合约中定义一些事件和状态变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 成功event</span><br><span class="line">event SuccessEvent();</span><br><span class="line"></span><br><span class="line">// 失败event</span><br><span class="line">event CatchEvent(string message);</span><br><span class="line">event CatchByte(bytes data);</span><br><span class="line"></span><br><span class="line">// 声明OnlyEven合约变量</span><br><span class="line">OnlyEven even;</span><br><span class="line"></span><br><span class="line">constructor() &#123;</span><br><span class="line">    even = new OnlyEven(2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SuccessEvent</code>是调用成功会释放的事件，而<code>CatchEvent</code>和<code>CatchByte</code>是抛出异常时会释放的事件，分别对应<code>require/revert</code>和<code>assert</code>异常的情况。<code>even</code>是个<code>OnlyEven</code>合约类型的状态变量。</p>
<p>然后我们在<code>execute</code>函数中使用<code>try-catch</code>处理调用外部函数<code>onlyEven</code>中的异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 在external call中使用try-catch</span><br><span class="line">function execute(uint amount) external returns (bool success) &#123;</span><br><span class="line">    try even.onlyEven(amount) returns(bool _success)&#123;</span><br><span class="line">        // call成功的情况下</span><br><span class="line">        emit SuccessEvent();</span><br><span class="line">        return _success;</span><br><span class="line">    &#125; catch Error(string memory reason)&#123;</span><br><span class="line">        // call不成功的情况下</span><br><span class="line">        emit CatchEvent(reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在remix上验证"><a href="#在remix上验证" class="headerlink" title="在remix上验证"></a>在remix上验证</h4><p>当运行<code>execute(0)</code>的时候，因为<code>0</code>为偶数，满足<code>require(b % 2 == 0, &quot;Ups! Reverting&quot;);</code>，没有异常抛出，调用成功并释放<code>SuccessEvent</code>事件。</p>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221027112359783.png" alt="image-20221027112359783"></p>
<p>当运行<code>execute(1)</code>的时候，因为<code>1</code>为奇数，不满足<code>require(b % 2 == 0, &quot;Ups! Reverting&quot;);</code>，异常抛出，调用失败并释放<code>CatchEvent</code>事件。<img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221027112414108.png" alt="image-20221027112414108"></p>
<h4 id="处理合约创建异常"><a href="#处理合约创建异常" class="headerlink" title="处理合约创建异常"></a>处理合约创建异常</h4><p>这里，我们利用<code>try-catch</code>来处理合约创建时的异常。只需要把<code>try</code>模块改写为<code>OnlyEven</code>合约的创建就行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 在创建新合约中使用try-catch （合约创建被视为external call）</span><br><span class="line">// executeNew(0)会失败并释放`CatchEvent`</span><br><span class="line">// executeNew(1)会失败并释放`CatchByte`</span><br><span class="line">// executeNew(2)会成功并释放`SuccessEvent`</span><br><span class="line">function executeNew(uint a) external returns (bool success) &#123;</span><br><span class="line">    try new OnlyEven(a) returns(OnlyEven _even)&#123;</span><br><span class="line">        // call成功的情况下</span><br><span class="line">        emit SuccessEvent();</span><br><span class="line">        success = _even.onlyEven(a);</span><br><span class="line">    &#125; catch Error(string memory reason) &#123;</span><br><span class="line">        // catch失败的 revert() 和 require()</span><br><span class="line">        emit CatchEvent(reason);</span><br><span class="line">    &#125; catch (bytes memory reason) &#123;</span><br><span class="line">        // catch失败的 assert()</span><br><span class="line">        emit CatchByte(reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在remix上验证-1"><a href="#在remix上验证-1" class="headerlink" title="在remix上验证"></a>在remix上验证</h4><p>当运行<code>executeNew(0)</code>时，因为<code>0</code>不满足<code>require(a != 0, &quot;invalid number&quot;);</code>，会失败并释放<code>CatchEvent</code>事件。</p>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221027112454454.png" alt="image-20221027112454454"></p>
<p>当运行<code>executeNew(1)</code>时，因为<code>1</code>不满足<code>assert(a != 1);</code>，会失败并释放<code>CatchByte</code>事件。</p>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221027112509450.png" alt="image-20221027112509450"></p>
<p>当运行<code>executeNew(2)</code>时，因为<code>2</code>满足<code>require(a != 0, &quot;invalid number&quot;);</code>和<code>assert(a != 1);</code>，会成功并释放<code>SuccessEvent</code>事件。</p>
<p><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/image-20221027112525411.png" alt="image-20221027112525411"></p>
<p>练习题：</p>
<p>1.以下异常返回值类型为bytes的是：</p>
<ul>
<li>revert()</li>
<li>require()</li>
<li>assert()</li>
<li>以上都是  √</li>
</ul>
<p>2.try-catch捕获到异常后是否会使try-catch所在的方法调用失败？</p>
<ul>
<li>会</li>
<li>不会  √</li>
</ul>
<p>3.try代码块内的revert是否会被catch本身捕获？ </p>
<ul>
<li>会</li>
<li>不会  √  此处与JavaScript类似</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://DestinyWei.github.io">浩烬</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://destinywei.github.io/post/solidity%E8%BF%9B%E9%98%B6.html">https://destinywei.github.io/post/solidity%E8%BF%9B%E9%98%B6.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://DestinyWei.github.io" target="_blank">浩烬的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Solidity/">Solidity</a></div><div class="post_share"><div class="social-share" data-image="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/Solidity进阶.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/%E6%9C%89%E9%81%93%E7%BF%BB%E8%AF%91%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB%E7%A0%B4%E8%A7%A3.html"><img class="prev-cover" src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/blog-picture.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">有道翻译简单爬虫破解</div></div></a></div><div class="next-post pull-right"><a href="/post/Solidity%E5%85%A5%E9%97%A8.html"><img class="next-cover" src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/Solidity入门.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Solidity学习笔记(一)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/Solidity%E5%85%A5%E9%97%A8.html" title="Solidity学习笔记(一)"><img class="cover" src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/Solidity入门.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-10</div><div class="title">Solidity学习笔记(一)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/头像3.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">浩烬</div><div class="author-info__description">坚持就是胜利</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/DestinyWei"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/DestinyWei" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1342348280@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的Blog频道，若有疑问，请联系我的QQ：1342348280</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Solidity%E8%BF%9B%E9%98%B6"><span class="toc-number">1.</span> <span class="toc-text">Solidity进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E9%87%8D%E8%BD%BD"><span class="toc-number">1.1.</span> <span class="toc-text">14.重载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">1.1.1.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E5%8F%82%E5%8C%B9%E9%85%8D%EF%BC%88Argument-Matching%EF%BC%89"><span class="toc-number">1.1.2.</span> <span class="toc-text">实参匹配（Argument Matching）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E5%BA%93%E5%90%88%E7%BA%A6"><span class="toc-number">1.2.</span> <span class="toc-text">15.库合约</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9AString%E5%BA%93%E5%90%88%E7%BA%A6"><span class="toc-number">1.2.1.</span> <span class="toc-text">示例：String库合约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%BA%93%E5%90%88%E7%BA%A6"><span class="toc-number">1.2.2.</span> <span class="toc-text">如何使用库合约</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-import"><span class="toc-number">1.3.</span> <span class="toc-text">16.import</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#import%E7%94%A8%E6%B3%95"><span class="toc-number">1.3.1.</span> <span class="toc-text">import用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%AF%BC%E5%85%A5%E7%BB%93%E6%9E%9C"><span class="toc-number">1.3.2.</span> <span class="toc-text">测试导入结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E6%8E%A5%E6%94%B6ETH"><span class="toc-number">1.4.</span> <span class="toc-text">17.接收ETH</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6ETH%E5%87%BD%E6%95%B0-receive"><span class="toc-number">1.4.1.</span> <span class="toc-text">接收ETH函数 receive</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E9%80%80%E5%87%BD%E6%95%B0-fallback"><span class="toc-number">1.4.2.</span> <span class="toc-text">回退函数 fallback</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#receive%E5%92%8Cfallback%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.3.</span> <span class="toc-text">receive和fallback的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E5%8F%91%E9%80%81ETH"><span class="toc-number">1.5.</span> <span class="toc-text">18.发送ETH</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6ETH%E5%90%88%E7%BA%A6"><span class="toc-number">1.5.1.</span> <span class="toc-text">接收ETH合约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81ETH%E5%90%88%E7%BA%A6"><span class="toc-number">1.5.2.</span> <span class="toc-text">发送ETH合约</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#transfer"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">transfer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#send"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">send</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#call"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">call</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E8%B0%83%E7%94%A8%E5%85%B6%E5%AE%83%E5%90%88%E7%BA%A6"><span class="toc-number">1.6.</span> <span class="toc-text">19.调用其它合约</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E5%90%88%E7%BA%A6"><span class="toc-number">1.6.1.</span> <span class="toc-text">目标合约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8OtherContract%E5%90%88%E7%BA%A6"><span class="toc-number">1.6.2.</span> <span class="toc-text">调用OtherContract合约</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BC%A0%E5%85%A5%E5%90%88%E7%BA%A6%E5%9C%B0%E5%9D%80"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">1. 传入合约地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BC%A0%E5%85%A5%E5%90%88%E7%BA%A6%E5%8F%98%E9%87%8F"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">2. 传入合约变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%9B%E5%BB%BA%E5%90%88%E7%BA%A6%E5%8F%98%E9%87%8F"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">3. 创建合约变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%B0%83%E7%94%A8%E5%90%88%E7%BA%A6%E5%B9%B6%E5%8F%91%E9%80%81ETH"><span class="toc-number">1.6.2.4.</span> <span class="toc-text">4. 调用合约并发送ETH</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-Call"><span class="toc-number">1.7.</span> <span class="toc-text">20.Call</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#call%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-number">1.7.1.</span> <span class="toc-text">call的使用规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E5%90%88%E7%BA%A6-1"><span class="toc-number">1.7.2.</span> <span class="toc-text">目标合约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8call%E8%B0%83%E7%94%A8%E7%9B%AE%E6%A0%87%E5%90%88%E7%BA%A6"><span class="toc-number">1.7.3.</span> <span class="toc-text">利用call调用目标合约</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-Delegatecall"><span class="toc-number">1.8.</span> <span class="toc-text">21.Delegatecall</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#delegatecall"><span class="toc-number">1.8.1.</span> <span class="toc-text">delegatecall</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E7%94%A8%E5%88%B0delegatecall"><span class="toc-number">1.8.2.</span> <span class="toc-text">什么情况下会用到delegatecall?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#delegatecall%E4%BE%8B%E5%AD%90"><span class="toc-number">1.8.3.</span> <span class="toc-text">delegatecall例子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84%E5%90%88%E7%BA%A6C"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">被调用的合约C</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E8%B5%B7%E8%B0%83%E7%94%A8%E7%9A%84%E5%90%88%E7%BA%A6B"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">发起调用的合约B</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-create%E5%92%8Ccreate2"><span class="toc-number">1.9.</span> <span class="toc-text">22.create和create2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Create"><span class="toc-number">1.9.1.</span> <span class="toc-text">Create</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%81%E7%AE%80Uniswap"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">极简Uniswap</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Pair%E5%90%88%E7%BA%A6"><span class="toc-number">1.9.1.1.1.</span> <span class="toc-text">Pair合约</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PairFactory"><span class="toc-number">1.9.1.1.2.</span> <span class="toc-text">PairFactory</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CREATE2"><span class="toc-number">1.9.2.</span> <span class="toc-text">CREATE2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CREATE%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%9C%B0%E5%9D%80"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">CREATE如何计算地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CREATE2%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%9C%B0%E5%9D%80"><span class="toc-number">1.9.2.2.</span> <span class="toc-text">CREATE2如何计算地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8CREATE2"><span class="toc-number">1.9.2.3.</span> <span class="toc-text">如何使用CREATE2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%81%E7%AE%80Uniswap2"><span class="toc-number">1.9.2.4.</span> <span class="toc-text">极简Uniswap2</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Pair"><span class="toc-number">1.9.2.4.1.</span> <span class="toc-text">Pair</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PairFactory2"><span class="toc-number">1.9.2.4.2.</span> <span class="toc-text">PairFactory2</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%85%88%E8%AE%A1%E7%AE%97Pair%E5%9C%B0%E5%9D%80"><span class="toc-number">1.9.2.5.</span> <span class="toc-text">事先计算Pair地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#create2%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.9.2.6.</span> <span class="toc-text">create2的实际应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.9.2.7.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%88%A0%E9%99%A4%E5%90%88%E7%BA%A6"><span class="toc-number">1.10.</span> <span class="toc-text">23.删除合约</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#selfdestruct"><span class="toc-number">1.10.1.</span> <span class="toc-text">selfdestruct</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8selfdestruct"><span class="toc-number">1.10.2.</span> <span class="toc-text">如何使用selfdestruct</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">1.10.3.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.10.4.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-ABI%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81"><span class="toc-number">1.11.</span> <span class="toc-text">24.ABI编码解码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ABI%E7%BC%96%E7%A0%81"><span class="toc-number">1.11.1.</span> <span class="toc-text">ABI编码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#abi-encode"><span class="toc-number">1.11.1.1.</span> <span class="toc-text">abi.encode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#abi-encodePacked"><span class="toc-number">1.11.1.2.</span> <span class="toc-text">abi.encodePacked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#abi-encodeWithSignature"><span class="toc-number">1.11.1.3.</span> <span class="toc-text">abi.encodeWithSignature</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#abi-encodeWithSelector"><span class="toc-number">1.11.1.4.</span> <span class="toc-text">abi.encodeWithSelector</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ABI%E8%A7%A3%E7%A0%81"><span class="toc-number">1.11.2.</span> <span class="toc-text">ABI解码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#abi-decode"><span class="toc-number">1.11.2.1.</span> <span class="toc-text">abi.decode</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ABI%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.11.3.</span> <span class="toc-text">ABI的使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-Hash"><span class="toc-number">1.12.</span> <span class="toc-text">25.Hash</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">1.12.1.</span> <span class="toc-text">Hash的性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.12.2.</span> <span class="toc-text">Hash的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Keccak256"><span class="toc-number">1.12.3.</span> <span class="toc-text">Keccak256</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Keccak256%E5%92%8Csha3"><span class="toc-number">1.12.3.1.</span> <span class="toc-text">Keccak256和sha3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86"><span class="toc-number">1.12.3.2.</span> <span class="toc-text">生成数据唯一标识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%B1%E6%8A%97%E7%A2%B0%E6%92%9E%E6%80%A7"><span class="toc-number">1.12.3.3.</span> <span class="toc-text">弱抗碰撞性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E6%8A%97%E7%A2%B0%E6%92%9E%E6%80%A7"><span class="toc-number">1.12.3.4.</span> <span class="toc-text">强抗碰撞性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">1.13.</span> <span class="toc-text">26.选择器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#selector"><span class="toc-number">1.13.1.</span> <span class="toc-text">selector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#msg-data"><span class="toc-number">1.13.1.1.</span> <span class="toc-text">msg.data</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#method-id%E3%80%81selector%E5%92%8C%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D"><span class="toc-number">1.13.1.2.</span> <span class="toc-text">method id、selector和函数签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8selector"><span class="toc-number">1.13.1.3.</span> <span class="toc-text">使用selector</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-Try-Catch"><span class="toc-number">1.14.</span> <span class="toc-text">27.Try Catch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#try-catch"><span class="toc-number">1.14.1.</span> <span class="toc-text">try-catch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try-catch%E5%AE%9E%E6%88%98"><span class="toc-number">1.14.2.</span> <span class="toc-text">try-catch实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OnlyEven"><span class="toc-number">1.14.2.1.</span> <span class="toc-text">OnlyEven</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%BC%82%E5%B8%B8"><span class="toc-number">1.14.2.2.</span> <span class="toc-text">处理外部函数调用异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8remix%E4%B8%8A%E9%AA%8C%E8%AF%81"><span class="toc-number">1.14.2.3.</span> <span class="toc-text">在remix上验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%90%88%E7%BA%A6%E5%88%9B%E5%BB%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">1.14.2.4.</span> <span class="toc-text">处理合约创建异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8remix%E4%B8%8A%E9%AA%8C%E8%AF%81-1"><span class="toc-number">1.14.2.5.</span> <span class="toc-text">在remix上验证</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/ETHBeijing%20Hackthon.html" title="ETHBeijing游记"><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/ETHBeijingHackthon.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ETHBeijing游记"/></a><div class="content"><a class="title" href="/post/ETHBeijing%20Hackthon.html" title="ETHBeijing游记">ETHBeijing游记</a><time datetime="2023-04-18T16:23:31.912Z" title="发表于 2023-04-19 00:23:31">2023-04-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8.html" title="北京大学肖臻老师《区块链技术与应用》公开课"><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/区块链.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="北京大学肖臻老师《区块链技术与应用》公开课"/></a><div class="content"><a class="title" href="/post/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8.html" title="北京大学肖臻老师《区块链技术与应用》公开课">北京大学肖臻老师《区块链技术与应用》公开课</a><time datetime="2023-04-10T11:17:41.356Z" title="发表于 2023-04-10 19:17:41">2023-04-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/%E6%9C%89%E9%81%93%E7%BF%BB%E8%AF%91%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB%E7%A0%B4%E8%A7%A3.html" title="有道翻译简单爬虫破解"><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/blog-picture.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="有道翻译简单爬虫破解"/></a><div class="content"><a class="title" href="/post/%E6%9C%89%E9%81%93%E7%BF%BB%E8%AF%91%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB%E7%A0%B4%E8%A7%A3.html" title="有道翻译简单爬虫破解">有道翻译简单爬虫破解</a><time datetime="2023-04-10T11:17:41.354Z" title="发表于 2023-04-10 19:17:41">2023-04-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/solidity%E8%BF%9B%E9%98%B6.html" title="Solidity学习笔记(二)"><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/Solidity进阶.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Solidity学习笔记(二)"/></a><div class="content"><a class="title" href="/post/solidity%E8%BF%9B%E9%98%B6.html" title="Solidity学习笔记(二)">Solidity学习笔记(二)</a><time datetime="2023-04-10T11:17:41.354Z" title="发表于 2023-04-10 19:17:41">2023-04-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/Solidity%E5%85%A5%E9%97%A8.html" title="Solidity学习笔记(一)"><img src="https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/Solidity入门.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Solidity学习笔记(一)"/></a><div class="content"><a class="title" href="/post/Solidity%E5%85%A5%E9%97%A8.html" title="Solidity学习笔记(一)">Solidity学习笔记(一)</a><time datetime="2023-04-10T11:17:41.353Z" title="发表于 2023-04-10 19:17:41">2023-04-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://weihaoming-tuchuang.oss-cn-chengdu.aliyuncs.com/img/Solidity进阶.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 <i id="heartbeat" class="fa fas fa-heartbeat"></i>  浩烬</div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>! <div> <a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral">本网站由 <img src="img/又拍云_logo2.png" width="30px" height="15px" /> 提供CDN加速/云存储服务</a> </div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://npm.elemecdn.com/hexo-butterfly-clock/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_injector_config();
  }
  </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax src="https://npm.elemecdn.com/hexo-butterfly-clock/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>
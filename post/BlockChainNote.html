<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>北京大学肖臻老师《区块链技术与应用》公开课 | 浩烬的博客</title><meta name="keywords" content="区块链"><meta name="author" content="浩烬"><meta name="copyright" content="浩烬"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="&#x2F;&#x2F;以下笔记大部分为他人笔记，我会在此基础上加上自己的一些补充或理解(粗体+斜体部分) 课程链接:北京大学肖臻老师《区块链技术与应用》公开课_哔哩哔哩_bilibili BTC部分BTC-密码学原理比特币被称为加密货币crypto-currency区块链上内容都是公开的，包括区块的地址，转账的金额。 比特币主要用到了密码学中的两个功能:1.哈希2.签名 1.密码学中用到的哈希函">
<meta property="og:type" content="article">
<meta property="og:title" content="北京大学肖臻老师《区块链技术与应用》公开课">
<meta property="og:url" content="https://destinywei.github.io/post/BlockChainNote.html">
<meta property="og:site_name" content="浩烬的博客">
<meta property="og:description" content="&#x2F;&#x2F;以下笔记大部分为他人笔记，我会在此基础上加上自己的一些补充或理解(粗体+斜体部分) 课程链接:北京大学肖臻老师《区块链技术与应用》公开课_哔哩哔哩_bilibili BTC部分BTC-密码学原理比特币被称为加密货币crypto-currency区块链上内容都是公开的，包括区块的地址，转账的金额。 比特币主要用到了密码学中的两个功能:1.哈希2.签名 1.密码学中用到的哈希函">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/区块链.png">
<meta property="article:published_time" content="2022-08-13T18:28:01.697Z">
<meta property="article:modified_time" content="2022-08-14T03:13:42.750Z">
<meta property="article:author" content="浩烬">
<meta property="article:tag" content="区块链">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/区块链.png"><link rel="shortcut icon" href="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/头像3.jpg"><link rel="canonical" href="https://destinywei.github.io/post/BlockChainNote"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '北京大学肖臻老师《区块链技术与应用》公开课',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-08-14 11:13:42'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_1.css" ><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_2.css" ><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-clock/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head><body>
    <div id='loader'>
        
            <div class="outer_box">
                <div class='loader_overlay'></div>
                <div class='loader_cogs'>
                    <div class='loader_cogs__top'>
                        <div class='top_part'></div>
                        <div class='top_part'></div>
                        <div class='top_part'></div>
                        <div class='top_hole'></div>
                    </div>
                    <div class='loader_cogs__left'>
                        <div class='left_part'></div>
                        <div class='left_part'></div>
                        <div class='left_part'></div>
                        <div class='left_hole'></div>
                    </div>
                    <div class='loader_cogs__bottom'>
                        <div class='bottom_part'></div>
                        <div class='bottom_part'></div>
                        <div class='bottom_part'></div>
                        <div class='bottom_hole'></div>
                    </div>
                    <p style="text-align:center">&nbsp;&nbsp;&nbsp;loading...</p>
                </div>
            </div>
        
    </div>

    <script>
        var endLoading = function () {
            document.body.style.overflow = 'auto';
            document.getElementById('loader').classList.add("loading");
        }
        window.addEventListener('load',endLoading);
    </script>

<div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/头像3.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/区块链.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">浩烬的博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">北京大学肖臻老师《区块链技术与应用》公开课</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-13T18:28:01.697Z" title="发表于 2022-08-14 02:28:01">2022-08-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-14T03:13:42.750Z" title="更新于 2022-08-14 11:13:42">2022-08-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">59.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>176分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="北京大学肖臻老师《区块链技术与应用》公开课"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><strong>&#x2F;&#x2F;以下笔记大部分为他人笔记，我会在此基础上加上自己的一些补充或理解</strong>(<em><strong>粗体+斜体部分</strong></em>)</p>
<p>课程链接:<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Vt411X7JF?p=1">北京大学肖臻老师《区块链技术与应用》公开课_哔哩哔哩_bilibili</a></p>
<h2 id="BTC部分"><a href="#BTC部分" class="headerlink" title="BTC部分"></a>BTC部分</h2><h3 id="BTC-密码学原理"><a href="#BTC-密码学原理" class="headerlink" title="BTC-密码学原理"></a>BTC-密码学原理</h3><p>比特币被称为加密货币crypto-currency<br>区块链上内容都是公开的，包括区块的地址，转账的金额。</p>
<p>比特币主要用到了密码学中的两个功能:1.哈希2.签名</p>
<p>1.密码学中用到的哈希函数被称为cryptographic hash function:    它有两个重要的性质:<br>①collision(这里指哈希碰撞) resistance  :例如x≠y H(x)&#x3D;H(y) 两个不同的输入，输出却是相等的，这就称哈希碰撞。它是不可避免的，因为输入空间总大于输出空间。给出x，很难找到y，除非蛮力求解(brute-force)。</p>
<p><em><strong>即使输入空间远大于输出空间，但我们输入内容的宽度也应该足够宽，倘若我们输入的内容一直是在某个范围内的内容，那么蛮力破解成功的可能性会大大提高</strong></em></p>
<p>该性质的作用:对一个message求digest<br>比如message取m m的哈希值是H(m)&#x3D;digest 如果有人想篡改m值而H(m)不变，则无法做到。<br>哈希碰撞无法人为制造，无法验证，是根据实践经验得来的。</p>
<p>②hiding 哈希函数的计算过程是单向的，不可逆的。(从H(x)无法推导出x) hiding性质<strong>前提是输入空间足够大，分布比较均匀</strong>。如果不是足够大，一般在x后面拼接一个随机数，如H(x||nonce)。<br>该性质的作用:和collision resistance 结合在一起，用来实现digital commitment(又称为digital equivalent of a sealed envelope)<br>把预测结果作为输入x，算出一个哈希值，讲哈希值公布，hiding让人们知道哈希值而不知道预测值，最后再将x公布，因为有collision resistance的性质，预测结果是不可篡改的。</p>
<p>除了密码学中要求的这两个性质外，比特币中用到的哈希函数还有第三个性质:<br>③puzzle friendly 指哈希值的预算事先是不可预测的。假如哈希值是00…0XX…X(以k个0开头)，一样事先无法知道哪个值更容易算出这个结果，所以只能一个一个带入求哈希值即蛮力破解。</p>
<p>比特币挖矿的过程中实际就是找一个nonce(随机数)，nonce跟区块的块头里的其他信息合一起作为输入***(此处为的是增加输入的宽度，从而降低被蛮力破解的概率)***，得出的哈希值要小于等于某个指定的目标预值即H(block header)≤target。block header 指块头，块头里有很多域，其中一个域是我们可以设置的随机数nonce，挖矿的过程就是不停的试随机数，使得block header取哈希后落在指定的范围之内。</p>
<p>puzzle friendly是指挖矿过程中没有捷径，为了使输出值落在指定范围，只能一个一个去试。所以这个过程还可以作为工作量证明(proof of work)。<br>挖矿很难，但验证很容易。(difficult to solve ,but easy to verify)</p>
<p>比特币中用的哈希函数叫作SHA-256(secure hash algorithm )以上三个性质它都是满足的。</p>
<p>2.在比特币系统中开账户:<br>在本地创立一个公私钥匙对(public key ,private key)，这就是一个账户。公私钥匙对是来自于非对称的加密技术(asymmetric encryption algorithm)。</p>
<p>两人之间信息的交流可以利用密钥(encryption key)，A将信息加密后发给B，B收到后用密钥解密，因为加密和解密用的是同一个密钥，所以叫对称加密。但前提是得有渠道可以安全地把密钥分发给通讯的双方。因此对称加密的缺点就是密钥的分发不方便，因为在网络上很容易被窃听。</p>
<p>而非对称密钥是用一对密钥而不是一个，加密用公钥，解密用私钥，加密和解密用的都是<strong>接收方</strong>的公钥和私钥。公钥是不用保密的，私钥要保密但是私钥只要保存在本地就行，不用传给对方。公钥相当于银行账号，别人转账只要知道公钥就行，私钥相当于账户密码，知道私钥可以把账户上钱转走。公钥和私钥是用来签名。</p>
<p>假如A想向B转10个比特币，A把交易放在区块链上，别人怎么知道这笔交易是A发起的呢?这就需要A要用自己的私钥给交易签名，其他人收到这笔交易后，要用A的公钥去验证签名。签名用私钥，验证用公钥，用的仍然是同一个人的。创建账户产生相同公私钥的可能性微乎其微，可以忽略不计，所以大量创建账户来窃取其他人账户是不可行的。</p>
<p>我们假设产生公私钥时有一个好的随机源(a good source of randomness)，产生公私钥是随机的，如果随机源不好，就有可能产生相同的公私钥。比特币中用的签名算法，不仅是生成公私钥的时候要有好的随机源，之后每一次签名时也要用好的随机源。只要有一次签名用的随机源不好的话，就有可能泄露私钥。</p>
<h3 id="BTC-数据结构"><a href="#BTC-数据结构" class="headerlink" title="BTC-数据结构"></a>BTC-数据结构</h3><p>普通指针存储的是某个结构体在内存中的地址。假如P是指向一结构体的指针，那么P里面存放的就是该结构体在内存中的起始位置。而哈希指针除了要存地址之外，还要保存该结构体的哈希值H()。好处是:从哈希值这个哈希指针，不仅可以找到该结构体的位置，同时还能够通过对比哈希值是否相同来检测出该结构体的内容有没有被篡改，因为我们保存了它的哈希值。</p>
<p>比特币中最基本的结构就是区块链，区块链就是一个一个区块组成的链表。区块链和普通的链表相比有什么区别:<br>①用哈希指针代替了普通指针(B block chain is a linked list using hash pointers)</p>
<p>区块链第一个区块叫作创世纪块(genesis block) ，最后一个区块是最近产生的区块(most recent block) ，每一个区块都包含指向前一个区块的哈希指针。<br>一个区块的哈希指针怎么算:是把前面整个区块的内容，包括里面的hash pointer ，合在一起取哈希值。通过这种结构，可以实现tamper-evident log。如果有人改变了一个区块的内容，后面一个区块的哈希指针就对不上，因为后一个区块哈希指针是根据前一个区块的内容算出来的，所以后一个哈希指针也得改，以此类推，我们保留的最后一个哈希值也会变化。</p>
<p>②普通链表可以改变任意一个元素，对链表中其他元素是没有影响的。而区块链是牵一发而动全身，因为只需要保存最后一个哈希值，就可以判断区块链有没有改变，在哪里改变了。<br>因此比特币没有要保存所有区块的内容，可以只保留最近的几千个区块。如果要用到以前的区块，可以向系统中其他节点索要这个区块。但可能有些节点是有恶意的，怎么判断?这里要用到哈希值一个性质，如下:<br>其他节点给你一个区块，如何判断它是正确的?算出它的哈希值，与保留的区块的哈希值对比，即可。</p>
<p>比特币中的另外一个结构是:Merkle tree(默克尔树)。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Merkel%20tree%20Data%20Structure.png">(其中最下面一层是数据块(data blocks)，上面三层内部节点都是哈希指针(hash pointers)，第一层是根节点，根节点的区块也可以取个哈希，叫根哈希(root hash))<br>另外一个概念:binary tree。</p>
<p>这种结构的好处:只要记住根哈希值，就能检测出对树中任何部位的修改。<br>它们的区别:①用哈希指针代替了普通指针。</p>
<p>比特币当中各区块之间用哈希指针连接在一起，每个区块所包含的交易组织成一个merkle tree的形式，最下面一行data blocks每个区块实际上是一个交易，每个区块分为两部分，分别是区块头和区块体(block header ,block body)。区块头里面有根哈希值，每个区块所包含的所有交易组成的merkle tree的根哈希值存在于区块的区块头里面，但是，区块头里没有交易的具体内容，只储存一个根哈希值，区块体里面是有交易的列表的。</p>
<p>merkle tree 的作用:①提供merkle proof<br>比特币中的节点分为两类:全节点(保存整个区块的内容，即区块头区块体都有，有交易的具体信息)和轻节点(例如手机上的比特币钱包)(只有区块头)</p>
<p>这时存在一个问题:如何向一个轻节点证明某个交易是写入区块链的?<br>这时需要用到merkle proof :找到交易所在的位置(图片中最底行的其中一个区块)，这时该区块一直往上到根节点的路径就叫merkle proof。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Merkel%20Proof.png" alt="Merkel Proof"></p>
<p>最上面一行是小型的区块链，该图展现的是一个区块的merkle tree，最下面一行是包含的交易。假设某个轻节点想知道图中黄色的交易，是否包含在了merkle tree里面。该轻节点没有包含交易列表，没有这颗merkle tree的具体内容，只有一个根哈希值。这时轻节点会向一个全节点发出请求，请求证明黄色的交易被包含在这颗merkle tree里面的merkle proof。全节点收到这个请求之后，只需要将图中标为红色的这三个哈希值发给轻节点即可。有了这些哈希值之后，轻节点可以在本地计算出图中标为绿色三个哈希值。首先算出黄色交易的哈希值，即它正上方的那个绿的哈希值，然后跟旁边红色的哈希值拼接起来，可以算出上层节点绿色的哈希值。然后再拼接，再算出上层绿色哈希值，再拼接，就可以算出整棵树的根哈希值。轻节点把这个根哈希值和block header里的根哈希值比较一下，就能知道黄色的交易是否在这颗merkle tree里。</p>
<p>全节点在merkle proof里提供的这几个哈希值，就是从黄色的交易所在的节点的位置到树根的路径上用到的这些哈希值。轻节点收到这样一个merkle proof之后，只要从下往上验证，沿途的哈希值都是正确的即可。(验证时只能验证该路径的哈希值，其他路径是验证不了的，即该图中红色的哈希值是验证不了的)</p>
<p>这样是否不安全呢?假如黄色交易被篡改，它的哈希值发生了变化，那能不能调整旁边红色的哈希值，使得它们拼接起来的哈希值是不变的呢?不行，根据collision resistance，我们知道人为制造哈希碰撞是不可行的。</p>
<p>merkle proof可以证明merkle tree里面包含了某个交易，所以这种证明又叫proof of membership或 proof of inclusion。<br>对于一个轻节点来说，验证一个merkle proof 复杂度是多少?假设最底层有n个交易，则merkle proof 复杂程度是θ(log(n))</p>
<p>如何证明merkle tree里面没有包含某个交易?即proof of non-membership。可以把整棵树传给轻节点，轻节点收到后验证树的构造都是对的，每一层用到的哈希值都是正确的，说明树里只有这些叶节点，如果要找的交易不在这些叶节点里面，就证明了proof of non-membership。问题在于，它的复杂度是线性的θ(n)，是比较笨的方法。</p>
<p>如果对叶节点的排列顺序做一些要求，比如按照交易的哈希值排序。每一个叶节点都是一次交易，先对交易的内容取一次哈希，按照哈希值从小到大排列。要查的交易先算出一个哈希值，看看它在里面应该是在哪个位置。比如说在第三个和第四个之间，这时提供的proof是第三个第四个叶节点都要往上到根节点。如果其中哈希值都是正确的，最后根节点算出的哈希值也是没有被改过的，说明第三、四个节点在原来的merkle tree里面，确实是相邻的点。要找的交易如果存在的话，应该在这两个节点中间。但是它没有出现，所以就不存在。其复杂度也是log形式，代价是要排序。排好序的叫作sorted merkle tree。比特币中没有用到这种排好序的merkle tree，因为比特币中不需要做不存在证明。</p>
<p>这节讲了比特币中两种最基本的结构:区块链和merkle tree，都是用哈希指针来构造的。除了这两种之外，哈希指针还能用另一个方面。</p>
<p>只要一个数据结构是无环的(非循环链表)，都能用哈希指针代替普通指针。有环的话存在一个问题，他们的哈希值没法计算，没法确定一个哈希值固定的区块***(假如有一个三个元素的循环链表，第一个元素的哈希指针的确定需要以第二个元素为基础，而第二个元素的哈希指针的确定需要以第三个元素为基础，同时第三个元素的哈希指针的确定需要以第一个元素为基础，这样就形成了一种矛盾，导致所有元素的哈希指针都无法确定下来，因此哈希指针用在有环结构中会出现问题)***。</p>
<h3 id="BTC-协议"><a href="#BTC-协议" class="headerlink" title="BTC-协议"></a>BTC-协议</h3><p>数字货币和纸质货币区别是可以复制，叫作双花攻击  即double spending attack。</p>
<p><strong>去中心化货币要解决两个问题:①数字货币的发行②怎么验证交易的有效性，防止double spending attack。</strong>   </p>
<p>答案:①比特币的发行是由挖矿决定的<br>②依靠区块链的数据结构<br>比特币的发行者A拥有铸币权(createcoin) 假如发行10个比特币  A(10)分别给B和C各五个  → B(5)C(5) 该交易需要有A的签名，证明经A同意(designed by A)。同时还要说明花掉的10个比特币从哪来的。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Protocol%201.png"></p>
<p>第二个方框中的钱是从第一个框内铸币交易中来的。</p>
<p>比特币系统中每个交易都包含输入和输出两部分。输入部分要说明币的来源，输出部分要给出收款人公钥的哈希。<br>有的交易部分比较复杂，如C的货币来源是第二第三个方框，要标识清楚。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Protocol%202.png"></p>
<p>上图就构成了一个小型的区块链，这里有两种哈希指针，一种哈希指针是连接在各个区块之间的，把它们串起来构成一个链表，前面学的就是这种哈希指针。而在该图中还有第二种哈希指针，是指向前面某个交易的指针，用来指明币的来源。为什么要说明币的来源:证明币不是凭空捏造的是有记录的，同时也是为了防范double spending。</p>
<p>现在来看第二个方框里A向B的转账，该交易需要A的签名和B的地址。比特币系统里收款的地址是通过公钥推算出来的。比如B的地址就是B的公钥取哈希然后经过一些转换得到的。</p>
<p><strong>A如何知道B的地址?</strong></p>
<p>比特币系统中没有查询对方地址的功能，必须通过其他渠道。比如某个电商网站，接受比特币支付，就可以公开它的地址或公钥。</p>
<p><strong>A需要知道B的地址，那B需要知道A的什么信息吗?</strong></p>
<p>B其实也要知道A的公钥，这代表A的身份。不仅是B，所有节点都需要知道A的公钥。而签名是用私钥签名公钥验证(注意不要跟前面知识弄混了，加密是用<strong>接收人</strong>的公钥加密私钥解密)，所以区块链上每个节点都要独立验证。</p>
<p><strong>那如何才能知道A的公钥?</strong></p>
<p>实际上交易里就包含了。输入时不仅要输入币的来源，还要输入公钥。那就存在了安全漏洞，假如B的同伙伪造了这次交易呢?其实第一个方框里铸币交易的输出就有A的公钥的哈希，所以第二个方框交易里A的公钥要跟前面哈希对的上才会链接在一起。</p>
<p>在比特币系统当中，前面这些验证过程，是通过执行脚本来实现的。每个交易的输入提一段脚本，包括给出公钥的过程，公钥也是在输入的脚本里指定的。每个交易的输出也是一段脚本，验证其的合法性，就需要把当前交易的输入脚本跟前面交易(提供币来源的交易)的输出脚本拼在一起，然后看看能不能顺利执行，如果能执行说明是合法的。这里的脚本称为比特币脚本(BitCoin Script)。</p>
<p>该图对交易系统进行了简化，实际上每个区块(对应图中的每个方框)可以有很多交易，这些交易就组成merkle tree。每个区块分为区块头和区块体。</p>
<p>区块头包含的是区块的宏观信息，比如:用的是比特币哪个版本(version)的协议，区块链当中指向前一个区块的指针(hash of previous block header)，整棵merkle tree 的根哈希值(merkle root hash)，还有两个域是跟挖矿相关的，一个是挖矿的难度目标阈值(target)，另一个是随机数nonce。</p>
<p>这里的target，就是前面讲到的，整个区块头的哈希要小于等于这个阈值，即H(block header)≤target。block header里存的就是这个目标阈值的编码(nBits)。这里需要注意，前一个区块的哈希只算的是前一个区块的区块头，所以前面画的，一个区块引出一个剪头指向另一个区块中间，是不正确的，所以有的书箭头是指向一个区块的上面。取哈希时是把区块头的所有内容都取哈希。区块体里面有交易列表(transaction list)。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Protocol%203.png"></p>
<p>前面还有一个内容讲的时候简化了:每个节点都需要验证所有的交易，实际上系统中的节点分为全节点(full node)和轻节点(light node)，全节点是保存区块链所有的信息的，验证每一个交易，所以全节点又叫fully validating node。而轻节点只保存block header的信息，一般来说轻节点没法独立验证交易的合法性。</p>
<p>比如一个交易是不是double spending，轻节点没有存以前的交易信息所以它没法验证。系统中大多数节点是轻节点，这节课内容主要针对全节点，因为轻节点没有参与区块链的构造和维护，只是利用了区块链的一些信息做一些查询。</p>
<p><strong>区块链里的内容是如何写到区块链里面的呢?</strong></p>
<p>每个节点，每个账户都可以发布交易，交易是广播给所有节点的。有些交易是合法的，有些是非法的。谁来决定哪些交易应该被写入下一个区块中呢?按照什么顺序写呢?如果每个节点自己决定可以吗?</p>
<p>如果每个人在本地维护一个区块链，那区块链的统一性得不到保证，而账本的内容是要取得分布式的共识(distributed consensus)。</p>
<p><strong>下面的笔记跟比特币的应用关系不大，可以作为了解:</strong></p>
<p>{</p>
<p>分布式的共识一个简单的例子就是分布式的哈希表(distributed hash table)，比如系统里有很多台机器，共同维护一个全局的哈希表。</p>
<p>这里需要取得共识的内容是什么？</p>
<p>哈希表中包含了哪些键值对key valve pair。假如有人在自己电脑上插入一个键值对，’xiao’这个pair对应的是12345，即’xiao’→12345。那么别人在另一台读的时候也要能把这个读出来，这就叫一个全局的哈希表。</p>
<p>关于分布式系统有很多不可能结论(impossibility result)，其中最著名的是FLP。这三个字母是三个专家的名字缩写，他们的结论是:在一个异步的(asynchronous)系统里，(网络传输迟延没有上限就叫异步系统)，即使只有一个成员是有问题的(faulty)，也不可能取得共识。</p>
<p>还有一个著名结论:CAP Theorem。(CAP是指分布式系统的三个我们想要的性质，Consistency【系统状态的一致性】  Availability【别人都可以用】 Partition tolerance)。该理论内容是:任何一个分布式系统，比如分布式哈希表，这三个性质中，最多只能满足两个，假如想要前两个性质，那么就不会得到第三个性质。</p>
<p>分布式共识一个著名的协议是Paxos，该协议能够保证一致性，即第一个性质。如果该协议达成了共识，那么这个共识一定是一致的，即每个成员所认为的共识都是相同的。但是，某些情况下，该协议可能永远无法达成共识，这种可能性比较小但是是客观存在的。</p>
<p>}</p>
<p>比特币中的共识协议(consensus in BitCoin):<br>比特币中共识要解决的一个问题是，有些节点可能是有恶意的。我们假设系统中大多数节点是好的，那么该如何取得共识协议?</p>
<p>第一种方案是投票，首先应该确定哪些区块有投票权，有些membership是有严格要求的，这种情况下基于投票的方案是可行的。但比特币系统创建账户是很容易的，甚至一个人产生了公私钥对别人都无法得知，只有转账时别人才知道。所以有些人可以不停的创建账户，当超过账户总数的一半时就有了控制权，这种称为女巫攻击(sybil attack)。因此投票方法不可取。</p>
<p>比特币账户巧妙的解决了这个问题，不是按照账户数目投票，而是按照算力来投票。每个节点都可以在本地组装出一个候选区块，把它认为合法的交易放在里面，然后开始尝试各种nonce值(占4 byte)，看哪一个能满足不等式H(block header)≤target的要求。如果某个节点找到了符合要求的nonce，它就获得了记账权。</p>
<p>所谓的记账权，就是往比特币账本里写入下一个区块的权利。只有找到这个nonce，获得记账权的节点才有权利发布下一个区块。其他节点收到这个区块之后，要验证这个区块的合法性。</p>
<p>比如括号里block header的内容填的对不对；block header里面有一个域，叫nBits域，实际上它是目标预值的一个编码检查一下nBits域设置的是不是符合比特币协议中规定的难度要求；该不等式是否成立。假设都符合要求，然后检查block body 里面的交易列表，验证一下每个交易都是合法的:①要有合法的签名②以前没有被花过。如果有一项不符合要求，这个区块就是不能被接受的。如果所有条件都符合，也不一定会被接受。</p>
<p>假如生成了一个新区块，怎么知道新区块插在了哪里呢?根据生成区块的指针。有可能就存在一个问题</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Protocol%204.png"></p>
<p>如上图 ，这两个交易指A转账给B，以及A转账给自己。这种情况不是double spending，判断一个交易是不是double spending ，是看这个区块所在的分支上币有没有被花掉。如图，一直到第三个区块，币都没有花过，所以这个交易是合法的。虽然该交易是合法的，但是它不在最长合法链(longest valid chain)上。这种称为分叉攻击(forking attack)。所以接收的区块应该是扩展最长合法链。</p>
<p>区块链在正常情况下也可能出现分岔:两个节点同时获得记账权。每个节点在本地自己组装一个它认为合适的区块，然后去试各种nonce，如果两个节点在差不多同一个时间找到了符合要求的nonce，就都可以把区块发布，这时会出现两个等长的分岔。这两条都是最长合法链，那该接受那条呢?比特币协议当中，在缺省(默认的意思)情况下，每个节点是接受它最早收到的那个。所以不同节点根据在网络上的位置不同，有的节点先听到新生成的其中一个区块，那就接受这个区块；有些节点先听到另一个区块，那就接受另一个区块。</p>
<p>那如何判断接收了哪一个区块?比特币协议中用到了implicit consign，如果沿着这个区块往下继续扩展，就算认可了这个发布的区块。比如在新生成的其中一个区块后面又拓展一个区块，表明就认可了这个新区块。</p>
<p>等长的临时性的分叉会维持一段时间，直到一个分叉胜出。也就是哪一个链抢先一步生成了新的区块，哪一条就是最长合法链。另一个作废的就叫orphan block。这两个新区块有可能会各自拉拢，两个区块链看谁的算力强，有时候也是看谁的运气好，就会胜出。</p>
<p>竞争记账权的好处:首先获得记账权的节点本身有一定的权力，可以决定哪些交易写到下一个区块里。但这些不应该被设定为竞争记账权的动力，所以巧妙地建立了一个机制:区块奖励(block reward)。</p>
<p>比特币协议中规定获得记账权的节点在发布的区块里可以有一个特殊的交易:铸币交易。在这个交易里可以产生新的一定数量的比特币。</p>
<p>这里要回到前面的问题①，谁来决定货币的发行?coinbase transaction币基交易是比特币系统中发行新的比特币的唯一方法，后面的交易都只是比特币的转移，而没有新的比特币的产生。这个交易不用指出币的来源。</p>
<p>那么能造多少币呢?开始时比特币刚上线的时候，每一个发布的区块可以产生50BTC(BTC就是比特币的符号)。协议中规定，每产生21万个区块以后，初块奖励就要减半，即变成了25BTC。再过21万个区块，又要减半。</p>
<p>因此当一个区块胜出后，另一个作废的区块得到的比特币是没有作用的，其他诚实的区块是不会承认的。</p>
<p>比特币系统中要取得什么共识?	去中心化的账本要取得共识。</p>
<p>谁又能决定账本的内容呢?	只有获得记账权的节点才能写东西。</p>
<p>怎么获得记账权呢?	就是解pow(挖矿)。按照算力记票，算力可以用每秒能试多少nonce数值表示。</p>
<p>那怎样防范女巫攻击呢?	按算力记票，即使创建再多的账户，也无法使算力增强。</p>
<p>比特币争夺记账权的过程叫作挖矿(mining)，比特币被称为数字黄金(digital gold)，争夺记账权的节点被称为矿工(miner)。</p>
<h3 id="BTC-实现"><a href="#BTC-实现" class="headerlink" title="BTC-实现"></a>BTC-实现</h3><p>区块链是去中心化的账本，比特币使用的是基于交易的这种账本模式(transaction【交易】-based ledger【账本】)。系统当中并不会显示每个账户有多少钱。</p>
<p>比特币系统的全节点要维护一个叫UTXO(unspent transaction output)(还没有被花出去的交易的输出)的数据结构。区块链上有很多交易，有些交易的输出可能已经被花掉，有些还没有被花掉。所有没有被花掉的输出的集合就叫做UTXO。</p>
<p>一个交易可能有多个输出。假如A给B 5个比特币，B花掉了。A也给了C 3个比特币，C没有花掉。这时5个比特币就不算UTXO，而3个比特币算。UTXO集合当中的每个元素要给出产生输出的交易的哈希值，以及它在这个交易里是第几个输出。这两个信息就可以定位到UTXO中的输出。</p>
<p>要UTXO集合有什么作用?<br>为了检测double spending，即检测新发布的交易是否合法。因此全节点要在内存中维护UTXO这样一个数据结构，以便快速检测double spending。</p>
<p>每个交易要消耗掉一部分输出，也会产生新的输出。还看上面的例子，B花掉的5个比特币虽然不在UTXO里面，但如果他转账给D，而D没有花掉，那么这5个比特币又要保存在UTXO里面。如果D始终不花，那么这个信息要永久保存在UTXO里面。有可能是不想花，也有可能是D不小心把密钥丢了。</p>
<p>每个交易可以有多个输入，也可以有多个输出，所有输入金额之和要等于输出金额之和，即total inputs&#x3D;total outputs。因此一个交易可能来自多个地址，可能有多个签名。</p>
<p>有些交易total inputs略微大于total outputs。<br>假如输入1比特币，输出0.99比特币，另外0.01比特币作为交易费给获得记账权发布区块的节点。</p>
<p>区块奖励也不能完全作为挖矿的奖励，发布区块的节点为什么一定要把你的交易打包在区块呢?他们还要验证你的交易的合法性，如果交易较多占用的带宽会比较大，网络传播速度也会更慢。所以只有区块奖励是不够的。</p>
<p>因此比特币系统设计了第二个激励机制:交易费(transaction fee)。也就是你把我的交易打包在区块里，我给你一些小费。交易费一般很小，也有一些简单的交易没有交易费。</p>
<p>21万个区块大概要挖多长时间呢?大约是4年。比特币系统设计的平均出块时间是10分钟，就是整个系统平均10分钟会产生一个新的区块。</p>
<p>除了比特币这种基于交易的模式，与之对应的还有基于账户的模式(account-based ledger)，比如以太坊系统。在这种模式中，系统是要显示的记录每个账户上有多少币。</p>
<p>比特币基于交易的模式，隐私保护性较好。缺点是比特币当中的转账交易要说明币的来源，而基于账户的模式就不用。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Implementation%201.png"></p>
<p>如图一个区块的例子 </p>
<p>左边:</p>
<p>第一行表明:该区块包含了686个交易<br>第二行:总输出XXX个比特币<br>第四行:总交易费(686个交易的交易费之和)<br>最下面一行:区块奖励(矿工挖矿的主要动力)<br>第五行:区块的序号<br>第六行:区块的时间戳<br>第九行:挖矿的难度(每隔2016个区块要调整挖矿的难度，保持出块时间在10分钟左右)<br>倒数第二行:挖矿时尝试的随机数</p>
<p>右边:</p>
<p>第一行:该区块块头的哈希值<br>第二行:前一个区块块头的哈希值<br>(注意:计算哈希值只算块头)<br>两个哈希值的共同点:前面都有一长串0。是因为，设置的目标阈值，表示成16进制，就是前面一长串的0。所以凡是符合难度要求的区块，区块头的哈希值算出来都是要有一长串的0。<br>第四行:merkle root 是该区块中包含的那些交易构成的merkle tree的根哈希值。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Implementation%202.png"></p>
<p>如图区块头的数据结构<br>最后一行:是32位的无符号整数。nonce只有2的32次方个可能的取值。按照比特币现在的挖矿情况来说，很可能把2的32次方个取值都验了一遍也找不到合适的。那怎么办呢?block header 的数据结构里还有哪些域是可以调整的呢?</p>
<p>区块头里各个域的描述<br>第一行:比特币协议的版本号(无法更改的)<br>第二行:前一个区块的块头的哈希值(无法更改)<br>第三行:merkle tree的根哈希值(可以更改)<br>第四行:区块产生的时间(可以调整)	比特币系统不要求特别精确的时间，可以在一定范围内调整。<br>第五行:目标阈值(编码后的版本)	(只能按协议中的要求定期调整)<br>第六行:随机数</p>
<p>挖矿时只改随机数不够，还可以更改根哈希值。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Implementation%203.png"></p>
<p>如图，铸币交易没有输入，它有一个coinbase，可以写入任何的内容。也可以把digital commitment里的commit的哈希值写入里面。也可以把第一节讲到的预测股市的内容写入里面，coinbase的内容是没有人会检查的，甚至可以写你的心情。</p>
<p>那这个域对我们有什么用呢?</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Implementation%204.png"></p>
<p>如图，对应的是最后一个block header里的根哈希值对应的merkle tree，左下角的交易是coinbase，把它的域改了之后，其上的哈希值就发生了变化，然后沿着merkle tree的结构往上传递。最后导致block header里的根哈希值发生变化(merkle root是block header的一部分)。区块头里4个字节的nonce不够用，还有其他字节可以用，比如coinbase域的前八个字节当做extra nonce来用，这样子搜索空间就增大到了2的96次方。</p>
<p>所以真正挖矿的时候会有两层循环，外层循环调整coinbase域的extra nonce，算出block header里的根哈希值之后，内层循环再调整header里的nonce。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Implementation%205.png"></p>
<p>如图普通的转账交易的例子<br>该交易有两个输入和两个输出。<br>左上角:这里的output其实是输入，指的是之前交易的output。<br>右上角:这里的output都是unspent，都没有被花掉，会保存在UTXO里面。<br>右边表格第一行:输入的总金额。<br>依次往下:输出总金额、两者之间的差值即交易费。<br>两表格下面:可以看出输入和输出都是用脚本的形式来指定的。</p>
<p>比特币系统中验证交易的合法性，就是把input scripts和output script配对后执行来完成的。注意:不是把图中的input scripts<br>和output scripts配对，因为这两个脚本是一个交易中的脚本。不是把同一个交易里的输入脚本和输出脚本配对，而是把这里的输入脚本和前面提供币来源的交易的输出脚本配对。如果输入输出脚本拼接在一起，能顺利执行不出现错误，那么该交易就是合法的。</p>
<p>求解puzzle的过程<br>注意:求哈希时只用到了block header的内容，而交易的具体信息在block header里面是没有的。block header里面只有merkle tree 的根哈希值，这个就已经能保证交易是没有被篡改的。</p>
<p>挖矿过程每次尝试一个nonce可以看作是一个Bernoulli trial(伯努利实验)。每一个随机的伯努利实验就构成了一个伯努利过程。它的一个性质是:无记忆性(memoryless)。</p>
<p>每尝试一个nonce成功的概率是很小的，要进行大量的实验。这时可以用泊松过程来代替伯努利过程。我们真正关心的是系统出块时间，出块时间是服从指数分布。可以画出一个坐标轴，纵轴表示概率密度，横轴表示出块时间(整个系统的出块时间，并不是每个矿工的出块时间)。具体到每一个矿工，他能挖到下一个区块的时间取决于矿工的算力占系统算力的百分比。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Implementation%206.png"></p>
<p>假如一个人的算力占系统总算力的1%，那么系统出100个区块，就有一个区块是这个人挖的。</p>
<p>指数分布也是无记忆性的。因为概率分布曲线的特点是:随便从一个地方截断，剩下一部分曲线跟原来是一样的。比如:已经等十分钟了，还没有人找到合法的区块，那么还需要等多久呢?仍然参考概率密度函数分布 ，平均仍然要等十分钟。将来还要挖多长时间，跟过去已经挖了多长时间是没有关系的。这个过程也叫:progress free。</p>
<p>如果没有progress free ，会出现什么现象:算力强的矿工会有不成比例的优势。因为算力强的矿工过去做的工作是更多的，过去尝试了那么多不成功的nonce之后，后面nonce成功的概率就会增大。以此progress free 是挖矿公平性的保证。</p>
<p>出块奖励是系统中产生新的比特币的唯一途径。产生的比特币构成的一个几何序列。21万＊50+21万＊25+21万＊12.5+……&#x3D;21万＊50＊(1+1&#x2F;2+1&#x2F;4+……)&#x3D;2100万</p>
<p>比特币求解的puzzle，除了比拼算力之外，没有其他实际意义。比特币的稀缺性是人为造成的。</p>
<p>虽然挖矿求解puzzle本身没有实际意义，但是挖矿的过程对于维护比特币系统的安全性是至关重要的。挖矿提供一种凭借算力投票的有效手段，只要大部分算力是掌握在诚实的节点手里，系统的安全性就能够得到保证。</p>
<p>虽然挖矿奖励越来越小，难度越来越大，但这几年挖矿的竞争是越来越激烈的，因为比特币的价格是飙升的。最终区块奖励为0了，是不是就没有动力挖矿了呢?不是的，因为还有交易费激励机制。</p>
<p>假设大部分算力是掌握在诚实的矿工手里，我们能得到什么样的安全保证?能不能保证写入区块链的交易都是合法的?</p>
<p>挖矿给出的只是概率上的保证，只能说有比较大的概率下一个区块是由诚实的矿工发布的，但是不能保证记账权不会落到有恶意的节点手里。</p>
<p>比如好的矿工占90%的算力，坏的矿工占10%的算力。那么10%的概率下记账权会落在有恶意的矿工手里，这时候会出现什么情况?</p>
<p>先考虑第一个问题:他能不能偷币?能不能把别人账上的钱转给自己?	不能，因为他没有办法伪造别人的签名。</p>
<p>假设M是有恶意的，他想把A账上的钱转走，所以他发布一个A转给M的交易，但这个交易需要有A的签名，M虽然获得记账权，但他不知道A的私钥，所以伪造不了签名。</p>
<p>如果M把交易硬写在区块链上，诚实的节点不会接受这个区块，因为它包含有非法的交易。所以诚实的节点会继续沿前一个区块挖，生成新的区块代替非法的区块，其他诚实的区块会沿着这个合法的区块继续挖。比特币要求是扩展最长合法链，M生成的不是合法区块，所以该区块作废。这对他造成的代价是很大的，因为既没有了区块奖励，又没有偷到钱。</p>
<p>第二个问题:他能不能把已经花了的币再花一遍(即double spending)?	假如他把M→A的交易写在了一个区块里面，现在他获得了记账权，他又发布另一个交易，把这个钱转回给自己，即M→M’。同样，这很明显是double spending，只要是诚实的节点都不会接受这个区块。</p>
<p>他如果想发布这个区块，只能连在写了M→A交易区块的前一个区块。注意:区块插在哪个位置，在刚挖矿时就是要决定的，因为设置的block header里要填上前一个block header的哈希。所以他想插到那个区块的话，一开始就要认定，而不是等获得记账权以后再认定。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Implementation%207.png"></p>
<p>这样生成的两条区块链，都是合法的。参考上图。要看其他节点沿着哪一个链往下扩展，最后一个胜出一个作废。</p>
<p>这种攻击的目的是什么?	如果M→A的交易，产生了某种不可逆的外部效果，然后M→M’再把M→A的交易回滚了，那么M就可以从中不当获利。</p>
<p>比如:网上购物时，M购买一些商品，然后该网站接受比特币支付，M发起一个交易把账转给网站。网站监听到交易写入了区块链里，以为支付成功了，所以就把商品给了M。M拿到商品之后，又发起一个交易，把支出的钱转给自己，然后把下面的链拓展成最长合法链。这样的结果是:既得到了商品，又收回了花掉的钱，就达到了double spending的目的。</p>
<p>如何防范这种攻击呢?	如果M→A的交易所在的区块不是最后一个区块，那么这种攻击的难度就会大大增加。要是想回滚M→A的交易，还是要插在它之前的一个区块，然后想办法成为最长合法链。这个难度是很大的。因为诚实的节点，不会沿着它生成的区块往下扩展，因为它不是最长合法链。因此防范这种攻击的方法就是多等几个区块，或者叫多等几个确认confirmation。</p>
<p>M→A交易刚刚写入区块里时，我们把它叫作one confirmation。这时后面加的区块，依次叫two confirmation、three confirmation…比特币协议当中，缺省(系统默认)的是要等六个confirmation。有了六个confirmation，才认定M→A的交易是不可篡改的。这需要等多长时间呢?平均出块时间是10分钟，因此要等一个小时。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Implementation%208.png"></p>
<p>区块链是不可篡改的账本，那是不是意味着凡是写入区块链中的内容就永远改不了呢?	经上述分析可以看出，这种分析只是一种概率上的保证。刚刚写入区块链的内容，还是比较容易被改动的。经过一段等待时间之后，或者后面几个区块被确认之后，被篡改的概率就大幅度下降(指数级别的下降)。</p>
<p>其实还有一种，叫零确认(如上图)。意思是说，这个转账交易发布出去了，但还没又被写入区块链里。即M→A的交易已经发布，但下面包含M→M’的区块还没有被挖出来。</p>
<p>这个概念相当于电商购物的例子中，在支付时你发布一个转账交易，告诉电商自己已经转过钱了。</p>
<p>电商运行一个全节点或委托一个全节点监听区块链上的交易，他收到转账交易之后要验证该交易的合法性(有合法的签名，以前没有被花过)，甚至不用等到该交易写入区块链里。这种操作听起来风险很大，交易刚发布出去，都没往区块链里写呢。其实，零确认在实际当中，用的还是比较普遍的。为什么呢?</p>
<p>这其中有两个原因:①比特币协议缺省的设置是节点接收最先听到的那个交易。所以在零确认的位置，M→A的节点收到后，再发M→M’的交易，有比较大的概率诚实的节点是不会接受的。<br>②很多购物网站，从支付成功，到发货，是有一定的时间间隔的，即有一定的处理时间。</p>
<p>回到前面的问题:假设某个有恶意的节点获得记账权，它还能做什么坏事?	能不能故意不把某些合法的交易写入区块链里?即发布的区块故意不包含某些交易。这是可以的。</p>
<p>比特币协议并没有规定获得记账权的节点一定要把那些交易发布到区块里。但出现这种情况问题也不大，因为这些合法的交易一定会被写入后面的区块里，总会有诚实的节点愿意发布这些交易。</p>
<p>其实，区块链在正常工作下，也会出现合法的交易没有被包含进去的情况，可能就是这段时间交易的数目太多了。比特币协议中规定，每个区块的大小是有限制的，最多不能超过一兆字节。所以如果交易的数目太多了，那么有些交易可能就只能等到下一个区块再发布。</p>
<p>会不会出现这种情况?	M→M’的交易所在的区块所在的链条虽然短，但是先偷偷的生成比上面更多的区块，然后等上面的区块链公布后再一次性公布出来，就能够胜过上面的几个区块了?这种方法叫作selfish mining。</p>
<p>正常情况下挖到一个区块马上就发布，原因是你不发布别人可能就发布了，那样就拿不到区块奖励了。而selfish mining是先藏着不急着发布，这是分岔攻击的一种手段。</p>
<p>但这样成功的概率并不大，因为有恶意的节点本来算力占比就不高，还要生成更多的区块，就非常困难。</p>
<p>以上是selfish mining的其中一个目的，它还有另一个目的。</p>
<p>假如A挖到了第一个区块但没有立即发布转而继续挖下一个区块，导致其他节点去挖第一个区块，而A在挖第二个区块时，其他节点还在挖第一个区块(前提是A算力足够强)，当A把第二个区块也挖出来并把第一第二个区块都发布出来时，那么之前其他节点挖出来的第一个区块就作废了。这样做的好处就是减少竞争。</p>
<p>但这样做也存在风险，假如A挖出第一个区块，A以为他能赶在其他节点之前挖出第二个区块，结果这时已经有其他节点挖出了第一个区块，那这样的话A就要在其他节点发布第一个区块之后也立马发布自己所挖出的第一个区块(即产生分岔)去与它竞争，争取区块奖励。</p>
<h3 id="BTC-网络"><a href="#BTC-网络" class="headerlink" title="BTC-网络"></a>BTC-网络</h3><p>比特币网络<br>比特币工作在应用层(application layer:Bitcoin block chain)，它的底层是一个网络层(network layer:P2P overlay network)。</p>
<p>比特币的P2P网络是非常简单的，所有节点都是对等的。不像有的P2P网络有所谓的超级节点(super node)、主节点(master node)。</p>
<p>要加入P2P网络首先得知道至少有一个种子节点(seed node)，然后你要跟种子节点联系，它会告诉你它所知道的网络中的其他节点，节点之间是通过TCP通信的，这样有利于穿透防火墙。当你要离开时不需要做任何操作，不用通知其他节点，退出应用程序就行了。别的节点没有听到你的信息，过一段时间之后就会把你删掉。</p>
<p>比特币网络的设计原则是:简单、鲁莽，而不是高效的。每个节点维护一个邻居节点的集合，消息传播在网络中采取flooding的方式。节点第一次听到某个消息的时候，把消息传播给它所有的邻居节点，同时记录一下这个消息我已经收到过了。下次再收到这个消息的时候，就不用转发给邻居节点了。</p>
<p>邻居节点的选取是随机的，没有考虑底层的拓扑结构。比如一个在加利福尼亚的节点，它选的邻居节点可能是在阿根廷的。这样设计的好处是增强鲁莽性，它没有考虑底层的拓扑结构，但是牺牲的是效率，你向身边的人转账和向美国的人转账速度是差不多的。</p>
<p>比特币系统中，每个节点要维护一个等待上链的交易的集合。假如一个集合的交易都是等待写入区块链里的，那么第一次听到某个交易的时候，把这个交易加入这个集合，并且转发这个交易给邻居节点，以后再收到这个交易就不用转发了，这样避免交易会在网络上无限的传播下去。转发的前提是该交易是合法的(有合法的签名、以前没有被花过)。</p>
<p>这里有冲突的情况，有可能你会有两个有冲突的交易，差不多同时被广播到网络上。比如说A→B和A→C，这两个如果同时广播在网络上，那么每个节点根据在网络中的位置的不同，收到两个交易的先后顺序不同。</p>
<p>比如一个人先收到第一个交易，就写入到集合里，再收到第二个交易的时候就不会写入集合，因为跟上一个交易有冲突，就认定是非法的。假设这两个交易花的是同一个币，那么写入集合的交易就会被删掉。</p>
<p>比如说节点听到一个新发布的区块，里面包含了A→B的交易，那么这个交易就可以删掉了，因为已经写入到了区块链里。如果节点又听到了A→C的交易，该怎么办?这时候也要把A→B删掉。因为A→C如果已经被写入到了区块里，那么A→B就变成了非法交易，就变成了double spending，这就是冲突的情况。可能某个先收到A→C的节点，抢先挖到了矿，发布了区块。</p>
<p>新发布的区块在网络上的传播有很多方式，跟新发布的交易是类似的。每个节点除了要检查区块的内容合法性之外，还要查它是不是在最长合法链里。越是大的区块，在网络上传播速度越慢。</p>
<p>比特币协议对区块的大小有1M字节的限制。比特币系统采用的传播方式是非常耗费带宽的，带宽是瓶颈。按1M的区块大小限制来算的话，一个新发布的区块有可能需要几十秒，才能传输到网络大部分节点，这已经是挺长时间了，所以这个限制值不算小。</p>
<p>还需要注意的一点:我们讲的比特币网络的传播属于best effort 。一个交易发布到比特币网络上，不一定所有的节点都能收到，而且不同的节点收到这个交易的顺序也不一定是一样的。网络传播存在延迟，而且这个延迟有的时候可能会很长，而且有的节点也不一定按照比特币协议的要求进行转发。</p>
<p>可能有的该转发的不转发，导致某些合法的交易收不到，也有的节点可能转发一些不该转发发的消息，比如说有些不合法的交易也被转发了。这就是我们面临的一个实际问题，一个去中心化的系统中面临的实际问题。</p>
<h3 id="BTC-挖矿难度调整"><a href="#BTC-挖矿难度调整" class="headerlink" title="BTC-挖矿难度调整"></a>BTC-挖矿难度调整</h3><p>目标阈值越小，挖矿的难度越大。调整挖矿的难度就是调整目标空间在整个输出空间中所占的比例。</p>
<p>比特币用的哈希算法是SHA-256，这个产生的哈希值是256位。所以整个输出空间是2的256次方。调整这个比例，即目标空间占输出空间的比例，通俗的说，就是哈希值前面要有多少个0。比如说256位的哈希值，要是合法的区块，要求算出来的哈希，前面至少有70个0。当然这只是通俗的说法，因为这个目标阈值，并不是说前面都是0，从某一个位置开始，后面都变成了1。</p>
<p>挖矿的难度跟目标阈值是成反比的，公式是:difficulty(挖矿难度)&#x3D;difficulty_1_target &#x2F; target。上面是指挖矿难度等于1的时候所对应的目标阈值，挖矿难度最小就是1，这个时候对应的目标阈值是个非常大的数。</p>
<p>即target越大，挖矿是越容易的。所以公式里很大的一个数，除以当前的目标阈值，得到的就是当前的挖矿难度。所以difficulty和target大小是成反比的。</p>
<p>为什么要调整挖矿难度呢?如果不调会有什么问题呢?	系统里的总算力越来越强，挖矿难度保持不变的话，出块时间是越来越短的。</p>
<p>出块时间越来越短，会有什么问题吗?</p>
<p>比如说不到一秒就出一个区块，区块在网络上传播的时间可能需要几十秒，底层的比特币网络可能需要几十秒才能让其他节点都收到。别的节点没有收到这个区块之前还是继续沿着已有的区块链往下扩展。如果有两个节点同时都发布一个区块，这个时候就会出现分叉。出块时间如果越来越短的话，这种分叉会成为常态，而且不仅会出现二分叉，可能会出现很多的分叉。比如10个区块同时被挖出来，系统可能会出现10分叉。分叉如果过多，对于系统达成共识是没有好处的，而且危害了系统的安全性。比特币协议是假设大部分算力掌握在诚实的矿工手里。系统当中的总算力越强，安全性就越好，因为有恶意的节点想掌控51%的算力就越难。如果掌握了51%的算力，它就可以干很多坏事，比如分叉攻击。如果后面分叉多的话，前面某个区块里的某个交易，很可能就遭受分叉攻击，恶意节点会试图回滚。因为后面分叉多，算力就会分散，恶意节点得逞的概率更大。这个时候恶意节点就不需要51%的算力了，可能10%的算力就够了，因此出块时间不是越短越好。</p>
<p>那10分钟的出块时间是不是最优的呢?	不一定。改成其他值也可以，有间隔只是说应该有个常数范围。以太坊系统出块时间就降低到了15s，所以以太坊的出块速度是比特币的40倍。</p>
<p>出块时间大幅度下降之后，以太坊就要设计新的协议，叫ghost。在该协议中，这些分叉，产生的orphan block(即产生最长合法链后另一个要被丢弃的区块)就不能丢弃掉了，而是也要给它们一些奖励，这叫uncle reward。以太坊也要调整挖矿难度，使出块时间保持在15s。</p>
<p>讲完了为什么要调整挖矿难度，现在讲一下怎么调整挖矿难度。比特币协议中规定，每2016个区块后就要调整目标预值，这大概是每两个星期调整一次。</p>
<p>具体的调整公式:target(目标阈值) &#x3D;target×(actual time&#x2F;expected time)。actual time指产生2016个区块实际花费的时间，expected time指产生2016个区块应用的时间，即2016×10min。</p>
<p>如果实际花费时间超过了两周，即平均出块时间超过了10min。那么这时候挖矿难度要调的低一点，应该让出块更容易。因此该公式算出来的target会变大，则难度会下降。</p>
<p>实际上，上调和下调都有四倍的限制。假如实际时间超过了8个星期，那么我们计算公式时也只能按4倍算，目标阈值增大最多只能增大4倍。或是实际时间不到半个星期,那么我们计算公式时也只能按四分之一来算，目标阈值减小最多只能减少到四分之一。</p>
<p>那怎么才能让所有的矿工同时调整目标预值呢?	计算target的方法写在比特币系统的代码里，每挖到2016个区块会自动进行调整。</p>
<p>如果有有恶意的节点故意不调，会怎么样?	如果一个节点不调，将区块发布出去，诚实的节点是不会认的。nBits是target一个编码的版本，在block header里没有直接存储target的域，因为target的域是256位，直接存target的话要32个字节。nBits在header里只有四个字节，所以可以认为是它的一个压缩编码。</p>
<p>如果遇到有恶意的矿工，该调的时候不调，这时检查区块的合法性就通不过。因为每个节点要独立的验证发布的区块的合法性。检查的内容就包括:nBits，目标阈值设的对不对。如果投机取巧设计一个过大的目标阈值，使得你自己挖矿容易了，但这个区块是不会被接受的。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Difficulty%201.png"></p>
<p>如图显示的是比特币系统中总算力的变化情况。在比特币没有流行前，有很长一段时间，算力没有太明显的增长，前面这些年的hash rate几乎是0。其实这些年算力也是增长的，只是后面这些年算力增长的太快了，所以前面部分看上去像是一条直线。去年是涨得非常猛的一年，这也体现在了hash rate 的增长上，算力呈现出指数级的增长。即使在这段黄金时期，算力也不是单调递增的，中间也是有很多波动。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Difficulty%202.png"></p>
<p>如图是挖矿难度的变化情况，跟算力的增长基本上是同步的，这也符合难度调整的设计目标。通过调整挖矿难度，使得出块时间保持稳定。注意这个图显示的是挖矿难度，不是目标预值。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Difficulty%203.png"></p>
<p>如图是最近半年的难度调整曲线，可以看出很明显是一段一段的。每隔两个星期，难度上一个台阶，说明挖矿的人越来越多，用的设备越来越先进，反应出大家对比特币的热情越来越高。如果出现相反的情况，比如某个加密货币的挖矿难度越调越小，说明挖矿变得越来越容易了。但这不是好事，说明大家对币的热情是逐渐减小的。持续出现这种情况说明这个币将被淘汰。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Difficulty%204.png"></p>
<p>如图显示的是每天的出块时间。可以看出，总的来说出块时间稳定在10分钟上下振动。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Difficulty%205.png"></p>
<p>如图显示最近半年的出块时间，也是维持在10分钟左右。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Difficulty%206.png"></p>
<p>挖矿难度的公式:下一个难度&#x3D;前一个难度＊两周&#x2F;挖前2016个区块用的时间 (注意:前面的公式是目标阈值的公式，这个时挖矿难度的公式，不要混淆了)</p>
<h3 id="BTC-挖矿"><a href="#BTC-挖矿" class="headerlink" title="BTC-挖矿"></a>BTC-挖矿</h3><p>全节点介绍</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Mining%201.png"></p>
<p>轻节点介绍</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Mining%202.png"></p>
<p>比特币网络中大部分节点都是轻节点，如果只是转账而不是挖矿的话，没必要用全节点。挖矿过程中，如果你听到别人发布了一个区块，该区块是合法的，也是在延长最长合法链。这时候你该怎么办?</p>
<p>应该停止挖矿，然后重新在本地组装一个候选区块，再重新从头开始挖矿。因为如果沿着新发布的交易往下挖的话，那么本地组装的区块中包含的交易就会发生变化，有些交易可能已经被包含到新发布的区块里了。另外block header的内容也会发生变化，像block header里有交易所组成的merkle tree的根哈希值，还有指向前一个区块的指针，这些也都会发生变化。</p>
<p>这样做是不是有些可惜?	挖矿的一个性质是无记忆性，无论是继续挖原来的区块，还是停下来挖一个新组装出来的区块，成功的概率是一样的。只要还没有挖到符合要求的nonce值，前面已经挖了多长时间都是无所谓的。</p>
<p>即使挖到了合法的区块，发布到区块链上，也不能保证胜利了。有可能你发布的区块最终没有成为最长合法链，可能存在一些冲突情况，别人可能同时发布一些合法的区块，或者存在一些你不知道的double spending，使得你的区块中的某些交易变成冲突的。</p>
<p>比特币是怎么保证安全的?	两个方面:①密码学②共识机制 </p>
<p>①别人没有你的私钥，就没有办法伪造你的签名，所以不能把你账上的钱转走。(前提是系统中拥有大多数算力的矿工是好的，是遵守协议的，不会接受那些没有合法签名的交易。如果没有这些，密码学上的保证也就没有用武之地。)</p>
<p>比如:你去银行取钱，按照规定取钱得出示合法的证件，银行工作人员才能把钱给你。合法的证件就相当于密码学上的签名，密码学的性质保证了别人没有办法伪造你的签名，也就没有办法伪造你的身份。产生私钥以及签名的时候，都要有好的随机源，产生的随机数要足够随机。但又这些也不是足够的，银行工作人员要足够自觉，不能把钱交给那些没有合法证件的人，只有这两条合在一起，才能保证别人不能把你账上的钱转走。</p>
<p>挖矿的设备:挖矿设备演化趋势是越来越趋于专业化，最早的时候用的是普通的CPU挖矿，像家里计算机、笔记本电脑。但如果买一台计算机专门用来挖矿是非常不划算的，计算机当中的大部分内存都是闲置的，挖矿只用到其中很小一部分内存，CPU当中的大部分部件也是闲置的，因为挖矿当中计算哈希值的操作只用到了通用CPU当中的很少一部分指令。硬盘和其他很多资源也都是闲置的，所以随着比特币挖矿难度的提高，用CPU挖矿，用通用计算机挖矿显得性价比太低。</p>
<p>所以挖矿转入第二代设备:GPU。GPU效率相比CPU提高了很多，主要用于大规模的并行计算。但GPU用来挖矿还是有点浪费了，GPU是用于通用并行计算而设计的，用来挖矿的话有很多部件仍然是出于闲置状态，比如说用于浮点数计算的部件。这些部件对于深度学习来说是很重要的，但比特币的操作只用到了整数挖矿。所以GPU虽然效率提高了很多但仍然有不小的浪费。这些年GPU价格涨得很快，有些人归因于深度学习的火热，其实有很多GPU是用来挖矿的。不过有一个好消息，随着比特币挖矿难度的提升，用GPU挖矿已经划不来了，已经超过了GPU的算力范围，所以GPU现在可以更多的用于深度学习、游戏应用的服务。</p>
<p>有一些新开发的加密货币有的还在用GPU挖矿，而现在更多用ASIC芯片挖矿，这是专门为了挖矿而设计的芯片，上面没有多余的电动逻辑，整个芯片就是为了比特币挖矿、计算哈希值的操作而设计的。它的性价比是最高的，这个芯片除了挖矿什么事都干不了，而且为某一种加密货币设计的ASIC芯片，只能挖这一种加密货币。除非这两个加密货币用同一个mining puzzle。</p>
<p>有些加密货币刚发行的时候，为了解决能启动问题，会故意用一个已有的加密货币的mining puzzle，比如说跟比特币一样的mining puzzle，这样可以吸引更多的人来挖矿，这种情况叫merge mining。除了这种情况，其他都是一个芯片只能为一个加密货币挖矿。ASIC芯片生产周期需要一年，但跟其他通用芯片相比，ASIC芯片研发速度已经是非常快的了。</p>
<p>在这么长的生产周期里面，如果比特币价格出现剧烈变化的话，前期投入的研发费用可能就打水漂了。从历史上看，比特币的价格变化是比较剧烈的。曾经发生好几次，比特币的价格在几个月之内，下跌了80%，然后又慢慢恢复。</p>
<p>如果比特币价格大幅度下降的话，挖矿可能是赔本的，可能还抵不上电费。即使在比特币发展的黄金时期，价格不断上涨，这时挖矿是有利可图的。但是竞争也是越来越激烈的，定制的ASIC芯片可能用不了几个月就过时了。一款ASIC矿机刚上市的时候大部分的利润是在它上市的前两个月获得的，因为这个时候它的算力在同类产品中是最强的。再往后随着更强的矿机出现，它就可能被淘汰掉。所以购买ASIC矿机的时机很重要，现在都是要提前预定的。有些不良厂商，ASIC矿机生产出来之后，不是立即提供给消费者，而是自己先用来挖矿一段时间，赚取比特币，等到最赚钱的黄金时间即这前两个月过去之后，再把矿机发给用户。当比特币系统中算力突然有一个很大的提升，就说明某个大公司生产出了新一款的ASIC矿机。所以在挖矿热潮中真正赚钱的不一定是挖矿的用户，而可能是卖矿机的大厂商。</p>
<p>挖矿机的变化趋势，是从通用变得越来越专用，CPU是通用计算，GPU是通用并行计算，ASIC是专用计算。ASIC一旦过时就作废了，不像CPU和GPU还能做其他工作。很多人觉得这是不好的，是跟去中心化的理念是不相符的，也违背了比特币设计的初衷。最民主的情况是，大家都用家里的CPU计算机挖矿。后来改为GPU噪音是很大的。而有些新的加密货币设计的是Alternative mining puzzle。而设计它的出发点是asic resistance(抗asic芯片化)，目的是让通用的计算机也能参与挖矿的过程。</p>
<p>挖矿的另一个趋势是大型矿池的出现，单个矿工即使用了ASIC芯片，挖矿从平均收益上看是有利可图的，但是收入是非常不稳定的。比特币系统中平均每10分钟出一个区块，这是说比特币系统中所有的矿工做一个整体来看平均10min会产生一个区块。但如果具体到某一个矿工来说，他可能要挖很长时间，如果他用一个矿机可能要挖一两年。这样子就好像是买彩票，挖到了就是中了一个大奖。单矿工还有其他问题，他除了挖矿之外还要承担全节点的其他责任(就是这节课最开始介绍的那些)。</p>
<p>所以要引入矿池，所谓的矿池，就是把这些矿工组织起来，作为一个整体，矿池的架构一般是一个全节点会驱动很多矿机，一个矿池有一个矿主，叫pool manager。下面连了很多矿工，这些矿工只负责计算哈希值，全节点的其他职责都由矿主来承担。他负责监听网上的交易，把这些交易组织打包成区块，同时要看一看有没有其他的节点抢先发布区块，如果有的话看怎样进行调整…..</p>
<p>ASIC芯片只能负责计算哈希值，它不能干全节点的其他功能。矿池的出现还为了解决另一个问题:收入不稳定。单个矿工的收入是不稳定的，所以大家一起干，有了收益再进行分配。</p>
<p>那么收益该如何分配?矿池一般有两种组织形式，一种是像大型数据中心那样，有的互联网公司，有成千上万个服务器，大的矿池里面也有成千上万的矿机，这些矿机如果是属于同一个机构的话，那么收入怎么分配就不重要了。</p>
<p>但也有矿机是来自不同机构的，即第二种组织方式:分布式的。矿工和矿主不在同一个地方，可能分散在世界各地，那么矿工要加入一个矿池，就是按照矿池规定的通讯协议跟矿主进行联系。矿主把计算哈希值的任务分配给他，矿工计算完之后，把结果反馈给矿主，将来获得出块奖励时一起分配。</p>
<p>如果矿工是来自五湖四海的，不是属于同一个机构的，那么利益该怎么分配?平均分配行不行?比如每个矿工挖到一个区块，得到了出块奖励，然后平分给其他矿工，这样行吗?	不行，因为会有矿工偷懒。因此要按矿工的贡献大小进行分配，也就是这里同样需要工作量证明。那该怎么证明每个矿工做了多少工作呢？</p>
<p>为什么矿工的收入不稳定，因为挖矿太难了，如果把挖矿的难度降低之后，挖矿就会变得稳定了。怎么降低难度呢?	以前的要求是，矿工要找到一个nonce，用nonce计算block header 的哈希值，前面至少有70个0才是合法的区块。降低挖矿难度之后，比如说前面只要有60个0就行了，这样挖到的叫作一个share，这个share叫做almost valid block。矿工挖到share或almost valid block之后，把它提交给矿主。矿主拿到这个区块有什么用呢？用来证明矿工所做的工作量，而没有其他用途。矿主无法得到区块奖励以及任何好处。所以矿主就统计每个矿工提交了多少这样的share，将来等到某个矿工真正挖到了合法的区块之后，再将出块奖励按照每个矿工所做的工作量，提交的share数目进行分配。</p>
<p>这样做为什么是可行的?	每个矿工挖到矿的概率取决于他尝试的nonce数目，尝试的nonce越多，能找到的share就越多。</p>
<p>有没有可能一个矿工挖到一个合法的区块之后，不把它提交给矿主，而是自己偷偷摸摸发布出去，得到出块奖励?即平时挖到的share提交，但挖到了合法区块就不提交?	不可能，因为每个矿工的任务是由矿主分配的，矿主负责组装好一个区块，然后交给矿工去尝试各种nonce，而且挖矿仅仅调nonce是不够的，还需要调整coinbase parameter。所以矿主会把不同的coinbase parameter所对应的nonce值的范围交给不同的矿工去尝试。那么这个区块里包含什么?coinbase transaction里面有收款人的地址，这个地址填的是矿主的地址，即pool manager的地址，所以矿工挖到区块之后，如果他不提交给矿主自己发不出去是没有用的。里面的收款地址是矿主的，他取不出钱来。所以只要是当初按矿主给分配的任务进行挖矿的，就不可能偷区块奖励。</p>
<p>如果他一开始就不管矿主的任务，自己组装一个区块，偷偷把收款地址改成自己地址，会怎样?	那样他提交share给矿主的话，矿主是不认的，因为里面交易列表被改过了，coinbase transaction里面的内容发生了变化，算出的merkle tree 的根哈希值也是不一样的。这种情况下矿主是不会给他工作量证明的。那就相当于矿工一开始就单干，跟矿池是没关系的。</p>
<p>虽然不可能偷区块奖励，但会不会有人捣乱，比如平时挖到一个share，提交给矿主，作为工作量证明。等他挖到一个真正合法的区块之后，把它扔掉。这是有可能的，虽然没有经济好处，但有可能是别的矿池派来的卧底，不想让这个矿池得到区块奖励。这些矿工还是会分红，分的是别的矿工挖出来的区块奖励。</p>
<p>如图(第八节视频 第38分处 )是矿池在各个国家的分布比例，中国矿池占世界81%，远远超过其他国家，所以按矿池比例来看的话，中国的总算力是有绝对优势的。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Mining%203.png"></p>
<p>如图，如果按照单个矿池来看，在2014年，曾经有叫GHash.IO的矿池，这个矿池的算力，占到了全球算力的一半以上。在当时曾引起一些恐慌，这一个矿石的算力就已经足以发动51%的攻击了。这个事情公布之后，该矿池主动把算力占比大幅度的减少，以免动摇大家对比特币的信心。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Mining%204.png"></p>
<p>如图，是2018年的各矿池的算力分布，看上去没有那么集中了，GHash.IO矿池早已停止运营。当然，挖矿集中化的程度仍然是比较大的，几个大型矿池占了相当大的比重，但没有矿池占50%以上。这样看算比较安全了，但可能只是一个表面现象。假如一个机构有一半以上的算力，他不一定要把算力集中在一个矿池里，而可以把算力分散隐藏在很多矿池里，真正需要发动攻击的时候再集中起来发动攻击。</p>
<p>矿工转换矿池是很容易的，加入一个矿池就是按照这个矿池的协议跟这个矿主联系，矿池把组装好的区块信息发给矿工，矿工来尝试各种nonce值就可以了。</p>
<p>所以这就是矿池带来的危害，如果没有矿池，想要发动51%的攻击，攻击者要投入大量的成本来购买到足够的矿机，能够达到系统中半数以上的算力。有了矿池之后，他可能只占很小一部分比例的算力，只要能够吸引到足够多的矿工，足够多的不明真相的群众加入到他的矿池里来就行了。</p>
<p>一般来说，矿池的矿主要收取一定比例的出块奖励作为管理费。矿主也要按照比例收取管理费，有的是按照出块奖励的比例，也有的是抽取交易费。有的一些有恶意的矿池在发动攻击之前，可能故意把管理费降得特别低，甚至是赔本赚吆喝，吸引足够多的矿工加入之后就可以发动攻击了。这是大型矿池的一个弊端，使得51%的攻击更加容易了。</p>
<p>假如某个矿池占到了半数以上的算力，他具体能够发动哪些攻击呢?一个最常见的就是分叉攻击。假如一个区块链，其中一个区块包含了一个大笔的交易，又等了几个确认区块之后，自认为已经安全了。然后这时就可能有人在该交易前面的区块发动分叉攻击。</p>
<p>看上去好像追赶的道路是很漫长的，但如果拥有51%的算力，最终还是可以成功攻击。另外，不要把51%当成绝对的门槛，有可能不到51%就可以。算力都是估计的，而且算力还在不断变化。</p>
<p>攻击者还能做什么坏事?	还可以做boycott(封锁境域)。比如说攻击者不喜欢某个账户，怀疑某个账户参与非法交易，想把这个账户封锁掉，所有跟这个账户相关的交易都不让上链。假如A把某个交易A→B发布到区块链上，攻击者就会马上进行分叉，产生一个不包含这个交易的区块，所有跟A有关的交易也都不包含进去。</p>
<p>这种攻击跟分叉攻击区别是什么?	他没必要等后面几个确认区块。这时候如果攻击者等待确认区块，是为了让B放心，B以为后面有六个确认区块，已经没事了，然后攻击者再发动分叉攻击。而如果目的是为了boycott的话，就没有必要等后面区块生成。A→B交易一上链马上进行分叉，越早越好，因为攻击者是希望别人沿着他的链继续往下挖的。</p>
<p>前面讲过，有些有恶意的节点故意不把某些交易写入区块里，是可以的。但没有关系，后面的区块还是会包含的。但是如果这个坏人拥有51%的算力的话，他可能仗着自己算力强，公开抵制他想抵制的交易。这样别的矿工也不敢随便把交易打包进去了。</p>
<p>那么攻击者有没有可能掌握51%的算力后，把别人账上的钱转走?	这是不可能的。因为他没有别人账户的私钥，没有办法伪造签名。如果他仗着算力强，强行把一个没有合法签名的交易发布到区块链上，会有什么样的结果?	会造成分叉。因为诚实的矿工会沿着另外一个分叉去挖，不会沿着他发布的区块往下挖。所以盗币是不可能的。</p>
<p>总结:矿池的出现减轻了矿工的负担，矿工只需要挖矿，计算哈希值就行了，别的事情都由矿主来完成。矿工的收入分配也更加稳定。但矿池的出现也有危害，发动51%的攻击变得容易了。他不一定自己有这么强的算力，只要动员召集这些算力就可以了。</p>
<p>这有点类似于云计算中的on demand computing。平时不需要维护很大的计算机群，需要用的时候可以随时召回来。而矿池的情况，是on demand mining。</p>
<h3 id="BTC-比特币脚本"><a href="#BTC-比特币脚本" class="headerlink" title="BTC-比特币脚本"></a>BTC-比特币脚本</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Script%201.png"></p>
<p>如图是比特币的一个交易实例。该交易有一个输入两个输出。左上角写着output，其实是这个交易的输入。右边两个输出，上面unspent即没有花出，下面spent表示已花出。该交易已经收到了23个确认，所以回滚的可能性很小了。</p>
<p>下面是这个交易的输入输出脚本，输入脚本包含两个操作，分别把两个很长的数压入栈里。比特币使用的脚本语言是非常简单的，唯一能访问的内存空间就是一个堆栈。不像通用的编程语言，像C语言C++那样有全局变量、局部变量、动态分配的内存空间，它这里就是一个栈，所以叫做基于栈的语言。这里输出脚本有两行，分别对应上面的两个输出。每个输出有自己单独的一段脚本。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Script%202.png"></p>
<p>如图是交易的具体内容。首先看交易的一些宏观信息。</p>
<p>第一行:transaction ID</p>
<p>第二行hash:该交易的哈希值</p>
<p>第三行:使用的比特币协议的版本</p>
<p>第四行:该交易的大小</p>
<p>第五行:用来设定交易的生效时间，此处的0表示立即生效。绝大多数情况下，locktime都是0。如果是非零值，那么该交易要过一段时间才能生效。比如要等10个区块以后才能被写入区块链里。</p>
<p>第六行第七行的vin、vout是输入输出部分，后面会详细讲解。</p>
<p>第八行:这个交易所在区块的哈希值。</p>
<p>第九行:该交易已经有多少个确认信息。</p>
<p>第十行:交易产生的时间</p>
<p>第十一行:这个区块产生的时间</p>
<p>(time 和block time都是指很早的一个时间到现在过了多少秒)</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Script%203.png"></p>
<p>如图是交易的输入结构。一个交易可以有多个输入，在这个例子中只有一个输入。每个输入都要说明该输入花的币是来自之前哪个交易的输出，所以前两行给出输出币的来源。</p>
<p>第一行:之前交易的哈希值</p>
<p>第二行:vout表示这个交易里的第几个输出。所以这里表示花的币来自于哈希值为c0cb…c57b的交易中第0个输出。</p>
<p>接下来是输入脚本，输入脚本最简单的形式就是给出signification就行了，证明你有权利花这个钱。(后面的PPT中scriptsig就写成input script输入脚本)。如果一个交易有多个输入，每个输入都要说明币的来源，并且要给出签名，也就是说比特币中的一个交易可能需要多个签名。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Script%204.png"></p>
<p>如图是交易的输出，也是一个数组结构。该例子中有两个输出，value是输出的金额，就是给对方转多少钱，单位是比特币，即0.22684个比特币。还有的单位是satoshi(聪)，是比特币中最小的单位。1比特币&#x3D;10的8次方聪。n是序号，表示这是这个交易里的第几个输出。(scriptpubkey是输出脚本，后面都写成output script)。输出脚本最简单的形式就是给出一个pubkey。下面asm是输出脚本的内容，里面包含一系列的操作，在后面会详细解释。require sigs表示这个输出需要多少个签名才能兑现，这两个例子中都是只需要一个签名。type是输出的类型，这两个例子类型都是pubkeyhash，是公钥的哈希。addresses是输出的地址。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Script%205.png"></p>
<p>如图是展示输入和输出脚本是怎样执行的。在区块链第二个区块里有A→B的转账交易，B收到转来的钱后，又隔了两个区块，把币又转给了C。所以B→C交易的txid、vout是指向A→B交易的输出。而要验证交易的合法性，是要把B→C的输入脚本，跟A→B交易的输出脚本拼接在一起执行。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Script%206.png"></p>
<p>如图这里有个交叉，前面交易的输出脚本放在后面，后面交易的输入脚本放在前面。在早期的比特币实践中，这两个脚本是拼接在一起，从头到尾执行一遍。后来出于安全因素的考虑，这两个脚本改为分别执行。首先执行输入脚本，如果没有出错就再执行输出脚本。如果能顺利执行，最后栈顶的结果为非零值，也就是true，那么验证通过，这个交易就是合法的。如果执行过程中出现任何错误，这个交易就是非法的。如果一个交易有多个输入的话，那么每个输入脚本都要和所对应的交易的输出脚本匹配之后来进行验证。全都验证通过了，这个交易才是合法的。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Script%207.png"></p>
<p>如图是输入、输出脚本的几种形式。一种最简单的形式就是P2PK(pay to public key)。输出脚本里直接给出收款人的公钥，下面一行checksig，是检查签名的操作。在输入脚本里，直接给出签名就行了。这个签名是用私钥对输入脚本所在的整个交易的签名。这种形式是最简单的，因为公钥是直接在输出脚本里给出的。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Script%208.png"></p>
<p>如图是脚本的实际执行情况。这三行是把输入脚本和输出脚本拼接起来之后的结果。第一行来自输入脚本，后两行来自输出脚本。注意，实际代码中出于安全考虑，这两个脚本实际上是分别执行的。</p>
<p>第一行:把输入脚本提供的签名压入栈</p>
<p>第二行:把输出里提供的公钥压入栈</p>
<p>第三行:checksig是把栈顶的这两个元素弹出来。用公钥检查一下这个签名是否正确。如果正确，返回true，说明验证通过。否则，执行出错，这个交易就是非法的。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Script%209.png"></p>
<p>如图是P2PK的一个实例。上面交易的输入脚本就是把签名压入栈，下面交易是上面交易输入的币的来源。它的输出有两行，第一行是把公钥压入栈，第二行就是checksig。这是第一种形式。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Script%2010.png"></p>
<p>如图是第二种形式P2PKH(pay to public key hash)，跟第一种区别是输出脚本里没有直接给出收款人的公钥，给出的是公钥的哈希。公钥是在输入脚本里给出的。输入脚本既要给出签名，也要给出公钥。输出脚本里还有一些其他操作，DUP、HASH160等等，这些操作都是为了验证签名的正确性。P2PKH是最常用的形式。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Script%2011.png"></p>
<p>如图是脚本的执行结果，这个是把上一页的输入脚本和输出脚本拼接之后得到的，前两条语句来自输入脚本，后面的语句来自输出脚本，还是从上往下执行。</p>
<p>第一条语句先把签名压入栈</p>
<p>第二条语句把公钥压入栈</p>
<p>第三条语句是把栈顶的元素复制一遍，所以栈顶又多了一个公钥。</p>
<p>第四条语句的HASH160是把栈顶元素弹出来，取哈希，然后把得到的哈希值再压入栈。所以栈顶变成了公钥的哈希值。</p>
<p>第五行是把输出脚本里提供的公钥的哈希值压入栈。这个时候栈顶有两个哈希值，上面的哈希值是输出脚本里面提供的，收款人公钥的哈希，即我发布交易时，转账的钱是转给谁的，在输出脚本里提供一个收款人的公钥的哈希。下面的哈希是指你要花这个钱时在输入脚本里给出的公钥，然后前面的操作HASH160是取哈希后得到的。</p>
<p>第六行的语句操作的作用是弹出栈顶的两个元素，比较是否相等，即比较其哈希值是否相等。这样做的目的是防止有人莫名顶替，用自己的公钥冒充收款人的公钥。假设两个哈希是相等的，那么就从栈顶消失了。</p>
<p>最后一条语句作用是用公钥检查弹出栈顶的元素是否正确。假设签名是正确的，整个脚本就顺利运行结束，栈顶留下的是true。如果执行过程任何一个环节发生错误，比如输入里给出的公钥跟输出里给出的哈希值对不上，或者是输入里给出的签名跟给出的公钥对不上，那么这个交易就是非法的。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Script%2012.png"></p>
<p>P2PKH是最常用的脚本信息，该实例用的就是这种脚本。输入脚本就是把签名压入栈，把公钥压入栈。下面的输出脚本复制栈顶元素，然后取哈希值，hash160。然后把公钥的哈希压入栈，最后比较栈顶的两个哈希值，检查签名。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Script%2013.png"></p>
<p>最后一种如图，也是最复杂的一种脚本形式，是Pay to Script Hash。这种形式的输出脚本给出的不是收款人的公钥的哈希，而是收款人提供的一个脚本的哈希，这个脚本叫redeemscript(赎回脚本)。将来花这个钱时输入脚本里要给出redeemscript(这个赎回脚本的具体内容)，同时还要给出让赎回脚本能够正确运行所需要的签名。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Script%2014.png"></p>
<p>验证时分为两部，第一步验证输入脚本里给出的赎回脚本是不是跟输出脚本里给出的赎回脚本的哈希值匹配，如果不匹配说明给出的赎回脚本是不对的，就类似于刚才讲的pay to public key hash里面给出的公钥不对一样。匹配不上说明给出的赎回脚本是不对的，那么验证就失败了。如果输入里给出的赎回脚本是正确的，那么第二步还要把赎回脚本的内容当做操作指令来执行一遍，看看最后能不能顺利执行。如果两步验证都通过了，那么这个交易才是合法的。听上去有点抽象，那么下面看一个具体的例子。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Script%2015.png"></p>
<p>用pay to script hash实现pay to public key 的功能。这里的输入脚本就是给出签名，再给出序列化的赎回脚本，赎回脚本的内容就是给出公钥，然后用checksig检查签名。下面这个输出脚本是用来验证输入脚本里给出的赎回脚本是否正确。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Script%2016.png"></p>
<p>如图看一下pay to script hash的执行过程。开始也是把输入脚本和输出脚本拼接在一起，前两行来自输入脚本，后面三行来自输出脚本。首先把输入脚本的签名压入栈，然后把赎回脚本压入栈，然后是取哈希的操作，得到赎回脚本的哈希。这里RSH是指redeem script hash，赎回脚本的哈希值。接下来还要把输出脚本里给出的哈希值压入栈，这时栈里就有两个哈希值了。最后用equal比较这两个哈希值是否相等，如果不等就失败了。假设相等，那这两个哈希值就从栈顶消失了，到这里第一阶段的验证就算结束了，接下来还要进行第二个阶段的验证。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Script%2017.png"></p>
<p>如图第二个阶段首先要把输入脚本提供的序列化的赎回脚本进行反序列化，这个反序列化的操作在PPT上并没有展现出来，这是每个节点自己要完成的。然后执行赎回脚本，首先把public key压入栈，然后用checksig验证输入脚本里给出的签名的正确性。验证痛过之后，整个pay to script hash才算执行完成。</p>
<p>有人可能会问:干脆用pay to public key就行了，搞这么复杂干嘛?为什么非要把这些功能嵌入到赎回脚本里面?	对于这个简单的例子来说确实是复杂了，但pay to script hash它的常见的应用场景是对多重签名的支持。</p>
<p>比特币系统中一个输出可能要求多个签名才能把钱取出来，比如某个公司的账户，可能要求五个合伙人中任意三个人签名才能把公司账户上的钱取走，这样为私钥的泄露提供了一些安全的保护。</p>
<p>比如说有某个合伙人私钥泄露出去了，那么问题也不大，因为还需要两个人的签名才能把钱取走。这同时也为私钥的丢失提供了一些冗余，即使有两个人把私钥忘掉了，省下的三个人依然可以把钱取出来，然后转到某一个安全的账户。</p>
<p>以上的功能是通过check multisig来实现的。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Script%2018.png"></p>
<p>如图，输出脚本里给出N个公钥，同时指定一个预值M。输入脚本只要提供接N个公钥对应的签名中任意M个合法的签名就能通过验证。 </p>
<p>比如刚才举的例子中，N&#x3D;5，M&#x3D;3，五个合伙人中任意三个的签名都可以，输入脚本的第一行有一个红色的“×”，这是什么意思呢?</p>
<p>比特币中check multisig的实现，有一个bug，执行的时候会从堆栈上多弹出一个元素，这个就是它的代码实现的一个bug。这个bug现在已经没有办法改了，因为这是个去中心化的系统，要想通过软件升级的方法去修复这个bug代价是很大的，要改的话需要硬分叉。所以实际采用的解决方案，是在输入脚本里，往栈上多压进去一个没用的元素，第一行的“×”就是没用的多余的元素。另外需要注意给出的M个签名的相对顺序，要跟它们在N个公钥中的相对顺序是一致的才行。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Script%2019.png"></p>
<p>如图是check multisig的执行过程。这个例子假设三个签名中给出两个就行。图中可以看到这两个签名给出的相对顺序也是跟它们在公钥中的顺序是一样的。在公钥当中，第一个公钥排在第二个公钥前面。那么给出这两个签名的时候也是第一个签名排在第二个的前面。</p>
<p>第一行的false就是前面说的多余的元素。首先把多余的元素压入栈里，然后把两个签名依次压入栈，这个时候输入脚本就执行完了。接下来的输出脚本里把M的值，即预值M压入栈。然后把三个公钥压入栈，接着把N的值压入栈，最后执行check multisig，看看堆栈里是不是包含了这三个签名中的两个，如果是那么验证通过。</p>
<p>注意:这个过程中并没有用到pay to script hash。就是用比特币脚本中原生的check multisig来实现的。这么实现有什么问题吗？</p>
<p>早期的多重签名就是这样实现的，在实际的应用当中，有一些不是很方便的地方。</p>
<p>比如:网上购物。某个电商用multi签名，要求有五个合伙人中任意三个人的签名才能把钱取出来，要求网上购物的用户在支付的时候生成的转账交易里给出这五个合伙人的公钥，同时要给出N和M值。在这个例子中，N&#x3D;5，M&#x3D;3，这些都是用户在网上购物的时候生成转账交易时输出脚本里要给出的信息，给出这五个公钥，给出N和M值。</p>
<p>那么用户怎么知道这些信息呢?	需要购物网站在网上公布出来，比如网上可以公布我们用了多重签名，我们用的五个签名中要给出三个，这是五个公钥，然后用户生成这个转账交易的时候，就把这些信息填进去。那么不同的电商采用的多重签名的规则是不一样的。有的电商可能是五个签名中要任意三个，有的可能要四个。这就给用户生成转账交易带来了一些不方便的地方，因为这些复杂性都暴露给用户了。</p>
<p>那么该如何解决?	这里就要用到pay to script hash。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Script%2020.png"></p>
<p>如图是用pay to script hash实现的多重签名，它的本质是把复杂度从输出脚本转移到了输入脚本。现在这个输出脚本变得非常简单，只有这三行。原来的复杂度被转移到redeemscript赎回脚本里。输出脚本只要给出这个赎回脚本的哈希值就可以了。赎回脚本里要给出这N个公钥，还有N和M的值，这个赎回脚本是在输入脚本里提供的，也就是说是由收款人提供的。</p>
<p>像前面网上购物的例子，收款人是电商，他只要在网站上公布赎回脚本的哈希值，然后用户生成转账交易的时候把这个哈希值包含在输出脚本里就行了。至于这个电商用什么样的多重签名规则，对用户来说是不可见的，用户没必要知道。从用户的角度来看采用这种支付方式跟采用pay to public key hash没有多大区别，只不过把公钥的哈希值换成了赎回脚本的哈希值。当然，输出脚本的写法上也有一些区别，但不是本质性的。这个输入脚本是电商在花掉这笔输出的时候提供的，其中包含赎回脚本的序列化版本，同时还包含让这个赎回脚本验证通过所需的M个签名。将来如果这个电商改变了所采用的多重签名规则，比如由五个里选三个变成三个里选两个，那么只要改变输入脚本和赎回脚本的内容，然后把新的哈希值公布出去就行了。对用户来说，只不过是付款的时候，要包含的哈希值发生了变化，其他的变化没有必要知道。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Script%2021.png"></p>
<p>如图是具体的执行过程。这是把输入脚本和输出脚本拼接在一起后的情况，第一行的FALSE就是为了应付check multisig的bug而准备的一个没用的元素，执行的时候先把它压入栈，然后依次把两个签名压入栈，接下来是序列化的赎回脚本，目前只是把它作为数据压入栈，到这里输入脚本就执行完了。下面是输出脚本，取哈希，然后把输出脚本里提供的哈希值压入栈顶。最后判断两个哈希值是否相等，到这里第一阶段的验证就完成了。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Script%2022.png"></p>
<p>如图开始第二阶段的验证，把赎回脚本展开后执行。先把M压入栈，然后把三个公钥压入栈，把N压入栈，最后检查多重签名的正确性，三个里面有两个是正确的。第二阶段的验证过程跟前面直接使用check multisig的情况是类似的。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Script%2023.png"></p>
<p>如图是网上使用pay to script hash来做多重签名的一个实例。上面输入脚本的最后一个就是序列化的赎回脚本，反序列化之后得到的就是三个里面取两个的多重签名脚本。下面这个输出脚本的内容，跟前面讲的是一样的。现在的多重签名，一般都是采用这种pay to script hash的形式。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Script%2024.png"></p>
<p>如图这种脚本格式是比较特殊的，这种格式的输出脚本开头是return的操作，后面可以跟任意的内容。return操作的作用，是无条件的返回错误，所以包含这个操作的脚本永远不可能通过验证，执行到return语句，就会出错，然后执行就终止了，后面跟的内容根本没有机会执行。</p>
<p>为什么要设计这样的输出脚本呢？这样的输出岂不是永远花不出去吗？	无论输入脚本写的是什么内容，执行到输出的return语句，它就会报错，那么这里的钱永远都花不出去。确实如此，这个脚本是销毁比特币的一种方法。</p>
<p>为什么要销毁比特币呢？这个一般有两种应用场景:</p>
<p>①有些小的币种要求销毁一定数量的比特币才能够得到这个币种，有时候把这种小币种称为AltCoin(Alternative coin)。除了比特币之外的其他小的加密货币都可以认为是Alternative Coin。比如有的小币种要求销毁一个比特币可以得到1000个小币，也就是说要用上述的方法证明已经付出了一定的代价才能够得到这个小币种。</p>
<p>②往区块链里写入一些内容。区块链是个不可篡改的账本，有人就利用这个特性往里面添加一些需要永久保存的内容，比如第一节课讲的digital commitment。要证明在某个时间，知道某些事情。比如涉及知识产权保护的，把某项知识产权的内容取哈希之后，把哈希值放到return语句的后面，其后面的内容反正是永远不会执行的，往里面写什么都没关系。而且放在这里的是一个哈希值，不会占太大的地方，而且也没有泄露出来你知识产权的具体内容。将来如果出现了纠纷，像知识产权的一些专利诉讼，再把具体的哈希值的输入内容公布出去，证明你在某个时间点已经知道某个知识了。</p>
<p>这个应用场景和coinbase域相似。coinbase transaction里面有个coinbase域，在这个域里写什么内容同样是没人管的，那这里为什么不用coinbase的方法呢？coinbase还不用销毁比特币，就可以直接往里写。</p>
<p>coinbase的方法只有获得记账权的那个节点才能用。如果是一个全节点，挖矿挖到了，然后发布一个区块，可以往coinbase transaction 里的coinbase域写入一些内容，这是可以的。</p>
<p>而我们说的上述方法，是所有节点都可以用的，甚至不一定是个节点，可能就是一个普通的比特币上的一个用户，任何人都可以用这种方法去写入一些内容。发布交易不需要有记账权，发布区块才需要有记账权。任何用户都可以用这种方法销毁很少的比特币，比如0.0000001个比特币，换取往区块链里面写入一些内容的机会。其实有些交易根本没有销毁比特币，只不过支付了交易费。</p>
<p>下面看两个实例</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Script%2025.png"></p>
<p>如图是一个coinbase transaction。这个交易有两个输出，第一个输出的脚本是正常的pay to public key hash，输出的金额就是得到的block reward加上transaction fee。第二个输出的金额是0，输出脚本就是刚才提到的格式:开头是return，后面跟了一些乱七八糟的内容，第二个输出的目的就是为了往区块链里写一些东西。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Script%2026.png"></p>
<p>如图这是个普通的转账交易，输出脚本也是以return开头的。这个交易的输入是0.05个比特币，输出金额是0，说明输入金额全部用来支付交易费了。这个交易实际上并没有销毁任何比特币，只不过是把输入里的比特币作为交易费转给挖到矿的矿工了。</p>
<p>这种形式的脚本的一个好处是:矿工看到这种脚本的时候知道它里面的输出永远不可能兑现，所以就没必要把它保存在UTXO里面，这样对全节点是比较友好的。还有一点要说明:这个PPT当中涉及到比特币脚本的操作为了简单起见都没有加上OP前缀。比如CHECKSIG，实际上应该写成OP_CHECKSIG，CHECKMULTISIG、DUP也是如此。</p>
<p>比特币系统中用到的这种脚本语言是非常简单的，甚至连专门的名字都没有，它就叫比特币脚本语言(bitcoin scripting language)。后面可以看到，以太坊当中用的智能合约的语言比这个要复杂的多。比如说比特币的脚本语言不支持循环，所以有很多功能这个语言是实现不了的，这样的设计是有其用意的，不支持循环就不会有死循环，就不用担心停机问题。以太坊当中智能合约的语言表达能力很强，所以就要靠汽油费的机制来防止程序陷入死循环。</p>
<p>另外一方面，这个语言虽然在某些方面功能是很有限的，但是在另外一些方面它的功能却很强大，比如跟密码学相关的功能。如checkmultisig，检查多重签名用一条语句就能够完成，这个比很多通用的编程语言要方便的多。所以比特币的脚本语言虽然看上去很简单，但其实针对比特币的应用场景做了很好的优化。</p>
<h3 id="BTC-分叉"><a href="#BTC-分叉" class="headerlink" title="BTC-分叉"></a>BTC-分叉</h3><p>区块链由一条链变为两条链就叫分叉。分叉可能是多种原因造成的，比如挖矿的时候，两个节点差不多同一个时候挖到了矿，就会出现一个临时性的分叉，我们把这个分叉叫作state fork，是由于对比特币区块链当前的状态有意见分歧而导致的分叉。</p>
<p>前面还讲过分叉攻击(forking attack)，它也属于state fork(状态分叉)，也是属于对比特币这个区块链当前的状态产生的意见分歧，只不过这个意见分歧是故意造成的，人为造成的，所以我们又叫它deliberate fork。</p>
<p>除了这种state fork 之外，还有一种产生分叉的情况是，比特币的协议发生了改变，要修改比特币系统需要软件升级。在一个去中心化的系统里，升级软件的时候没有办法保证所有的节点同时都升级软件。</p>
<p>假设大部分节点升级了软件，少数节点因为种种原因可能没有升级，有可能是还没来得及升级，也可能是不同意对这个协议的修改。即假如你想把协议改成某个样子社区中可能是有人不支持的，这个时候也会出现分叉，这种分叉叫protocol fork(协议分叉)。因为对比特币协议产生了分歧，用不同版本的协议造成的分叉，我们称作protocol fork。</p>
<p>根据对协议修改的内容的不同，我们又可以进一步分成硬分叉和软分叉。出现硬分叉的情况:如果对比特币协议增加一些新的特性，扩展一些新的功能，这些时候那些没有升级软件的这些旧的节点，它是不认可这些新特性的，认为这些特性是非法的，这就属于对比特币协议内容产生了意见分歧，所以会导致分叉。</p>
<p>硬分叉的一个例子就是比特币中的区块大小限制(block size limit)。比特币系统规定每个区块最多是1M字节，有些人认为1M的限制太小了，也增加了交易的延迟。可以计算一下:1M&#x3D;1百万 一个交易大概认为是250个字节 1百万&#x2F;250&#x3D;4000 一个区块大概是4000个交易 平均10分钟出现一个区块 4000&#x2F;(60×10)&#x3D;7 大概每秒钟产生7笔交易即7tx&#x2F;sec 这个传输速度是非常低的。</p>
<p>有人发布一个软件更新，把block size limit从1M增加到4M。假设大多数节点更新这个软件，把block size limit更新到4M，少数节点没有更新。这里的大多数节点和少数节点不是按照账户数目来算的，而是按照算力，即系统中拥有大多数哈希算力的节点都更新了软件。新节点认为区块大小限制是4M，旧节点认为是1M。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Fork%201.png"></p>
<p>如图这时运行系统，会有什么结果?	假如一个新节点挖出一个区块，这个区块比较大，但旧节点不认可，它忽略大区块的存在会继续沿着它的前一个小区块接着挖。而旧节点如果挖出了区块新节点是认可的，因为4M的限制指不能超过4M，比4M小是可以的。</p>
<p>那为什么会产生分岔呢?	大区块挖出之后，因为大多数区块是更新了的，是认可新的大区块的，所以会沿着它继续挖。只有少数旧节点会接着下面链往下挖，这时新节点认为上下两条链都是合法的，但上面那条是最长合法链，所以会沿着上面一条挖。而且算力足够大会使上面那条链越来越长。而旧节点认为上面的链无论多长都是非法的，它们只会沿着下面的链挖。当然上面的链也可能出现小区块，因为新节点也可能挖出大小不到1M的区块，虽然这种是新旧节点都认可的，但这是没有用的，因为这条链上它们认为有非法的区块。所以这种分叉是永久性的，只要旧节点不更新软件，分叉就不会消失，所以才叫它硬分叉。</p>
<p>比特币社区当中有些人是比较保守的，提高block size limit有些人就是不同意。而且区块的大小也不是越大越好，比特币底层系统是个P2P overlay network，它的传播主要采用flooding的方式，所以对带宽的消耗是很大的，带宽是瓶颈。</p>
<p>那么旧节点挖出的小的区块还有没有出块奖励呢？	出现hard fork后出现了两条平行运行的链，平行运行链彼此之间有各自的加密货币。下面链的出块奖励在下面链里是认的。而分叉之前的币按道理应该是上下两条链都认可，所以会拆成两部分。</p>
<p>曾经出现过这样的问题:分叉前有A→B的交易，分叉后在上面链出现了B→C，下面链也出现了B→C，因为账户，私钥都是一样的。既然如此，就会有人利用这个特性，想收到上下两条链的转账。但如果没有人转账给他怎么办？</p>
<p>可以这样做:比如说B去购物，花一笔钱，给了C。后来B要退货，要取消这笔交易，C又把钱交给B。然后B又在下面一条链进行回放，就赚了一笔钱。那么在开始B转给C的交易在下面链会不会回放呢？所以这样做也是有风险的。为了解决这个问题，就让这两条链各带一个chain ID，所以现在以太坊的分叉已经没有问题了，就是两条独立运行的链了。</p>
<p>soft fork(软分叉):</p>
<p>软分叉出现的情况是什么?	如果对比特币协议加一些限制，加入限制之后原来合法的交易或区块在新的协议当中有可能变的不是合法了，这就引起软分叉。</p>
<p>假设有人发布一个软件更新，把这个区块大小变小了。调整区块大小不止是改变一个参数那么简单。一个去中心化的系统，改变一个参数，就可能导致分叉，而且取决于这个参数是怎么改的。有可能是硬分叉，也有可能是软分叉。这里把区块大小变小只是为了解释软分叉这个概念，实际中是不会这么做的。</p>
<p>假设新节点把区块大小改为0.5M，旧节点依然以1M为准，这时候会出现什么情况？假如一个区块链开始分叉，新节点挖出小区块，这种区块旧节点也是认的。而旧节点挖出的大区块新节点是不认的。这样下去，旧节点看到上面链更长，而且是合法的之后，就会转去挖上面的链。</p>
<p>所以为什么称这种分叉是软分叉?	因为这种分叉是临时性的。所以旧节点如果不更新软件，它们挖的区块可能就白挖了。旧节点转向上面的链挖的话，问题可能又会出现:它们可能又挖出了大区块。而新节点不认这个，新节点会继续沿着大区块前面一个小区块挖，如图所示。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Fork%202.png"></p>
<p>实际中可能出现软分叉的情况:给某些目前协议中没有规定的域增加一些新的含义，赋予它们一些新的规则，典型的例子就是coinbase域。前面讲过每一个发布的区块里可以有一个铸币交易(coinbase transaction)，coinbase transaction里有一个域叫coinbase域，这个域用来干什么是没人规定也没人检查的。</p>
<p>前面讲过coinbase域的一个用途:可以把它作为extra nonce。挖矿的时候要不断调整block header里的nonce，但block header里的nonce只有四个字节，最多只有2的32次方个可能性，所以实际中可以把coinbase前八个字节用来做extra nonce。两个合在一起就成了2的96次方，对于目前的挖矿难度，这个域已经是足够了。但coinbase域不止是八个字节，后面还有很多，剩下的字节有人就提议做UTXO集合的根哈希值。</p>
<p>目前这个集合只是每个全节点自己在内存中维护的，主要是为了快速查找、判断该交易是不是属于double spending，但这个集合的内容并没有写到区块链里，这跟前面讲到的merkle proof是不太一样的。</p>
<p>merkle proof能证明什么？证明某个交易是不是在给定的区块里。比如一个轻节点，没有维护整个区块的内容，只知道block header。轻节点问一个全节点:该交易是不是在这个区块里?  全节点返回一个merkle proof作为证明，轻节点就可以验证是否属实。但如果是另外一种情况，想要证明某个账户上有多少钱，这个目前在比特币系统中是证不出来的。如果是全节点还可以算一下，方法如下:想要知道A账户有多少钱，就看一下A在UTXO里对应的输出总共收到多少个币，就是该账户上有多少钱。</p>
<p>对于全节点是可以算出来的，但如果是区块链钱包、有的手机上的APP，它不可能在手机上维护一个完整的区块链，它实际上是个轻节点，它想要知道账户的余额需要询问全节点。全节点返回一个结果，怎么知道这个结果是否属实呢？现在是证不出来的。如果你自己不维护一个UTXO集合，就没法用merkle proof 证出来。</p>
<p>有人提议把UTXO集合当中的内容也组织成一颗merkle tree，这个merkle tree有一个根哈希值，根哈希值写在coinbase域里面。因为block header没法再改了，改block header动静就太大了，coinbase域正好是没人用的，所以就写入UTXO的根哈希值。coinbase域当中的内容最终往上传递的时候会传递到block header里的根哈希值里。所以改coinbase域的内容，根哈希值会跟着改。因此这个提案就是说把UTXO集合的内容组织成merkle tree，算出一个根哈希值来，写入coinbase域里某个位置。coinbase域的内容本身也会算哈希，算到block header里的根哈希值，这样就可以用merkle proof证出来了。</p>
<p>假设有人发布一个软件更新，规定coinbase域要按照这个要求来填写，大多数节点都升级了软件，少数节点没有更新，这属于软分叉，因为新节点发布的区块旧节点认为是合法的，因为旧节点不管新节点写什么内容。但旧节点发布的区块新节点可能是不认的，因为如果coinbase域不按要求写它是不认的，所以属于软分叉。</p>
<p>比特币历史上比较著名的软分叉的例子是pay to script hash。P2SH这个功能在最初的比特币版本里是没有的，它是后来通过软分叉的功能给加进去的。这是什么意思呢?  你支付的时候不是付给一个public key的哈希，而是付给一个赎回脚本的哈希。花钱的时候要把这个交易的输入脚本跟前面币的来源的交易的输出脚本拼接在一起执行。执行的时候验证分为两步，第一步是要验证输入脚本中给出的redeem script跟前面那个输出脚本给出的script的哈希值是对的上的，证明输入脚本里提供的script是正确的。第二步再执行redeem script，来验证输入脚本里给出的签名是合法的。</p>
<p>对于旧节点来说，它不知道P2SH的特性，只会做第一阶段的验证，即验证redeem script是否正确。新节点才会做第二阶段的验证，所以旧节点认为合法的交易新节点可能认为是非法的(如果第二阶段的验证通不过的话)。而新节点认为合法的交易旧节点肯定认为是合法的，因为旧节点只验证第一阶段。</p>
<p>总结:</p>
<p>soft fork是什么?	只要系统中拥有半数以上算力的节点更新了软件，那么系统就不会出现永久性的分叉，只可能有一些临时性的分叉。hard fork特点是什么？必须是所有的节点都要更新软件，系统才不会出现永久性的分叉，如果有小部分节点不愿意更新，那么系统就会分成两条链。</p>
<h3 id="BTC-问答"><a href="#BTC-问答" class="headerlink" title="BTC-问答"></a>BTC-问答</h3><p>一、转账交易时如果接收者不在线怎么办？</p>
<p>这个时候不需要接收者在线，转账交易只不过是在区块链上记录一下，把一个人账户上的比特币转移到他人的账户上，他本人是否当时连接在比特币网络上是没有影响的。</p>
<p>二、假设某个全节点收到了一个转账交易，有没有可能转账交易中接收者的收款地址是这个节点以前从来没有听说过的?</p>
<p>这是可能的。比特币账户在创建的时候是不需要通知其他人的，在本地产生一个公私钥对就可以了。只有在产生收款地址以后第一次收到钱时，其他节点才知道这个账户的存在。</p>
<p>三、如果账户的私钥丢失了，该怎么办?</p>
<p>私钥丢失之后是没有办法的。该账户上的钱就变成了死钱，永远取不出来了。在去中心化的系统里，是没有人可以给你重置密码的。</p>
<p>另外，有些加密货币交易时，一般来说交易所是中心化的机构。在交易所开办一个账户的时候，一般是要提供身份证明的。这种情况下把比特币保存在交易所里，私钥实际上是由交易所来保管的。登录这个交易所是按照登录银行差不多的程序，即一个账户名一个密码，一般来说需要二次验证，比如Google身份验证器产生一次性密码，通过二次验证然后登录。</p>
<p>这种情况下如果账户密码丢失了，是可以跟交易所联系的，通过身份验证之后重置密码。有一些在线钱包也提供保管私钥的功能，但比特币或加密货币的交易所处于一种缺乏监管的状态，这个跟股票交易所是很不一样的。历史上曾发生很多次加密货币的交易所被黑客攻击的情况。最著名的是日本的Mt.Gox的事件，它曾经是全世界最大的一个比特币交易所，交易量占到了全球比特币交易量的70%，后来被黑客攻击，丢失了大量的比特币。后来交易所破产了，其CEO被判刑。各种加密货币交易所出现问题的情况发生了很多次，也有内部监管不当，管理人员卷钱跑路也时常发生。相比之下，一些冷钱包和硬钱包是比较安全的。</p>
<p>四、如果私钥泄露了怎么办？</p>
<p>比如你发现自己账户上出现一些可疑的交易，这个时候该怎么办?这时应该尽快把自己账上的钱<strong>转到另外一个安全的账户上</strong>，这个也跟我们平时的生活体验不太一样，如果在银行账户上出现一些可疑的交易，我们首先想到的是通知银行，能否把密码重置，账户冻结，免得别人把钱取走，而这些在区块链的世界里都是做不到的。</p>
<p>比特币账户所谓的密码是什么？就是它的私钥。公私钥对生成之后是没有办法改的。可以生成一个新的账户，但是原来账户上的私钥是改不了的。同样，也无法阻止别人发布从这个账户上转账的交易，任何有私钥的人都可以发布一个转账交易，把账户上的钱转走，这个也是没有办法冻结的。所以我们能做的就是在第一时间抢在别人之前把自己账户上的钱转到一个安全的账户上。</p>
<p>五、如果转账的时候写错了地址怎么办？</p>
<p>这是没有办法的。如果写错了地址而转错了人，我们也没有办法取消已经发布了的交易，比特币当中转账交易一旦发布到区块链里，就没有办法取消了。当转错了地址，如果我们知道是转给了谁，可以跟对方进行联系。如果不知道转的是谁的地址，或者是不存在的地址，那就没有办法了。</p>
<p>什么叫不存在的地址？地址是公钥取哈希得到的。有些地址其实不是公钥的哈希得来的，比如第一节课曾讲的digital commitment的例子。你想把某项内容的哈希值发布到区块链上，证明你曾在某个时间知道某个事情。</p>
<p>在前面讲比特币脚本的时候，有个经典的说法，比如把哈希值放到return的后面，因为OP_RETURN后写什么都是没有人管的。但是有人会用哈希值生成一个看上去像是比特币地址的东西。比如A→B，正常情况下B是某个比特币账户公钥取哈希之后得到的地址。在这里把他要保存的那个哈希值生成一个地址，作为收款人的地址。这个地址是没有对应的私钥的，它其实是个假的地址，比特币系统并不知道这个地址的真假，你这个哈希是怎么来的，别人也看不出来。所以这样转账的钱就变成了死钱。这个转账永远不可能被取出来。</p>
<p>这种做法一般牺牲一点比特币，比如转很少一点钱，换取往这个区块链里写入这个哈希值的机会。这个做法是不提倡的，因为这样的话转账交易的输出会永久的保存在UTXO里面。全节点收到这样一个转账交易，它其实并不知道你的地址的真假，它不知道你的钱其实是花不出去的，所以它必须把它永久的保存起来，这样对全节点是不友好的。</p>
<p>接着问一个问题:proof of burn 、OP_RETURN这些实际当中是怎么操作的?</p>
<p>当一个全节点收到一个转账交易的时候，它首先要检查一下，这个交易的合法性，只有合法的交易才会被写入区块链里。而OP_RETURN这个语句是无条件的返回错误，既然如此，它怎么可能通过验证，怎么可能被写到区块链里呢？</p>
<p>验证当前交易合法性的时候，不会执行这个语句。即当前交易的输出脚本在验证交易合法性的时候，是不会被执行的。只有有人想花这笔钱，后面再有一个交易，要花这个交易的输出的时候才会执行这个交易的输出脚本。</p>
<p>六、挖矿时会不会有的矿工偷答案?</p>
<p>不会。发布的区块里有coinbase transaction，里面有一个收款人地址，是挖到矿的矿工的地址。假如A挖到了矿，里面就是A的收款地址。如果要偷答案的话，就要把A的地址换成自己的地址，而地址如果一变化，coinbase transaction的内容就发生了改变。这样会导致什么？导致merkle tree的根哈希值变化，因为这个交易和区块中所包含的其他交易是合在一起构成了merkle tree。任何一个地方发生改变，根哈希值就会变。而nonce是在区块头里面，根哈希值也是在区块头里面，block header的内容发生了变化之后，原来找到的nonce就作废了。所以不可能偷答案，因为每个矿工挖到的nonce是和他自己的收款地址绑定在一起的。</p>
<p>七、怎么判断交易费该给哪个矿工？即事先怎么知道哪个矿工会挖到矿?</p>
<p>事先不需要知道哪个矿工会得到这个交易费。交易费是怎么算的?	total inputs&gt;total outputs，其差额就是交易费。发布的交易里面，一个交易可以有很多个输入，也可以有很多个输出，总输入减总输出就是交易费。给谁不需要事先知道，哪个矿工挖到矿了，就可以把这个区块里所包含的交易差额收集起来，作为他自己的交易费。</p>
<p>下面看一下比特币的一些统计数据:</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Question%201.png"></p>
<p>如图显示的是比特币区块链的大小的变化情况，可以看到区块链是越来越大的。这也不奇怪，区块链只能往里面添东西，所以区块链只会越来越长。目前的size对于硬盘的容量来说，还是完全没有问题的，区块链大部分内容还是可以保存在硬盘上的。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Question%202.png"></p>
<p>如图是UTXO集合的大小变化。该集合总的趋势是不断变大的，有一些波动，主要原因就是比特币交易增多后UTXO的集合会跟着一起变大。当然还有另一些方面是历史原因造成的，有一些账户私钥丢失了，所以这些账户对应的输出在UTXO里就要永久的保存下去，时间长了也会累计增多。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Question%203.png"></p>
<p>如图是比特币矿池挖矿的情况。可以看出，挖矿集中化的趋势也非常严重，几个大的矿池占了系统中很大一部分。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Question%204.png"></p>
<p>如图是比特币的价格变化情况。如图(第25分第30秒)是比特币市值的变化情况，跟价格变化的图几乎是一样的。这里的市值是绝对的市值，不是说在加密货币整体中占的百分比。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Question%205.png"></p>
<p>如图是比特币的交易量。可以看出最后两年交易量增加的很明显，而且波动非常大，这个交易量是按照美元价格算出的，所以这些波动当中有一些是比特币本身的价格波动造成的。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Question%206.png"></p>
<p>如图是每天的交易数目。总的趋势也是在不断增长。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Question%207.png"></p>
<p>如图是每个区块的交易数量，趋势跟前面的图很接近，因为难度调整算法要把出块时间稳定在10分钟，这样的话每天能产生多少个区块就是差不多的。交易数目的变化主要是因为每个区块里所包含的交易数目发生了变化。每个区块最多包含交易的上限差不多是4000个，图中的情况是远远没有达到这个上限。很多人说1M太小了，但真实的区块链上很多区块是没有装满的。</p>
<h3 id="BTC-匿名性"><a href="#BTC-匿名性" class="headerlink" title="BTC-匿名性"></a>BTC-匿名性</h3><p>什么叫匿名？一般来说，匿名是跟隐私保护联系在一起的。比特币中不要求用真名，可以用公钥产生的地址，所以比特币具有一定的匿名性。也就是你可以产生任意多的地址，然后用不同的地址干不同的事情。它用的是化名，但它不是完全没有名字，所以有人把它称为preudonymity。</p>
<p>比特币和银行存款哪个匿名性更好?</p>
<p>银行账户是实名制，你得提交身份信息，然后才能注册银行账户，而比特币不需要，从这点上看比特币匿名性要好。</p>
<p>其实，以前银行是可以用化名的，如果银行账户匿名的话隐私性和匿名性与比特币相比哪个好?</p>
<p>银行账户更好。比特币区块链的账本是公开的，所有人都能查到，每个人都可以上区块链把整个信息下载下来。而银行的账本是受控制的，银行的工作人员可以查到，一些司法手段也可以调取银行的信息，但普通百姓是查不到别人的账的。</p>
<p>比特币系统中什么情况下有可能破坏匿名性?</p>
<p>有的人推荐每次收款都用一个新的地址，这样的话可以有不同的地址，谁也不知道哪些是属于你的，看起来好像匿名性很强，但实际上这些地址是可以被关联在一起的。</p>
<p>比如网上购物，比特币交易允许有多个输入多个输出。而多个输入有可能是同一个人，因为这个人可能同时控制了这两个账户的私钥。为什么要有两个输入:因为你买的东西很可能不是你某个账户上全部的币。有多个输出，很可能有一个是找零钱的地址。这种交易一般都是比特币钱包软件生成的。很多交易软件每次交易的时候都会生成一个新的找零的地址，也是为了隐私保护。</p>
<p>有没有可能把输入地址和输出地址也关联起来呢？比特币生成交易的时候并没有规定找零钱的地址在outputs中出现的位置，所以想知道哪个是找零的地址也并不容易，但有些情况下可以分析出来。</p>
<p>比如第一个地址账户上有4个比特币，第二个有5个。产生的两个输出第一个输出转入6个比特币，第二个输出转入3个比特币。那很明显转入3个比特币的输出是找零的，因为如果它是商家的地址，就用不着两个inputs，任意一个输入都比3大。通过这种方法我们可以把输入地址和输出地址也关联起来。</p>
<p>如果想要更好的隐私保护，可以产生一些没必要的输出，为了迷惑别人。但是这些交易几乎都是用钱包软件生成的，现在很少有人手工生成这些比特币的转账交易，常用的比特币钱包就那么几种。所以把常用的比特币钱包生成交易的方式搞清楚，那么区块链上很大一部分转账交易都可以分析出来。常用的钱包到目前为止一般没有故意生成一些不必要的输出地址。</p>
<p>有可能破坏比特币匿名性的第一个方面:一个人可以生成很多个地址账户但这些地址账户是有可能被关联起来的。第二个方面:是这个地址账户跟现实世界中的身份也可能产生关联。什么时候会有关联？什么情况下别人有可能知道比特币账户对应的现实生活中的哪个人呢？</p>
<p>比特币系统一旦跟现实世界联系起来，就可能泄露你的真实身份，最明显的例子就是资金的转入和转出。怎么避免用比特币洗钱呢？盯住比特币的转入转出链是一个常用的手段。大数目的比特币和货币的交易想不引起司法部门的注意是很难的，转入转出也是比特币隐私容易被破坏的一个很重要的时机。</p>
<p>还有什么时候会泄露真实身份？用比特币做支付的时候。在实体世界中用比特币做支付，比如国外有的商家是接受比特币支付。但有一些麻烦之处:①延迟很长，等到交易确认要等六个区块生成，即一个小时。②交易费很贵。如果买咖啡，交易费可能都跟咖啡差不多贵了。这样的话，你支付的账户就跟你的真实身份建立联系了。这个账户可能跟个人的其他账户也是有联系的，所以这样很容易泄露个人隐私和身份。而且该交易不仅是该商家会知道，其他人也会知道。</p>
<p>比如:A想知道B的地址。A可以在B去买商品时，留意B支付的时间，然后去查找在这个时间点的交易。在B下一次购买商品时也留意支付时间，这样下去用不了几次就能知道哪个哈希值是B的。</p>
<p>这个例子告诉我们什么？信用卡记录不能公开，即使匿名，也不应将公钥取哈希后公开。但比特币系统是无法保密的，所以比特币的匿名性并不是绝对的，没有想象中那么好。</p>
<p>实际中用比特币的人匿名性保存的怎么样？中本聪发明比特币以来，没有进行过任何一笔交易，所以到现在也没人知道他的真实身份。曾经有一个叫丝路(silk road)的网站(eBay for illegal drugs)，有像eBay一样的网上交易平台，但卖的都是非法的违禁品。为了逃避司法制裁，其支付手段就是比特币，底下的网络层用的是洋葱路由(TOR)，在美国也有匿名邮寄的服务。最后运行了两三年，就被查封了。美国政府抓到其老板时没收了其十几万个比特币，在当时价值几千万美元。但他生活简朴，因为虽然有价值连城的比特币，但一旦消费就会暴露身份。</p>
<p>该网站被查封之后，有人又开了silk road2。也是运行没几年就被查封。还有一些类似的网上黑店，最后下场都不好。这些事件都说明了，比特币的匿名性没有我们想象中的那么好，尤其是想用它来做坏事。</p>
<p>所以回到前面的问题:比特币的匿名性有多好?	匿名是跟隐私保护相关联的，但问题在于:你不想向谁暴露身份(hide your identity from whom)？如果你不想让身边的亲戚朋友知道，这是比较容易实现的。如果是非法组织，从事黑市活动，那保护起来就难多了。</p>
<p>一个比特币用户能采用什么样的方法尽量提高个人的匿名性?	以前曾讲过，比特币系统是运行于应用层(application layer)的，底层是网络层(network layer)。所以要提高匿名性可以从两个方面入手。</p>
<p>①网络层怎么提高匿名性?</p>
<p>在现实中，如果一个人去网吧发了帖子，别人是有办法知道他是谁的。因为他的身份证代表了他的身份，这和他的IP地址是有很大关联性的。</p>
<p>而网络层的匿名性是比较好解决的。区块链是个新生事物，但网络层的匿名性学术界已经有了很好的方案:多路径转发。跟洋葱路由(TOR)是一样的原理。即消息不是由发出者直接发送给接收者，中间要经过很多次转发。中间的每一个节点，只知道它的上一个节点是谁，但并不知道最早发出消息的人是谁。当然中间一些节点可能是坏的，但路径上只要有一个节点是诚实的，就能够把最初发起人的身份隐藏起来。这也是洋葱路由的基本原理。</p>
<p>②应用层怎么提高匿名性?</p>
<p>把不同人的币混在一起(coin mixing)，即把你的身份跟别人的身份混在一起，让别人分不清楚谁是谁。不光是区块链，在其他各个需要匿名的领域都能用到。有一些专门做coin mixing的网站，提供一定的服务收取一定的服务费。所有想做coin mixing的人把币发给网站，网站内部进行一些重组，然后你再把币取回来，这时取出的币就不是你当初发布到网站上的币了，它是随机抽取一些币给你。</p>
<p>coin mixing真正实施起来有一定的复杂性，如果设计不好的话，别人可以根据你当初存进去币的数额，推断出来哪些币是你存进去的。</p>
<p>而且，在当今的区块链的世界里，没有什么信誉度非常高的coin mixing的服务。很多coin mixing的服务它本身也是要保持匿名的，它匿名的后果是:有可能投进去的币被他卷款跑路了，投币者是一点办法都没有的。</p>
<p>实际上并不一定非要做coin mixing，有一些应用本身也带有coin mixing的性质，比如在线钱包。很多人会把钱存入在线钱包里，在线钱包就会把这些人的币混起来，再取回自己的币时可能就不是当初存进去的币了。但在线钱包并不保证要履行coin mixing的功能。</p>
<p>还可以通过加密货币的交易所，交易所一般有天然的coin mixing的性质。前提是交易所不会泄露提币、存币的记录，否则也是不行的。</p>
<p>为什么保护隐私性难度挺大？本质原因是区块链是公开的，而且是不可篡改的。不可篡改性对于隐私保护来说是灾难性的。</p>
<p>零知识证明:</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Anonymity%201.png"></p>
<p>概念如图所示:零知识证明是指一方(证明者)向另一方(验证者)证明一个陈述是正确的，而无需透露除该陈述是正确的外的任何信息。</p>
<p>例如:要证明一个账户是我的，只需要我给出私钥就行。但私钥不能直接泄露，所以就给出由私钥产生的签名，假设对方是知道这个账户的公钥的，那么就可以验证签名的正确性。这是不是一个零知识证明其实是有争议的，因为我给出了私钥之外的其他信息，具体算不算要看应用场合。</p>
<p>同态隐藏:</p>
<p>零知识证明的数学基础是同态隐藏。</p>
<p>如图是同态隐藏的性质。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Anonymity%202.png"></p>
<p>第一个性质说明加密函数值E不会出现碰撞，这跟哈希函数有所不同，哈希函数是可能出现碰撞的。这个性质反过来说明如果E(x)和E(y)是相等的，那么x、y也是相等的。(该语句是上面语句的逆否命题)</p>
<p>第二个性质说明加密函数是不可逆的，知道加密后的值，没办法推出加密前的值。</p>
<p>第三个性质是最重要的，叫作同态运算。它说的是对加密之后的函数值进行某些代数运算，等价于对这些输入直接进行代数运算然后再加密。</p>
<p>同态加法:加密值的和等于和的加密。</p>
<p>同态乘法:加密值的乘积等于积的加密。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Anonymity%203.png"></p>
<p>举一个例子:如图所示Alice想要向Bob证明她知道一组数x和y使得x+y&#x3D;7，同时不让Bob知道x和y的具体数值。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Anonymity%204.png"></p>
<p>简单的解答版本如图</p>
<p>·Alice把E(x)和E(y)的数值发给Bob</p>
<p>·Bob通过收到的E(x)和E(y)计算出E(x+y)的值(利用了性质3)</p>
<p>·Bob同时计算E(7)的值，如果E(x+y）&#x3D;E(7)，那么验证通过，否则验证失败。</p>
<p>Bob可以用蛮力算法，一个一个试而计算出x和y的值，因此Alice要对x和y的值做一些随机化处理，保证x和y加起来还是不变的。</p>
<p>不考虑去中心化的前提下，前面在讲double spending时讲过，要对每一个数字货币进行编号就能防止double spending。回到这节课讲的隐私保护问题，央行是什么都知道的，那么有没有什么办法让央行做中心化的记账检测double spending，又不让它知道呢?	即虚拟货币的编号不能是央行产生的，改成自己产生的，又不会被篡改掉。</p>
<p>这里就要用到盲签方法。如图</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Anonymity%205.png"></p>
<p>·用户A提供SerialNum，银行在不知道SerialNum的情况下返回签名Token，减少A的存款</p>
<p>·用户A把SerialNum和Token交给B完成交易</p>
<p>·用户B拿SerialNum和Token给银行验证银行验证通过，增加B的存款</p>
<p>·银行无法把A和B联系起来</p>
<p>·中心化</p>
<p>解读如下:</p>
<p>·用户A提供序号，银行进行签名但此时看不到序号的内容，A要取钱所以银行要减少A的存款。</p>
<p>·A给B转账交易的时候把序号和签名给B，这个时候序号是明文，B是可以看到序号的具体内容的。</p>
<p>·B把序号和签名给银行验证，这个时候序号也是明文，这一步验证的目的是检测double spending。</p>
<p>这样设计的好处是:银行不知道B的币是从哪来的。</p>
<p>零币和零钞(它们也是加密货币，跟比特币是一类属性):</p>
<p>比特币在很大程度上提供了匿名性，但它不能完全消除关联性，那么我们能不能设计一种新的加密货币，这个货币从一开始的结构设计上就用了密码学的原理保证了匿名性，所以就有了零币和零钞。</p>
<p> <img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Anonymity%206.png"></p>
<p>如图零币和零钞</p>
<p>·零币和零钞在协议层就融合了匿名化处理，其匿名属性来自密码学保证。</p>
<p>·零币(zerocoin )系统中存在基础币和零币，通过基础币和零币的来回转换，消除旧地址和新地址的关联性，其原理类似于混币服务。</p>
<p>·零钞(zerocash)系统使用zk-SNARKs协议，不依赖一种基础币，区块链中只记录交易的存在性和矿工用来验证系统正常运行所需要关键属性的证明。区块链上既不显示交易地址也不显示交易金额，所有交易通过零知识验证的方式进行。</p>
<p>这是专门为匿名性设计的加密货币。</p>
<p>零币中存在基础币(比如比特币)和零币。用的时候要证明本来是有一个基础币，让基础币变得不能花费(unspendable)，然后换取一个零币，零币在花的时候只需要用零知识证明你花掉的币是系统中存在的某一个合法的币就行了，但是不用透露你花的是系统中具体的哪一个币。这是跟比特币的一个本质区别，比特币是每一笔转账交易都要说明币的来源。这样才能证明花的币的真实性不是凭空捏造出来的。</p>
<p>但零币和零钞不是这样，零币和零钞是说证明的时候可以从数据上保证你花的币是以前区块链上某个合法存在的币，但不知道具体是哪个。这样的话就把关联性破坏掉了，就没法追溯了。</p>
<p>零钞没有基础币，是完全的零币。零钞和零币也不是100%匿名安全的，在影响匿名安全的因素中依然有一个因素无法解决，就是与实体发生交互的时候。比如有人想拿这些币干坏事，把很大的金额转换成这种加密货币的时候，或者是把这些加密货币转换成现金的时候，仍然要暴露身份。这些加密货币数学上设计的再好，只是说对已经在区块链当中的转账有匿名性，跟外界交互的匿名性仍然是一个弱点。所以它依然无法提供100%的匿名。</p>
<h3 id="BTC-思考"><a href="#BTC-思考" class="headerlink" title="BTC-思考"></a>BTC-思考</h3><p>哈希指针:</p>
<p>指针保存的是本地内存的地址，那么只是在本地这台计算机上才有意义，发送到其他计算机上就没有意义了。那么在发布区块的时候哈希指针是怎么能够通过网络进行传输呢？</p>
<p>所谓的哈希指针只是一种形象的说法，实际系统中用的时候只有哈希，没有指针。回顾一下之前看到的block header的数据结构，如图</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Think%201.png"></p>
<p>第2行就是指向前一个区块的哈希，没有指针。block header里只有哈希值，没有指针。</p>
<p>那么怎么才能找到前一个区块的内容呢？全节点一般是把这些区块存储在一个(key，value)数据库里面。key是区块的哈希，value就是区块的内容。一个常用的key value数据库是level DB。所谓的区块链这种链表结构实际上是在level DB里面用哈希值算出来的。只要你掌握了最后一个区块的哈希值，那么你通过level DB的查找，哈希值key对应的value就可以把最后一个区块的内容取出来。然后这个区块块头里面，又有指向前一个区块的哈希值。那么再去查找key和value，可以找到前一个区块的内容，以此类推，一步一步往前找，最终能够把整个区块链都找出来。</p>
<p>所以说在实际系统当中，所谓的哈希指针，只有哈希，没有指针，或者也可以认为哈希值的本身就是指针。</p>
<p>有一些节点没有保存完整的区块链的信息，只保存了最近的几千个区块，如果需要用到前面的区块的信息可以问其他的全节点要。哈希指针的性质保证了整个区块链的内容是不可篡改的。</p>
<p>区块恋:</p>
<p>就是指，把一个私钥分成几份，有几个人各自保管，只有最终大家都拿出自己的部分私钥，才能合成完整的私钥。</p>
<p>这样存在的问题是:这些人中任何一个人把私钥丢了钱就取不出来了。还有更大一个问题:这种截断私钥的做法会降低账户的安全性。因为比特币系统中每个账户的安全性跟所用的私钥的长度是相关的。</p>
<p>为什么要用256位的私钥?	因为这个长度的私钥用暴力破解的方法是不可行的。就算把全世界的计算机集中起来破解256位的私钥，也是不可能成功的。但是如果从中截断，一对情侣中一个人分手之后想把钱取出来，他已经知道了其中一半的私钥，只要把剩下的128位私钥猜出来就行了。私钥长度减少一半并不意味着难度降低一半，难度由2的256次方降到了2的128次方，前者远远大于后者，破解难度降了很多。如果是四个合伙人的例子，有三个人瞒着另一个人要把钱取出来，那么他们只需要尝试2的64次方就可以了。</p>
<p>因此对于多个人的共享账户，不要用截断私钥的方法，而最好采用多重签名，多重签名中用到的每一个私钥都是独立产生的。而且多重签名也提供一些别的灵活性，比如可以要求N个人当中任意给出M个签名就可以了。</p>
<p>在区块恋例子中，如果一对情侣分手了，那么他们的比特币将永久的保存在UTXO里面，这对矿工是不友好的。矿工是不知道这笔钱永远取不出来的，所以矿工要把这笔钱永久的保存在UTXO里面，造成这个集合的膨胀。</p>
<p>分布式共识:</p>
<p>前面已经讲过，从理论上实现分布式系统的共识是不可能的，但实际当中又怎么变的可能了呢?为什么比特币系统能够绕过分布式共识中的那些不可能结论?	严格来说，比特币并没有取得真正意义上的共识，因为取得的共识随时有可能被推翻，比如出现了分叉攻击。你以为已经取得了一个共识，分叉攻击后系统会回滚到前一个状态，从理论上说甚至有可能回滚到创世纪块。</p>
<p>按照分布式系统理论的要求，共识一旦达成之后，就不应该再改了，所以从这方面来说比特币并没有绕过分布式系统那些不可能的结论，因为它并没有达到真正意义上的共识。这说明理论和实际往往是有区别的。很多理论上的不可能结论对于实际当中是并不适用的，因为这种不可能结论只是对某种特定的模型下是不可能的，实际当中把模型稍微改一改不可能结论就不成立了。</p>
<p>比特币的稀缺性:</p>
<p>矿工挖矿的原因是为了获得收益，挖矿的收益要大于开销才是有利可图的。要吸引别人来挖矿，要么增加挖矿的收益，要么降低挖矿开销。任何一个新发行的加密货币，都有一个能启动的问题。早期为了吸引矿工来挖矿，可以给矿工更多的收益。比特币的做法是:①早期难度设置的比较低。②早期的出块奖励比较高。</p>
<p>实际上，比特币这种总量恒定的性质是不适合用来做货币的。后面讲的以太坊就没有出块奖励定期减半的做法，一些新型的货币甚至要自带通胀的功能，每年要把货币的通行量提高一定的比例。因为稀缺的东西是不适合用来做货币的，通货膨胀会导致钱变得更不值钱了，但一个好的货币是要有通货膨胀的功能的。</p>
<p>量子计算:</p>
<p>随着量子计算的发展，量子计算机计算力变得越来越强大，加密货币会不会变得不安全了?</p>
<p>这种担心是没必要的:</p>
<p>①量子计算技术离实用还有很长一段距离，在比特币的有生之年不一定能产生实质性的联系。如果量子计算在将来能强大到破坏加密体系的话，首先会冲击的是传统金融业。比如我们在网上进行的很多金融活动:网上银行、网上转账、网上支付，都会变得不安全了。所以与其担心量子计算对比特币的冲击，还不如担心量子计算对传统金融业的冲击，因为大多数的钱还是放在传统金融业里面的，加密货币的市值只占了现代金融体系当中的很小一部分。</p>
<p>②比特币当中没有把账户的公钥直接暴露出来，而是用公钥取哈希之后得到一个地址。比特币当中用的非对称加密体系，从私钥是可以推导出公钥的。所以只要把私钥保管好，公钥其实丢了也没有关系。从公钥显然是不能推出私钥的，否则就麻烦了。</p>
<p>假设将来量子计算技术发达了，能够从公钥中推出私钥，那怎么办呢？比特币在设计的时候又加了一层保护，没有用公钥本身，而是用公钥的哈希。所以如果有人想偷你账户上的钱的话，首先是要用地址推导出你的公钥，相当于把公钥的哈希值进行逆运算，而这一点即使是用量子计算机也是没有办法完成的。</p>
<p>加密和取哈希是两个不同性质的操作，加密的目的是为了将来能够解密，所以加密算法要保证信息的完整性，加密过程是不能丢失信息的，这样解密的时候才能够还原原来的输入。但是取哈希的过程一般是会造成信息的损失的，哈希函数一般都是不可逆的，因为有些信息在取哈希的过程中就已经丢失了。</p>
<p>比特币系统中用的哈希算法是SHA-256，算出的哈希值是256位，无论输入有多大，即使有几个T，算出来的哈希值也是256位。这样的运算过程显然是不可逆的。如果可逆那可就变成了一个超级压缩算法。</p>
<p>所以在比特币系统中，如果要收款就没必要把公钥暴露出来，只暴露公钥的哈希生成的地址就行了。将来要取钱的时候才需要公钥和私钥产生的签名。假如一个坏人在网上监听到了你取钱的交易，知道了你的公钥，他要偷你的钱，就必须实时的从公钥推导出私钥来，然后要产生一个跟你竞争的交易。你要把钱转你账户，他要把你钱转给他账户，即使这个坏人拥有量子计算机也很难几分钟内把你的私钥破解了，而且他发布的交易要抢在你交易的前面。</p>
<p>所以安全起见，一个地址用过之后就不要再用了，每次取钱最好把钱一次取走，即使取不完，也最好把钱转给另一个安全的账户。后面会讲到，以太坊中的地址也是从公钥当中推导出来的，但也不是公钥本身，也是公钥取哈希之后进行的转换。</p>
<h2 id="ETH部分"><a href="#ETH部分" class="headerlink" title="ETH部分"></a>ETH部分</h2><h3 id="ETH-概述"><a href="#ETH-概述" class="headerlink" title="ETH-概述"></a>ETH-概述</h3><p>BTC和ETH为最主要的两种加密货币，BTC称为区块链1.0，以太坊称为区块链2.0。之前文章中提出了比特币设计中存在某些不足，以太坊便对其进行了改进。例如：出块时间、共识协议、mining puzzle（对内存要求高，反ASIC芯片使用）<br>未来，以太坊还将会用权益证明(POS)替代工作量证明(POW)<br>此外，以太坊增加了对<strong>智能合约（smart contract）</strong>的支持。</p>
<p>为什么要开发“智能合约”?<br>BTC本身是一个去中心化的货币，在比特币取得成功之后，很多人就开始思考：除了货币可以去中心化，还有什么可以去中心化？以太坊的一个特性就是增加了对去中心化的合约的支持。<br>如果说比特币系统本身是一个货币应用，以太坊则由于智能合约，升级成为了一个平台，用户可以依据该平台自行开发业务应用。</p>
<p>关于BTC和ETH<br>BTC的发明人为中本聪(疑似日本人)，ETH为Vitalik Buterin收到BTC启发发明出来的““下一代加密货币与去中心化应用平台””。BTC中货币最小单位为“聪”，最少的钱为一聪；ETH中货币最小单位为“Wei”，最少的钱为一Wei。</p>
<p>去中心化的合约<br>首先，讨论去中心化货币。货币本身由政府发行，政府公信力为其背书，BTC通过技术手段取代了政府的职能。<br>现实生活中，我们经常提到“契约”或“合约”。合约的有效性也是需要政府进行维护的，如果产生 纠纷需要针对合法性合同进行判决。ETH的设计目的就是，通过技术手段来实现取代政府对于合约的职能。<br>那么，去中心化的合约有什么好处？<br>若合同签署方并非一个国家，没有统一的司法部门（如：众筹）。如果可以编写无法修改的合约，所有人只能按照相关参与方执行，无法违约。</p>
<h3 id="ETH-账户"><a href="#ETH-账户" class="headerlink" title="ETH-账户"></a>ETH-账户</h3><p>BTC系统是基于交易的账本，系统中并未显示记录账户有多少钱，只能通过UTXO进行推算。但实际中，使用起来较为别扭。<br>A转给B钱的时候，需要说明币的来源。实际中只需要存钱说明来源，花钱则不用。此外，账户中的钱在花的时候，必须一次性全部花出去。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Account%201.png"></p>
<p>如图1，B收到A的10个BTC，他想要给C3个BTC，如果按照1中方式，其余7个比特币会以交易费的形式给挖出区块的矿工。<br>因此，为了避免这种情况，便吸引采用2中方式，将3个BTC转给C，将剩余7个BTC转到自己的另一账户D上面。</p>
<p>以太坊系统则采用了基于账户的模型，与现实中银行账户相似。系统中显示记录每个账户以太币的数量，转账是否合法只需要查看转账者账户中以太币是否足够即可，同时也不需要每次全部转账。同时，这也也天然地防范了双花攻击。<br>当然，以太坊发这种模式也存在缺点，这种模式存在重放攻击的缺陷。A向B转账，过一段时间，B将A的交易重新发布，从而导致A账户被扣钱两次。</p>
<p>为了防范重放攻击，给账户交易添加计数器记录该账户交易过多少次，转账时候将转账次数计入交易的内容中。<br>系统中全节点维护账户余额和该计数器的交易数，从而防止本地篡改余额或进行重放攻击。</p>
<p>以太坊系统中存在两类账户：外部账户和合约账户。</p>
<p>外部账户：类似于BTC系统中公私钥对。存在账户余额balance和计数器nonce<br>合约账户：并非通过公私钥对控制。(不能主动发起交易，只能接收到外部账户调用后才能发起交易或调用其他合约账户)其除了balance和nonce之外还有code(代码)、storage(相关状态-存储)<br>创建合约时候会返回一个地址，就可以对其调用。调用过程中，代码不变但状态会发生改变。</p>
<p>为什么要做以太坊，更换为基于账户的模型而不是沿袭BTC系统？<br>比特币中支持每次更换账户，但以太坊是为了支持智能合约，而合约签订双方是需要明确且较少变化的。尤其是对于合约账户来说，需要保持稳定状态。</p>
<h3 id="ETH-状态树"><a href="#ETH-状态树" class="headerlink" title="ETH-状态树"></a>ETH-状态树</h3><p>首先，我们要实现从账户地址到账户状态的映射。在以太坊中，账户地址为160字节，表示为40个16进制数额。状态包含了余额(balance)、交易次数(nonce),合约账户中还包含了code(代码)、存储(stroge)。</p>
<p>直观地来看，其本质上为Key-value键值对，所以直观想法便用哈希表实现。若不考虑哈希碰撞，查询直接为常数级别的查询效率。<br>但采用哈希表，难以提供Merkle proof(BTC数据结构篇中有对Merkle proof的介绍，还记得是什么吗？)。<br>需要记住的是，在BTC和以太坊中，交易保存在区块内部，一个区块可以包含多个交易。通过区块构成区块链，而非交易。</p>
<p>思考如何组织账户的数据结构<br>1.我们能否像BTC中，将哈希表的内容组织为Merkle Tree？<br>但当新区块发布，哈希表内容会改变，再次将其组织为新的Merkle Tree?如果这样，每当产生新区块(ETH中新区块产生时间为10s左右)，都要重新组织Merkle Tree，很明显这是不现实的。<br>需要注意的是，比特币系统中没有账户概念，交易由区块管理，而区块包含上限为4000个交易左右，所以Merkle Tree不是无限增大的。而ETH中，Merkle Tree来组织账户信息，很明显其会越来越庞大。<br>实际中，发生变化的仅仅为很少一部分数据，而我们每次重新构建Merkle Tree代价很大。<br>2.那我们不要哈希表了，直接使用Merkle Tree，每次修改只需要修改其中一部分即可，这个可以吗？<br>实际中，Merkle Tree并未提供一个高效的查找和更新的方案。此外，将所有账户构建为一个大的Merkle Tree，为了保证所有节点的一致性和查找速度，必须进行排序。<br>3.那么经过排序，使用Sorted Merkle Tree可以吗？<br>新增账户，由于其地址随机，插入Merkle Tree时候很大可能在Tree中间，发现其必须进行重构。所以Sorted Merkle Tree插入、删除(实际上可以不删除)的代价太大。<br>既然哈希表和 Merkle Tree都不可以，那么我们看一下实际中以太坊采取的数据结构：MPT。</p>
<p>注意：BTC系统中，虽然每个节点构建的Merkle Tree不一致（不排序），但最终是获得记账权的节点的Merkle Tree才是有效的。</p>
<p>一个简单的数据结构——trie(字典树、前缀树)<br>如下为一个通过5个单词组成的trie数据结构（只画出key，未画出value）</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/State%20trie%201.png"></p>
<p>特点：</p>
<p>1.trie中每个节点的分支数目取决于Key值中每个元素的取值范围(图例中最多26个英文字母分叉+一个结束标志位)。<br>2.trie查找效率取决于key的长度。实际应用中（以太坊地址长度为160byte）。<br>3.理论上哈希会出现碰撞，而trie上面不会发生碰撞。<br>4.给定输入，无论如何顺序插入，构造的trie都是一样的。<br>5.更新操作局部性较好  那么trie有缺点吗？当然有：<br>trie的存储浪费。很多节点只存储一个key，但其“儿子”只有一个，过于浪费。因此，为了解决这一问题，我们引入Patricia tree&#x2F;trie<br>Patricia trie(Patricia tree)<br>Patricia trie就是进行了路径压缩的trie。如上图例子，进行路径压缩后如下图所示：</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/State%20trie%202.png"></p>
<p>需要注意的是，如果新插入单词，原本压缩的路径可能需要扩展开来。那么，需要考虑什么情况下路径压缩效果较好？树中插入的键值分布较为稀疏的情况下，可见路径压缩效果较好。<br>在以太坊系统中，160位的地址存在2的160次方种，该数实际上已经非常大了，和账户数目相比，可以认为地址这一键值非常稀疏。<br>因此，我们可以在以太坊账户管理种使用Patricia tree这一数据结构！但实际上，在以太坊种使用的并非简单的PT(Patricia tree),而是MPT(Merkle Patricia tree)。</p>
<p>Merkle Tree 和 Binary Tree：<br>区块链和链表的区别在于区块链使用哈希指针，链表使用普通指针。<br>同样，Merkle Tree 相比 Binary Tree，也是普通指针换成了哈希指针。</p>
<p>所以，以太坊系统中可如此，将所有账户组织为一个经过路径压缩和排序的Merkle Tree，其根哈希值存储于block header中。</p>
<p>BTC系统中只有一个交易组成的Merkle Tree，而以太坊中有三个(三棵树)。也就是说，在以太坊的block header中，存在有三个根哈希值。</p>
<p>根哈希值的用处：</p>
<p>1.防止篡改。<br>2.提供Merkle proof，可以证明账户余额，轻节点可以进行验证。<br>3.证明某个发生了交易的账户是否存在</p>
<p>MPT(Modified Patricia tree)<br>以太坊中针对MPT(Merkle Patricia tree)进行了修改，我们称其为MPT(Modified Patricia tree)</p>
<p>下图为以太坊中使用的MPT结构示意图。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/State%20trie%203.png"></p>
<p>右上角表示四个账户(为直观，显示较少)和其状态(只显示账户余额)。（需要注意这里的指针都是哈希指针）</p>
<p>每次发布新区块，状态树中部分节点状态会改变。但改变并非在原地修改，而是新建一些分支，保留原本状态。如下图中，仅仅有新发生改变的节点才需要修改，其他未修改节点直接指向前一个区块中的对应节点。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/State%20trie%204.png"></p>
<p>所以，系统中全节点并非维护一棵MPT，而是每次发布新区块都要新建MPT。只不过大部分节点共享。</p>
<p>为什么要保存原本状态？为何不直接修改？<br>为了便于回滚。如下1中产生分叉，而后上面节点胜出，变为2中状态。那么，下面节点中状态的修改便需要进行回滚。因此，需要维护这些历史记录。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/State%20trie%205.png"></p>
<p>通过代码看以太坊中的数据结构</p>
<p>1.block header 中的数据结构</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/State%20trie%206.png"></p>
<p>2.区块结构</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/State%20trie%207.png"></p>
<p>3.区块在网上真正发布时的信息</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/State%20trie%208.png"></p>
<h3 id="ETH-交易树和收据树"><a href="#ETH-交易树和收据树" class="headerlink" title="ETH-交易树和收据树"></a>ETH-交易树和收据树</h3><p>每次发布一个区块时，区块中的交易会形成一颗Merkle Tree，即交易树。此外，以太坊还添加了一个收据树，每个交易执行完之后形成一个收据，记录交易相关信息。也就是说，交易树和收据树上的节点是一一对应的。由于以太坊智能合约执行较为复杂，通过增加收据树，便于快速查询执行结果。交易树和收据树都是M(Merkle)PT，而BTC中都采用普通的MT(Merkle Tree)。（可能就仅仅是为了三棵树代码复用好所以这样设计的）MPT的好处是支持查找操作，通过键值沿着树进行查找即可。对于状态树，查找键值为账户地址；对于交易树和收据树，查找键值为交易在发布的区块中的序号。</p>
<p>交易树和收据树只将当前区块中的交易组织起来，而状态树将所有账户的状态都包含进去，无论这些账户是否与当前区块中交易有关系。<br>多个区块状态树共享节点，而交易树和收据树依照区块独立。</p>
<p>交易树和收据树的用途：</p>
<p>1.向轻节点提供Merkle Proof。<br>2.更加复杂的查找操作(例如：查找过去十天的交易；过去十天的众筹事件等)</p>
<p>Bloom filter(布隆过滤器)<br>支持较为高效查找某个元素是否在某个集合中<br>最笨：元素遍历，复杂度为O(n)——轻节点不能用<br>方法：给一个大的集合，计算出一个紧凑的“摘要”，</p>
<p>例：如下图，给定一个数据集，其中含义元素a、b、c，通过一个哈希函数H()对其进行计算，将其映射到一个其初始全为0的128位的向量的某个位置，将该位置置为1。将所有元素处理完，就可以得到一个向量，则称该向量为原集合的“摘要”。可见该“摘要”比原集合是要小很多的。<br>假定想要查询一个元素d是否在集合中，假设H(d)映射到向量中的位置处为0，说明d一定不在集合中；假设H(d)映射到向量中的位置处为1，有可能集合中确实有d(与原先为1的元素的值相等)，也有可能是因为哈希碰撞(与原先为1的元素的值不相等)产生误报。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Tx%20trie%201.png"></p>
<p>Bloom filter特点：有可能出现误报，但不会出现漏报。<br>Bloom filter变种：采用一组哈希函数进行向量映射，有效避免哈希碰撞</p>
<p>如果集合中删除元素该怎么操作？<br>无法操作。也就是说，简单的Bloom filter不支持删除操作。如果想要支持删除操作，需要将记录数不能只为0和1，需要修改为一个计数器(但需要考虑计数器是否会溢出)。</p>
<p>以太坊中Bloom filter的作用<br>每个交易完成后会产生一个收据，收据包含一个Bloom filter记录交易类型、地址等信息。在区块block header中也包含一个Bloom filter，其为该区块中所有交易的Bloom filter的一个并集。<br>所以，查找时候先查找区块头中的Bloom filter，如果区块头中包含。再查看区块中包含的交易的Bloom filter，如果存在，再查看交易进行确认；如果不存在，则说明发生了“碰撞”。<br>好处是通过Bloom filter这样一个结构，快速大量过滤掉大量无关区块，从而提高了查找效率。</p>
<p>补充<br>以太坊的运行过程，可以视为交易驱动的状态机，通过执行当前区块中包含的交易，驱动系统从当前状态转移到下一状态。当然，BTC我们也可以视为交易驱动的状态机，其状态为UTXO。<br>对于给定的当前状态和给定一组交易，可以确定性的转移到下一状态(保证系统一致性)。</p>
<p>问题1：A转账到B，有没有可能收款账户不包含在状态树中？<br>可能。因为以太坊中账户可以节点自己产生，只有在<em><strong>第一次</strong></em>产生交易时才会被系统知道。<br>问题2：可否将每个区块中状态树更改为只包含和区块中交易相关的账户状态？(大幅削减状态树大小，且和交易树、收据树保持一致)<br>不能。首先，这样设计要查找账户状态很不方便，因为不存在某个区块包含所有状态。其次，如果要向一个新创建账户转账，因为需要知道收款账户的状态，才能给其添加金额，但由于其是新创建的账户，所以需要一直找到创世纪块才能知道该账户为新建账户，系统中并未存储，而区块链是不断延长的。</p>
<p>代码中具体数据结构<br>交易树和收据树的创建过程<br>根据此大致demo可以看到其创建流程。在肖老师视频中，还有针对bloom filter等具体结构的分析，这里不赘述，感兴趣可以直接观看肖老师视频。代码分析从该视频29：00开始</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Tx%20trie%202.png"></p>
<h3 id="ETH-GHOST"><a href="#ETH-GHOST" class="headerlink" title="ETH-GHOST"></a>ETH-GHOST</h3><p>BTC系统中出块时间为10min，而以太坊中出块时间被降低到15s左右，虽然有效提高了系统反应时间和吞吐率，却也导致系统临时性分叉变成常态，且分叉数目更多。这对于共识协议来说，就存在很大挑战。在BTC系统中，不在最长合法链上的节点最后都是作废的，但如果在以太坊系统中，如果这样处理，由于系统中经常性会出现分叉，则矿工挖到矿很大可能会被废弃，这会大大降低矿工挖矿积极性。而对于个人矿工来说，和大型矿池相比更是存在天然劣势。<br>对此，以太坊设计了新的公式协议——GHOST协议(该协议并非原创，而是对原本就有的Ghost协议进行了改进)。</p>
<p><strong>GHOST协议</strong><br><strong>GHOST协议最初版本</strong><br>如图，假定以太坊系统存在以下情况，A、B、C、D在四个分支上，最后，随着时间推移B所在链成为最长合法链，因此A、C、D区块都作废，但为了补偿这些区块所属矿工所作的工作，给这些区块一些“补偿”，并称其为”Uncle Block”（叔父区块）。<br>规定E区块在发布时可以将A、C、D叔父区块包含进来，A、C、D叔父区块可以得到出块奖励的7&#x2F;8，而为了激励E包含叔父区块，规定E每包含一个叔父区块可以额外得到1&#x2F;32的出块奖励。为了防止E大量包含叔父区块，规定一个区块只能最多包含两个叔父区块，因此E在A、C、D中最多只能包含两个区块作为自己的出块奖励</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/GHOST%201.png"></p>
<p>假定一个矿工挖出了B，此时他沿着其所在链继续挖，而他知道A是和自己“同辈”，则可以将A包含进区块挖矿，若挖矿过程中又听到C也是“同辈”，则可以先停止挖矿，将C包含进来重新组织成一个新区块再重新挖矿，实际中，由于挖矿过程的无记忆性，这样并不会降低成功挖到矿的概率。</p>
<p>最初版本缺陷：</p>
<p>1.因为叔父区块最多只能包含两个，如图出现3个怎么办？<br>2.矿工自私，故意不包含叔父区块，导致叔父区块7&#x2F;8出块奖励没了，而自己仅仅损失1&#x2F;32。如果甲、乙两个大型矿池存在竞争关系，那么他们可以采用故意不包含对方的叔父区块，因为这样对自己损失小而对对方损失大。</p>
<p><strong>Ghost协议新的版本</strong><br>如下图中1为对上面例子的补充，F为E后面一个新的区块。因为规定E最多只能包含两个叔父区块，所以假定E包含了C和D。此时，F也可以将A认为自己的的叔父区块(实际上并非叔父辈的，而是爷爷辈的)。如果继续往下挖，F后的新区块仍然可以包含B同辈的区块(假定E、F未包含完)。这样，就有效地解决了上面提到的最初Ghost协议版本存在的缺陷。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/GHOST%202.png"></p>
<p>但这样仍然存在一定的问题。</p>
<p>我们将“叔父”这个概念进行扩展，但问题在于，“叔父”这一定义隔多少代才好呢？<br>如下图所示，M为该区块链上一个区块，F为其严格意义上的叔父，E为其严格意义上的“爷爷辈”。以太坊中规定，如果M包含F辈区块，则F获得7&#x2F;8出块奖励；如果M包含E辈区块，则F获得6&#x2F;8出块奖励，以此类推向前。直到包含A辈区块，A获得2&#x2F;8出块奖励，再往前的“叔父区块”，对于M来说就不再认可其为M的”叔父”了。<br>对于M来说，无论包含哪个辈分的“叔父”，得到的出块奖励都是1&#x2F;32出块奖励。</p>
<p>也就是说，叔父区块的定义是和当前区块在七代之内有共同祖先才可（合法的叔父只有6辈）。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/GHOST%203.png"></p>
<p>这样，就方便了全节点进行记录，此外，也从协议上鼓励一旦出现分叉马上进行合并。</p>
<p>以太坊中的奖励：<br>BTC：静态奖励(出块奖励)+动态奖励(交易费，占据比例很小)<br>ETH：静态奖励(出块奖励+包含叔父区块的奖励)+动态奖励(汽油费，占据比例很小，叔父区块没有)<br>BTC中为了人为制造稀缺性，比特币每隔一段时间出块奖励会降低，最终当出块奖励趋于0后会主要依赖于交易费运作。而以太坊中并没有人为规定每隔一段时间降低出块奖励。</p>
<p>以太坊中包含了叔父区块，要不要包含叔父区块中的交易？<br>不应该，叔父区块和同辈的主链上区块有可能包含有冲突的交易。而且我们前文也提到，叔父区块是没有动态奖励的。因此，一个节点在收到一个叔父区块的时候，只检查区块的合法性而不检查其中交易的合法性。</p>
<p>当然，对于分叉后的堂哥区块怎么办？	例如下图所示，A-&gt;F该链并非一个最长合法链，所以B-&gt;F这些区块怎么办？该给挖矿补偿吗？<br>如果规定将下面整条链作为一个整体，给予出块奖励，这一定程度上鼓励了分叉攻击(降低了分叉攻击的成本，因为即使攻击失败也有奖励获得)。因此，ETH系统中规定，只认可A区块为叔父区块，给予其补偿，而其后的区块全部作废。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/GHOST%204.png"></p>
<p>以太坊真实数据<br>Etherscan网站，该网站可以实时观看以太坊的数据。以下截图为我于2020&#x2F;2&#x2F;28截的图，和肖老师视频中截图存在一定差异。但具体内容基本一致。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/GHOST%205.png"></p>
<p>Chome浏览器中文翻译后页面：</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/GHOST%206.png"></p>
<p>在视频中，肖老师还根据该网站上区块信息分析了GHOST协议中叔父区块奖励等信息，这里不再赘述。(59分30秒开始)</p>
<h3 id="ETH-挖矿算法"><a href="#ETH-挖矿算法" class="headerlink" title="ETH-挖矿算法"></a>ETH-挖矿算法</h3><p>在之前的BTC篇中，介绍了比特币系统中使用的挖矿算法。挖矿这一过程，虽然并没有创造什么实际价值，但挖矿本身维持了比特币系统的稳定。总体来说，比特币系统中的挖矿算法较为成功，并未发现大的漏洞。<br>当然，比特币系统的挖矿算法也存在一定问题，其中最为突出的就是导致了挖矿设备的专业化，普通计算机用户难以参与进去，导致了挖矿中心化的局面产生，而这与“去中心化”这一理念相违背。<br>因此，在比特币之后包括以太坊在内的许多加密货币针对该缺陷进行改进，希图做到ASIC Resistance(抗拒ASIC专用矿机)。由于ASIC芯片相对普通计算机来说，算力强但访问内存性能差距不大，因此常用的方法为Memory Hard Mining Puzzle，即增加对内存访问的需求。</p>
<p>LiteCoin(莱特币)</p>
<p>莱特币曾一度成为市值仅次于比特币的第二大货币。其基本设计大体上和比特币一致，但针对挖矿赛诺菲进行了修改。<br>莱特币的puzzle基于Scrypt。Scrypt为一个对内存性能要求较高的哈希函数，之前多用于计算机安全密码学领域。</p>
<p>莱特币挖矿算法基本思想<br>1.设置一个很大的数组，按照顺序填充伪随机数。<br>因为哈希函数的输出我们并不能提前预料，所以看上去就像是一大堆随机的数据，因此称其为“伪随机数”。</p>
<p>Seed为种子节点，通过Seed进行一些运算获得第一个数，之后每个数字都是通过前一个位置的值取哈希得到的。<br>可以看到，这样的数组中取值存在前后依赖关系</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/ETH%20Mining%201.png"></p>
<p>2.在需要求解Puzzle的时候，按照伪随机顺序，从数组中读取一些数，每次读取位置与前一个数相关。例如：第一次，从A位置读取其中数据，根据A中数据计算获得下一次读取位置B；第二次,从B位置读取其中数据，根据B中数据计算获得下一次读取位置C；</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/ETH%20Mining%202.png"></p>
<p>分析<br>如果数组足够大，对于挖矿矿工来说，必须保存该数组以便查询，否则每次不仅计算位置，还要根据Seed计算整个数组数据，才能查询到对应位置的数据。这对于矿工来说，计算复杂度大幅度上升。<br>当然，矿工可以选择只保存一部分数据，例如：只保存奇数位置数据，偶数位置需要时再根据前一个奇数位置数据计算即可，从而对内存空间大小减少了一半(计算复杂度提高一点，但内存减少一半)。</p>
<p>核心思想：不能仅仅进行运算，增加其对内存的访问，从而实现对ASIC芯片不友好。</p>
<p>这个IDEA有问题吗？看似蛮不错的，使得ASIC矿机挖矿变得不友好，但该方法对Puzzle验证并不是很友好。想要验证该Puzzle，也需要存储该数组，因此对于轻节点来说，并不友好(系统中绝大多数节点为轻节点)。<br>因此，莱特币真正应用来说，数组大小不敢设置太大。例如：对于计算机而言，1G毫无压力，而对于手机APP来说，1G占据空间就过大了。所以，实际中，莱特币系统设计的数组大小仅仅128K大小。起初莱特币发行时，不仅希望能够抗拒ASIC，还希望能抗拒GPU。但实际中，后来慢慢出现了GPU挖矿，再后来，ASIC芯片挖矿也出现了。实际应用中，莱特币的设计并未起到预期作用，也就是说，128k对于ASIC Resistance来说过小了。</p>
<p>莱特币的这一设计是好事还是坏事？<br>从其并未起到预期作用来看，当然是一件坏事，但换个角度来思考，早期通过宣传这一设计目标，有效吸引了大批矿工参与，解决了莱特币“能启动”问题，因此目前莱特币仍然是一个较为主流的加密货币。</p>
<p>此外，莱特币和比特币另一区别为出块时间，莱特币为2.5min，为比特币的1&#x2F;4。除了这些不同外，这两种货币基本一样。</p>
<p>以太坊<br>以太坊的理念与莱特币相同，都是Memory Hard Mining Puzzle，但具体设计上与莱特币不同。</p>
<p>以太坊挖矿算法基本思想<br>以太坊中，设计了两个数据集，一大一小。小的为16MB的cache，大的数据集为1G的dataset(DAG)。其关系为，1G的数据集是通过16MB数据集生成而来的。</p>
<p>思考为何要设计一大一小两个数据集？<br>为了便于进行验证，轻节点保存16MB的Cache进行验证即可，而矿工为了挖矿更快，减少重复计算则需要存储1GB大小的大数据集。</p>
<p>16MB的小Cache数据生成方式与莱特币中生成方式较为类似</p>
<p>1.通过Seed进行一些运算获得第一个数，之后每个数字都是通过前一个位置的值取哈希获得的。<br>2.(不同)：</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/ETH%20Mining%203.png">		i.莱特币：直接从数组中按照伪随机顺序读取一些数据进行运算<br>        ii.以太坊：先生成一个更大的数组(注：以太坊中这两个数组大小并不固定，因为考虑到计算机内存不断增大，因此该两个数组需要定期增大)</p>
<p>3.大的DAG生成方式：<br>大的数组中每个元素都是从小数组中按照伪随机顺序读取一些元素，方法同莱特币中相同。如第一次读取A位置数据，对当前哈希值更新迭代算出下一次读取位置B，再进行哈希值更新迭代计算出C位置元素。如此来回迭代读取256次，最终算出一个数作为DAG中第一个元素，如此类推，DAG中每个元素生成方式都依次类推。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/ETH%20Mining%204.png"></p>
<p>分析<br>轻节点只保存小的cache，验证时进行计算即可。但对于挖矿来说，如果这样则大部分算力都花费在了通过Cache计算DAG上面，因此，其必须保存大的数组DAG以便于更快挖矿。</p>
<p>以太坊挖矿过程：<br>根据区块block header和其中的Nonce值计算一个初始哈希，根据其映射到某个初始位置A，读取A位置的数及其相邻的后一个位置A’上的数,根据该两个数进行运算，算得下一个位置B，读取B和B’位置上的数，依次类推，迭代读取64次，共读取128个数。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/ETH%20Mining%205.png"></p>
<p>最后，计算出一个哈希值与挖矿难度目标阈值比较，若不符合就重新更换Nonce，重复以上操作直到最终计算哈希值符合难度要求或当前区块已经被挖出。</p>
<p><strong>伪代码理解以太坊挖矿算法</strong></p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/ETH%20Mining%206.png"></p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/ETH%20MIning%207.png"></p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/ETH%20Mining%208.png"></p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/ETH%20Mining%209.png"></p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/ETH%20Mining%2010.png"></p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/ETH%20Mining%2011.png"></p>
<p>目前以太坊挖矿以GPU为主，可见其设计较为成功，这与以太坊设计的挖矿算法(Ethash)所需要的大内存具有很大关系。<br>1G的大数组与128k相比，差距8000多倍，即使是16MB与128K相比，也大了一百多倍，可见对内存需求的差距很大(况且两个数组大小是会不断增长的)。<br>当然，以太坊实现ASIC Resistance除了挖矿算法设计之外，还存在另外一个原因，即其预期从工作量证明(POW)转向权益证明(POS)</p>
<p>权益证明(POS: Proof of State)<br>权益证明：按照所占权益投票进行共识达成，类似于股份制有限共识按照股份多少投票，权益证明不需要挖矿。<br>而这对于ASIC矿机厂商来说，就好比一把悬在头上的达摩克利斯之剑。因为ASIC芯片研发周期很长，成本很高，如果以太坊转入权益证明，这些投入的研发费用将全部白费(ASIC矿机只能用于挖特定的加密货币)</p>
<p>但实际上，以太坊目前仍然是POW挖矿共识机制。在设计之初，以太坊开发者就设想要从POW转向POS，并为了防止有矿工不愿意转埋下了一颗“难度炸弹”。但截至目前，以太坊仍然基于POW共识机制。</p>
<p>其实很多时候，面对一些问题转换思路就能得到很好的解决方案。如这里，如果按照原本思想，通过不断改进挖矿算法来达成ASIC Resistance，无疑是比较难的。而这里通过不停宣传要转向POS来不断吓阻矿工，使得矿工不敢擅自转入ASIC挖矿，从而实现了ASIC Resistance。</p>
<p>预挖矿(Pre-Mining)<br>以太坊中采用的预挖矿的机制。这里“预挖矿”并不挖矿，而是在开发以太坊时，给开发者预留了一部分货币。以太坊的早期开发者，目前就很有钱了。<br>而比特币并未采用这一模式，所有比特币都是通过挖矿产生的。但早期挖矿难度容易，所有中本聪本人本来就有很多币。<br>和Pre-Mining对应，还有Pre-Sale，Pre-Sale指的是将预留的货币出售掉用于后续开发，类似于拉风投或众筹。目前，各类加密货币很多，存在一部分货币就在采用Pre-Sale来获取资金，如果此时买入，后续如果该货币取得成功，同样可以获得很大收益，但真正成功的货币只占少数，这就是其风险性。</p>
<p><strong>以太坊统计数据</strong><br>1.以太坊中以太币供应量(2018年)<br>饼状图中，蓝色部分都是Pre-Mining产生的（接近3&#x2F;4），可见掌握技术有多么重要。黑色部分为出块奖励产生的以太币，绿色为叔父区块产生的奖励以太币。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/ETH%20Mining%2012.png"></p>
<p>2.最大的25个矿池挖矿算力比重(2018年)</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/ETH%20Mining%2013.png"></p>
<p>3.以太币价格变化情况(至2018年)</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/ETH%20Mining%2014.png"></p>
<p>4.以太币市值变化情况(至2018年)</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/ETH%20Mining%2015.png"></p>
<p>5.以太币Hash Rate变化情况(至2018年)</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/ETH%20Mining%2016.png"></p>
<p>其他观点<br>挖矿算法设计一直趋向于让大众参与，这样才是公平的。且由于参与人员的分散，算力分散，也进一步使得系统更安全。<br>但同样一件事物，从不同观点看就有不同的看法。也有人认为让普通计算机参与挖矿是不安全的，像比特币那样，让中心化矿池参与挖矿才是安全的。为什么呢？<br>因为要攻击系统，需要购入大量只能进行特定货币挖矿的矿机通过算力进行强行51%攻击，而攻击成功后，必然导致该币种的价值跳水，攻击者投入的硬件成本将会全部打水漂。而如果让通用计算机也参与挖矿，发动攻击成本便大幅度降低，目前的大型互联网公司，将其服务器聚集起来进行攻击即可，而攻击完成后这些服务器仍然可以转而运行日常业务。因此，也有人认为，在挖矿上面，ASIC矿机“一统天下”才是最安全的方式。</p>
<h3 id="ETH-难度调整"><a href="#ETH-难度调整" class="headerlink" title="ETH-难度调整"></a>ETH-难度调整</h3><p>前文中介绍了比特币难度调整是每隔2016个区块调整难度，从而达到维持出块时间10min的目标。而以太坊则与之不同，每个区块都有可能会进行难度调整。以太坊难度调整较为复杂，存在多个版本，网络上存在诸多不一致，这里遵循以代码逻辑为准的原则，从代码中查看以太坊难度调整算法。</p>
<p>以太坊难度调整<br>以太坊中区块难度调整算法如下图所示：</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/ETH%20Difficulty%201.png"></p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/ETH%20Difficulty%202.png"></p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/ETH%20Difficulty%203.png"></p>
<p>难度炸弹<br>为什么要设置难度炸弹？<br>根据以上以太坊难度调整算法可以看到，该算法可以很好地动态调整挖矿难度，从而保障系统整体出块时间维持在15s左右。但之前在挖矿算法的文章中有介绍到，以太坊在设计之初就计划要逐步从POW（工作量证明）转向POS（权益证明），而权益证明不需要挖矿。<br>从旁观者角度来看，挖矿消耗了大量电力、资金等，如果转入放弃挖矿，必然是一件好事。但从矿工的角度，花费了很大精力投入成本购买设备，突然被告知“不挖矿了”，这必然是一件很难接受的事情。而以太坊本身为一个分布式系统，其转入POS必须经过系统中大多数矿工认可才行，如果届时矿工联合起来转入POS，那么这一设计初衷就成了一江流水。<br>因此，以太坊在设计之初便添加了难度炸弹，迫使矿工转入POS。那么 如何促使矿工自愿升级软件，而非坚持POS呢？</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/ETH%20Difficulty%204.png"></p>
<p>数学上，指数函数是一个很可怕的东西。我们谈论一个算法，无论其时间复杂度还是空间复杂度，只要达到了指数级别，这个算法必然难以应用于大规模计算上。指数函数在前期增长相对缓慢，但在后期呈现“指数爆炸”，而这往往是我们无法通过升级硬件所能解决的。</p>
<p>可以看到，在以太坊早期时，区块号较小，难度炸弹计算所得值较小，难度调整级别基本上通过难度调整中的自适应难度调整部分决定，而随着越来越多区块被挖出，难度炸弹的威力开始显露出来，这也就使得挖矿变得越来越难，从而迫使矿工愿意转入POS。</p>
<p>难度炸弹调整<br>上面提到，以太坊设想是通过埋设难度炸弹迫使矿工届时愿意转入权益证明，但现实中有一句话：“理想很丰满，现实很骨感”。在实际应用中，权益证明的方式仍然并不成熟，目前以太坊共识机制仍然是POW，依然需要矿工参与挖矿维护以太坊系统的稳定。也就是说，转入POS的时间节点被一再推迟，虽然挖矿变得越来越难，系统出块时间开始逐渐变长，但矿工仍然需要继续挖矿。<br>在上面难度炸弹的公式中，有人应该注意到了第二项中的fake block number，该数仅仅为对当前区块编号减去了三百万，也就是相当于将区块编号回退了三百万个。那么，在前三百万个区块的时候，这个fake block number就是负数吗？<br>答案是否定的。实际上，在以太坊最初的设计中，并没有第二个公式。也就是说，最初就是简单地直接用区块编号除以100000。而在转入权益证明时间节点一再推迟后，以太坊系统采取了将区块编号回退三百万个区块的方法来降低挖矿难度，当然，为了保持公平，也将出块奖励从5个以太币减少到了3个以太币，这也是fake block number这一项出现的原因。<br>下图显示了难度调整对难度炸弹难度影响的结果：</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/ETH%20Difficulty%205.png"></p>
<p>以太坊发展<br>个人感觉这一块肖老师讲解得较为粗略，对于以太坊的四个阶段都只是简单提及，对“拜占庭”这一区块链中非常经典的问题并未进行介绍。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/ETH%20Difficulty%206.png"></p>
<p>以太坊发展存在四个阶段，我们目前处于第三个阶段中的拜占庭阶段，难度炸弹回调就是在拜占庭阶段进行的。</p>
<p>具体代码实现<br>1.难度计算公式<br>bigTime为当前区块时间戳，bigParentTime为当前区块的父区块时间戳。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/ETH%20Difficulty%207.png"></p>
<p>2.基础部分计算</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/ETH%20Difficulty%208.png"></p>
<p>3.难度炸弹计算</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/ETH%20Difficulty%209.png"></p>
<p>为什么不是减去3000000，而是2999999？<br>因为这里判断的父区块号，而公式中是根据当前区块来算的。<br>以太坊实际统计数据(2018年，取自肖老师授课PPT)</p>
<p>1.以太坊挖矿难度变化曲线<br>断崖式下跌是由于下调难度炸弹300万个区块。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/ETH%20Difficulty%2010.png"></p>
<p>2.以太坊出块时间变化曲线图</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/ETH%20Difficulty%2011.png"></p>
<p>3.两个真实区块信息<br>difficulty为当前区块难度，total difficulty为当前区块链上所有区块难度相加。<br>可见，最长合法链也就等同于最难合法链（难度最大合法链）。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/ETH%20Difficulty%2012.png"></p>
<h3 id="ETH-权益证明"><a href="#ETH-权益证明" class="headerlink" title="ETH-权益证明"></a>ETH-权益证明</h3><p>POW机制能耗状况<br>比特币和以太坊目前采用的都是POW(工作量证明)机制，但这种方式一直为人所诟病，正在于其浪费电力资源的特点。</p>
<p>比特币系统<br>下图为比特币系统电力消耗随着时间变化的情况。y轴的单位为Twh，1Twh &#x3D; 10^9 Kwh,1Kwh就是我们平时生活中常说的“一度电”。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/POS%201.png"></p>
<p>可见，比特币系统消耗电能是在逐步上升的。从整体数据看，下图所示从数据角度展现了比特币系统能耗消耗情况(2018年数据)</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/POS%202.png"></p>
<p>可见比特币系统每年的能耗是相当高的，每一笔交易的完成，都要消耗1000多度电力，这是我们不敢想象的。而在能耗如此高的情况下，为什么还会有人愿意挖矿呢？原因自然是尽管成本高，但仍然存在利润空间。如下图：</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/POS%203.png"></p>
<p>以太坊系统<br>下图为以太坊系统电力消耗随着时间变化的情况。y轴的单位为Twh，1Twh &#x3D; 10^9 Kwh,1Kwh就是我们平时生活中常说的“一度电”。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/POS%204.png"></p>
<p>下图从数据角度展现了以太坊系统能耗消耗情况(2018年数据)</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/POS%205.png"></p>
<p>可见以太坊平均每个交易能耗远远低于比特币，而这并非偶然，主要是由于比特币系统中，出块时间过长导致的。</p>
<p>以太坊+比特币<br>如果将以太坊、比特币系统相加，作为一个国家，其所消耗能耗在世界排名如下图：</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/POS%206.png"></p>
<p><strong>思考</strong><br>显而易见，“挖矿”过程消耗了大量的电力资源，这些能耗是必须的吗？<br>矿工挖矿是为了取得出块奖励，获取收益。而系统给予出块奖励的目的是激励矿工参与区块链系统维护，进行记账，而挖矿本质上是看矿工投入资金来决定的(投入资金买设备-&gt;设备决定算力-&gt;算力比例决定收益)。<br>那么，为什么不直接拼“钱”呢？现状是用钱购买矿机维护系统稳定，为什么不大家都将钱投入到系统开发和维护中，而根据投入钱的多少来进行收益分配呢？这就是权益证明的基本思想。</p>
<p><strong>权益证明</strong><br>一般来说，采用权益证明的货币，会先预留一些货币给开发者，而开发者也会出售一些货币换取开发所需要的资金，在系统进入稳定状态后，每个人都安装持有货币的数量进行投票。<br>优点：</p>
<p>1.省去了挖矿的过程，也避免了因此产生的能耗和对环境影响，减少了温室气体的排放。<br>2.维护区块链安全的资源形成闭环，而POW中维护其安全的资源需要通过现实中流通的货币购买矿机等设备进去区块链的，这也就导致只要有人想要攻击，只需要外部聚集足够资金就可以攻击成功(小型币种很容易被攻击，也就是在摇篮里就扼杀掉)。可见，POS机制可以有效防御这种情况。<br>有些币种根据持有币的权益进行挖矿难度调整(实际并不能这么简单设置，因为会导致“旱的旱死，涝的涝死”，需要添加一定限制)，也就是结合POW和POS。可见，POS与POW并不互斥。</p>
<p>当然，权益证明这么好，为什么实际中并未得到大规模应用呢？<br>原因是其中仍然存在很多挑战，例如“双边下注”：</p>
<p>如下图所示，区块链系统产生了分叉，存在两个区块A和B竞争主链时，采用权益证明的方法就是所有持币者对这两个区块投入币进行投票，从而决定哪一个区块成为最长合法链上的区块。假如有一个人，在A和B同时进行了下注。最终A区块胜出，那么他能够获得A区块相应收益，而在B区块进行投票放入的“筹码”也会被退还，这也就导致其每次都能获得收益。<br>由于一个人可以拥有多个账户，所以我们无法强迫一个人一次只能投向一个区块。而越有钱的人，通过“双边下注”得到的收益也就越多。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/POS%207.png"></p>
<p><strong>以太坊拟采用的权益证明</strong><br>以太坊中，准备采用的权益证明协议为Casper the Friendly Finality Gadget(FFG)，该协议在过渡阶段是要和POW结合使用的。<br>在比特币系统中，我们有提到为了防范分叉攻击，一个交易在其获得6次确认（其后跟着6个区块）后认为该区块安全。但实际上，这种安全只是概率意义上的安全，仍然可能会被拥有强大算力的用户在其前面发动分叉攻击进行回滚。<br>Casper协议引入一个概念：Validator(验证者)，一个用户想要成为Validator，需要上交一笔“保证金”，这笔保证金会被系统锁定。Validator的职责是推动系统达成共识，投票决定哪一条链成为最长合法链，投票权重取决于保证金数目。<br>实际中，采用两次投票的方式：预投票和Commit 投票，规定每次投票结果都要获得2&#x2F;3以上的验证者同意。在实际中，针对其进行了一些修改，两次投票在实际中只需要一次即可。（由于我觉得书面难免会有遗漏，这里就不详细展开了，推荐去肖老师视频中观看，大概从25：00起）。</p>
<p>矿工挖矿会获得出块奖励，而验证者也会得到相应奖励。当然，为了防止验证者的不良行为，规定其被发现时要受到处罚。例如某个验证者“行政不作为”，不参与投票导致系统迟迟无法达成共识，这时扣掉<strong>部分</strong>保证金；如果某个验证者“乱作为”，给两边都进行投票，被发现后没收<strong>全部</strong>保证金。没收的保证金被销毁，从而减少系统中货币总量。验证者存在“任期”，在任期结束后，进入“等待期”，在此期间等待其他节点检举揭发是否存在不良行为，若通过等待期，则可以取回保证金并获得一定投票奖励。</p>
<p>这样一定能保证不被篡改吗？<br>在该协议下，矿工无论算力多么强，最终投票权都不在其手中。必须在系统中，存在大量“验证者”进行了两边投票，也就是说，至少1&#x2F;3（该协议规定超过2&#x2F;3才有效）的验证者两侧都投票，才会导致系统被篡改。而这一旦被发现，这1&#x2F;3验证者的保证金将会被没收。</p>
<p>以太坊系统设想，随着世界推移，挖矿奖励逐渐减少而权益证明奖励逐渐增多，从而实现POW到POS的过渡，最终实现完全放弃挖矿。</p>
<p>然而权益证明仍然存在缺陷，但工作量证明已经得到了事实检验，该机制较为成熟。<br>目前，EOS加密货币，即“柚子”，2018年上线，就是采用权益证明的共识机制，其采用的是DPOS：Delegated Proof of Stake。该协议核心思想是通过投票选21个超级节点，再由超级节点产生区块。但目前，权益证明仍然处于探索阶段。</p>
<p>其他观点<br>前面的基本观点都是基于“挖矿消耗大量电能，而这是不好的”这一观点，但也有人持有相反观点。<br>他们认为其所消耗的电能所占比值并不大，而且其对于环境的影响是有限的。挖矿提供了将电能转换为钱的手段，而电能本身难以传输和存储，一般来说，白天所发的电不足，晚上所发的电又多于实际需求。因此，挖矿为将多余的电脑转换为有价值的货币提供了很好的解决手段。<br>也就是说挖矿消耗电能可以有效消耗过剩产能，带动当地经济发展。</p>
<h3 id="ETH-智能合约"><a href="#ETH-智能合约" class="headerlink" title="ETH-智能合约"></a>ETH-智能合约</h3><p>智能合约：运行在区块链系统上的一段代码，代码逻辑定义了合约内容。<br>智能合约的账户保存了合约当前的运行状态：</p>
<p>balance：当前余额<br>nonce：交易次数<br>code：合约代码<br>storage：存储，数据结构为一棵MPT<br>智能合约编写代码为Solidity，其语法与JavaScript很接近。<br>下图显示了智能合约的代码结构。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Contract%201.png"></p>
<p>账户调用<br>外部账户调用合约账户</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Contract%202.png"></p>
<p>合约账户调用合约账户<br>合约账户之间也可以进行调用。其调用方式如下：</p>
<p>直接调用</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Contract%203.png"></p>
<p>错误处理：直接调用的方式，一方产生异常会导致另一方也进行回滚操作。</p>
<p>address调用</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Contract%204.png"></p>
<p>错误处理：address.call()的方法，如果调用过程中被调用合约产生异常，会导致call()返回false，但发起调用的函数不会抛出异常，而是继续执行。</p>
<p>代理调用</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Contract%205.png"></p>
<p>和call()调用基本一致，区别在于其并不会切入被调用合约的上下文中。</p>
<p>关于Payable ：<br>如下，成员函数中的第一个函数，有一个payable修饰。原因是以太坊中规定，如果一个函数可以接收外部转账，则必须标记为payable。该例中背景为拍卖，bid()为出价，因此需要payable进行标记；withdraw()为其他未拍卖到的人将锁定在智能合约中的钱取出的函数，其不涉及转账，因此不需要payable进行标记。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Contract%206.png"></p>
<p>fallback()函数</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Contract%207.png"></p>
<p>该函数主要是防止A向B转账，但没有在data域中说明要调用哪个函数或说明的要调用函数不存在，此时调用fallback()函数。<br>只有合约账户才有代码，因此这些只和合约账户有关。如果没有fallback()，在发生之前的情况后，就会直接抛出异常。<br>另：转账金额和汽油费是不同的。汽油费是为了让矿工打包该交易，而转账金额是单纯为了转账，其可以为0，但汽油费必须给。</p>
<p>智能合约创建与运行<br>实际上并不是想转账，而是想要创建智能合约。EVM设计思想类似于JAVA中的JVM，便于跨平台增强可移植性。EVM中寻址空间256位，而目前个人机主流位32位和64位，与之存在较大差距。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Contract%208.png"></p>
<p>汽油费<br>以太坊中功能很充足，提供图灵完备的平台，从而使得以太坊相对于比特币可以实现很多功能，但这也导致一些问题，例如当一个全节点收到一个对智能合约调用怎么知晓其是否会导致死循环。<br>事实上，无法预知其是否会导致死循环，实际上，该问题是一个停机问题，而停机问题不可解。因此，以太坊引入汽油费机制将该问题扔给了发起交易的账户。<br>以太坊规定，执行合约中指令需要收取汽油费，并且由发起交易的人进行支付。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Contract%209.png"></p>
<p>当一个全节点收到一个对智能合约的调用，先按照最大汽油费收取，从其账户一次性扣除，再根据实际执行情况，多退少补(汽油费不够会引发回滚，而非简单的补齐)。</p>
<p>以太坊中存在gaslimit，通过收取汽油费保障系统中不会存在对资源消耗特别大的调用。但与比特币不同，比特币直接通过限制区块大小1MB保障对网络资源压力不会过大，这1MB大小是固定的，无法修改。而以太坊中，每个矿工都可以以前一个区块中的gaslimt为基数，进行上调或下调1&#x2F;1024，从而，通过绝大多数区块不断上下调整，保证得到一个较为理想化的gaslimt值(感觉这里有些类似于众包机制)。最终整个系统的gaslimt就是所有矿工希望的平均值。</p>
<p>为什么要引入汽油费？<br>在比特币系统中，交易是比较简单的，仅仅是转账操作，也就是说可以通过交易的字节数衡量出交易所需要消耗的资源多少。但以太坊中引入了智能合约，而智能合约逻辑很复杂，其字节数与消耗资源数并无关联。存在某些交易，从字节数来看很小，但其实际消耗资源很大(例如调用其他合约等)，因此要根据交易的具体操作收费，所有引入了汽油费这一概念。<br>在block header中包含了gaslimit，其并非将所有交易的消耗汽油费相加，而是该区块中所有交易能够消耗的资源的上限。</p>
<p>错误处理<br>以太坊中交易具有原子性，要么全执行，要么全不执行，不会只执行一部分(包含智能合约)。<br>需要注意的是，在执行过程中产生错误导致回滚，已经消耗掉的汽油费是不会退回的。从而有效防止了恶意节点对全节点进行恶意调用。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Contract%2010.png"></p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Contract%2011.png"></p>
<p>嵌套调用是否发生回滚，取决于调用方式。<br>一个合约向一个合约账户直接转账，因为fallback函数的存在，仍有可能会引发嵌套调用。</p>
<p>挖矿与智能合约执行<br>假设全节点要打包一些交易到区块中，其中存在某些交易是对智能合约的调用。全节点应该先执行智能合约再挖矿，还是先挖矿获得记账权后执行智能合约？</p>
<p>观点1：先挖矿后执行智能合约。因为如果先执行智能合约，后挖矿，可能导致同一智能合约被不同节点执行多次，因此可能会导致一个转账操作被执行多次，即转账了好多次。<br>实际上，这个观点很明显是没有理解区块链系统。实际上，一个在区块链上的区块中的智能合约，其必然在系统中所有节点中都得到了执行，因为这样才能保证系统中所有节点从一个状态转入另一个状态，从而保证系统的一致性。<br>如果存在一个全节点没有执行该智能合约，那么该全节点的状态就和其他节点不一致，则该系统就没有保持状态一致。</p>
<p>观点2：先挖矿后执行智能合约。因为执行智能合约要收取汽油费，如果多个人都执行，会收取很多份智能合约。<br>实际上这也是错误的。</p>
<p>观点3：先执行智能合约后挖矿。<br>实际上，这才是正确的。在介绍时候，我们常说执行智能合约时，要先从发起调用的账户扣除可能花费的最大汽油费，待执行完成后，有剩余再退还。这样介绍会令人感觉有些迷糊，那么每个节点都会执行智能合约，是不是每个节点都会扣除一份汽油费呢？<br>当然不是，这里就需要了解汽油费的扣除机制。</p>
<p>汽油费是怎么扣除的？<br>首先，之前在以太坊数据结构中介绍了以太坊中“三棵树”——状态树、交易树、收据树。这三棵树都位于全节点中，是全节点在<strong>本地</strong>维护的数据结构，记录了每个账户的状态等数据，所以该节点收到调用时，是在本地对该账户的余额减掉即可。所以多个全节点每人扣一次，仅仅是每个全节点各自在本地扣一次。<br>也就是说，智能合约在执行过程中，修改的都是本地的数据结构，只有在该智能合约被发布到区块链上，所有节点才需要同步状态，各自在本地执行该智能合约。</p>
<p>反思：如果先挖矿后执行智能合约会如何？<br>智能合约会导致数据结构发生改变，从而修改掉区块中的内容，那么之前挖矿时挖到的nonce是不适用于此时修改过后的block的，也就是说，执行智能合约后的区块，并非之前的区块，之前的nonce不能适用于当前区块，从而无法被加入到区块链中。<br>总结：挖矿导致三棵树数据结构改变，之前挖到的矿就无效了<br>所以，在以太坊系统中，必然是先执行智能合约，后挖矿</p>
<p>一些问题<br>1.发布到区块链上交易都是成功执行的吗？<br>为了防止恶意节点故意发布大量非法交易影响系统运行，对于其发布的交易即使无法成功执行也需要收取汽油费。但如果交易不被发布到区块链上，是无法收取汽油费的。</p>
<p>2.智能合约支持多线程吗？<br>不支持，根本就没有支持多线程的语句。因为以太坊本质为一个交易驱动的状态机，面对同一组输入，必须转移到一个确定的状态。但对于多线程来说，同一组输入的输入顺序不同，最终的结果可能不一致。<br>此外，其他可能导致执行结果不确定的操作也不支持，例如：产生随机数。因此，以太坊中的随机数是伪随机数。<br>也正是因为其不支持多线程，所以无法通过系统调用获得系统信息，因为每个全节点环境并非完全一样。因此只能通过固定的结构获取。下图分别为为其可以获得的区块链信息和调用信息。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Contract%2012.png"></p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Contract%2017.png"></p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Contract%2013.png"></p>
<p>Receipt数据结构<br>每个交易执行完成后会形成一个收据，下图便为收据的数据结构。其中status域就说明了该交易执行的状况。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Contract%2014.png"></p>
<p>以太坊地址类型<br>第一个，以wei为单位的地址类型的余额中，uint256并不是指其包含一个类型为uint256的参数，而是指该变量本身为uint256类型(无符号int)的变量。<br>下面的函数意义与我们认知有所不同，也与address.balance不同。<br>例如：<br>address.balance指的是address这个账户的余额<br>address.transfer(12345)，并非address向外转账12345Wei，因为这样没有收款人的address。所以，该函数指的是当前合约向address地址中转入了12345Wei。后面的函数都是该语义，这里是需要注意的，因为其与我们的认知存在差异。<br>(最下面三个函数为三种调用方式，忘记的话可以查看ETH智能合约篇1中的解释)</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Contract%2015.png"></p>
<p>在以太坊中，转账有以下三种方法。<br>transfer在转账失败后会导致连锁性回滚，抛出异常；而send转账失败会返回false，不会导致连锁性回滚。call的方式本意是用于发动函数调用，但是也可以进行转账。<br>前两者在调用时，只发生2300wei的汽油费，这点汽油费很少，只能写一个log，而call的方式则是将自己还剩下的所有汽油费全部发送过去(合约调用合约时常用call，没用完的汽油费会退回)。例如A合约调用B合约，而A不知道B要调用哪些合约，为了防止汽油费不足导致交易失败，A将自己所有汽油费发给B来减少失败可能性。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Contract%2016.png"></p>
<p>简单拍卖的例子：</p>
<p>1、这个拍卖不允许中途退出。而且必须先验资。</p>
<p>2、拍卖结束后，最高出价者获得物品，同时拍卖者获得收益，其他人可以把出价的钱退回来。</p>
<p>3、竞拍是可以多次出价的，多次出价只需要补差价即可。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Contract%2018.png" alt="img"> </p>
<p>solidty中的hash 表，如果不存在的话，那么它返回的就是个0。这里的bids[]就是一个哈希表。solidty中的哈希表不支持遍历，所以必须每次都更新一次。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Contract%2019.png" alt="img"> </p>
<p>智能合约的发布流程：</p>
<p>你写完智能合约后，你需要把该合约发布到区块链上。怎么发布？</p>
<p>1、往0的地址发一笔转账交易，转账金额是0。智能合约的代码放到data域中，汽油费是要出的。</p>
<p>2、矿工把这个智能合约发布到区块链上，会返还你一个合约地址。</p>
<p>3、这个合约就在区块链上，所有人都可以调用。</p>
<p>智能合约本身有个合约账户，里面有它的状态信息。</p>
<p>上面交易有个问题，就是如果被如下的黑客黑了，就无法发布到区块链上，就无法形成共识了。谁也收不到钱。智能合约任何对于状态的更新都是在本地进行的。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Contract%2020.png" alt="img"> </p>
<p>出现这种情况就没有办法了，ETH就有可能被永久地锁起来了，合约无论成功还是失败都要发布到区块链上，gas费用，所以就会被锁死了。code is low：区块链的不可篡改性，坏处是，规则中有漏洞你也改不了了。智能合约锁仓。有些类似不可撤销的信托。所以在发布智能合约之前，需要测试测试再测试。你也可以通过假的ETH的测试网来验证。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Contract%2021.png" alt="img"> </p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Contract%2022.png" alt="img"> </p>
<p>1、合约上的余额不够了。</p>
<p>2、汽油费不够了。</p>
<p>3、调用栈溢出了。  所以黑客在重复调用钱，增加了限定条件。</p>
<p>改善，类似上图，先清零了。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Contract%2023.png"></p>
<p>这样改有什么好处？</p>
<p>1、先清零，防止重复调用。2、用sender和transfer，因为gas是限制的2300个wei，所以无法支撑起再调用一次这种递归函数。</p>
<h3 id="ETH-TheDAO"><a href="#ETH-TheDAO" class="headerlink" title="ETH-TheDAO"></a>ETH-TheDAO</h3><p>我们说BTC实现了去中心化的货币，ETH实现了去中心化的合约。既然去中心化那么好，那么为什么我们不把所有的都去中心化呢？DAO的概念就是这样提出来了。</p>
<p>DAO：Decentralized Autonomous Organization  去中心化的自治组织</p>
<p>1、2016年出现了一个 众筹的投资资金：The DAO本质是运行在ETH上的智能合约。你把ETH发给智能合约 换成The DAO的代币。想要投资哪个项目，你手中的代币越多，你所拥有的权重就越大。如果有了收益则按照智能合约的规章制度来分配利益。2016年5月出现，在当时被称为伟大的尝试。1个月筹集到了1.5亿美元的ETH。遗憾的是The DAO 只存在3个月。问题在于你怎么换回投资的资金：</p>
<p>splitDAO，建立子资金的方法（childDAO）：这个设计的理念是允许一部分人从The DAO里面拆分出去，来换回对应的ETH，然后他们就能投他们想投的项目。极端情况，单个人投资一个子资金。这是投资者收回收益的唯一方式。拆分有7天的讨论期，28天的锁定期。问题出现在splitDAO的实现上。</p>
<p>黑客通过重入攻击调取了5000万的ETH。ETH社区对此进行激烈的讨论，一派认为要回滚交易。成立的子资金有28天的锁定期，可以有补救措施。另一派认为不需要什么补救措施，黑客的行为并没有违法。code in law。只是上面的智能合约上有个安全漏洞，如果每个漏洞你都回滚，那么你怎么说你是去中心化的开放合约。支持的人认为 The DAO占到ETH的1&#x2F;3了。The DAO is too big too fail。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/TheDAO%201.png" alt="img"> </p>
<p>DAC：Decentralized Autonomous Organization Corporation </p>
<p>2、怎么补救？</p>
<p>1）分叉攻击补救：在攻击前建立一个分叉，然后统一资源挖，超过原本的链。不止黑客的交易回滚，其他的交易都回滚，要回滚的话，必须要精确定位，不能影响到其他正常的交易，而只针对受黑客影响的交易，要回滚。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/TheDAO%202.png" alt="img"> </p>
<p>2）首先锁定黑客的账户，再设法把盗取的ETH退回去。</p>
<p>1、ETH发布了一个软件升级，凡是跟The DAO基金上账户相关的，不允许做任何交易。大多数ETH矿工都升级了。这种方法属于<strong>软分叉</strong>方案(旧矿工挖出的区块，新矿工可能不认可，而新矿工挖出的区块，旧矿工一定是认可的)可惜的升级后的软件有个bug，在于汽油费方面【按我们想应该要收去汽油费的，但是ETH恰恰就是在这里没有收取汽油费。最后导致网上有大量的这种攻击，导致矿工受不了了纷纷回滚了这次的升级，于是软分叉就失败了，软分叉的方案失败之后，剩下的时间就不多了】。</p>
<p>2、ETH升级了一个硬的分叉，将The DAO上的资金，强行转到另外一个新的智能合约上面去。这个新的智能合约只有一个功能，就是退钱。把代币退还成ETH。这个就是硬分叉了。用软件升级的方法，强行记账，不管The DAO上的用户同意不同意。就好比法院的强制执行，不用什么合法不合法的签名。所以这是个硬分叉(旧矿工挖出的区块，新矿工是认可的，而新矿工挖出的区块，旧矿工是不认可的，因为它并不能保证是合法的区块)。</p>
<p>ETH通过智能合约，通过ETH权重投票来决定是否这样做，结果大部分人都支持硬分叉，大部分矿工也同意升级了。大家等着挖出的192万个区块的历史性时刻。黑客盗取ETH的行为，最终还是没有获利。其实这个故事没有结束，当初反对的人，并没有投票结果就同意这个处理方案。两点理由：</p>
<p>1、投票是通过2个智能合约锁仓，结果出来后再退回来。大多数人并没有参与其中。</p>
<p>2、大多数人的意见一定是正确的吗？</p>
<p>硬分叉过后，旧的那条链并没有消失，只是算力变成了原来的1&#x2F;10。好处是挖矿难度也下降了，主要是竞争没那么激烈了。现在不到2%。</p>
<p>硬分叉之后，新的链继承了这个符号ETH，旧链变成了ETC。有些事处于投机目的，也有一些是出于信仰。结果ETC一直存在到现在。后来增加了一个chain ID，就正式分裂了。</p>
<p>为什么不能只冻结黑客的账户呢？</p>
<p>很简单，因为智能合约发布之后，无法修改，任何人都能调用这个合约成为新的黑客。</p>
<h3 id="ETH-反思"><a href="#ETH-反思" class="headerlink" title="ETH-反思"></a>ETH-反思</h3><p>1、 Is smart contract is really smart？ 智能合约真的智能吗？</p>
<p>说智能合约，其实类似自动合约。ATM取款机，按照事先规定好的规则去执行。其实是个代码合同。</p>
<p>smart contract is anything but smart 。 </p>
<p>区块链的不可篡改性，其实是一个双刃剑。 Irrevocability is a double edged sword!</p>
<p>如果像上节课的例子那样，智能合约里面有漏洞，被黑客调用，你如何及时地保护剩下的钱？</p>
<p>只能采用和黑客一样的方法，声明我是为了保护剩下的钱，通过另一个智能合约调用，将钱转移到安全的合约中。</p>
<p>2、Nothing is irrevocable！不要迷信区块链的不可篡改。 毕竟代码是死的，人是活的。</p>
<p>老师用美国第18宪法修正案来举例。【著名的禁酒令】 open container road。</p>
<p>一般情况下，区块链上的内容是改不了的，但遇到重大事件，改还是能改得了的。</p>
<p>3、solidty 这个语言的特性是反自然的。我给你转账的操作等于是隐性地调用了你的fallback，结果你还能过来调用我。</p>
<p>有人提出用函数式的编程语言。从长远来看，对于智能合约的功能性 ，安全性更重要。</p>
<p>老师提到了ocaml ，语法不够直观，运行比较缓慢。</p>
<p>formal rerification 形式化的语言</p>
<p>4、大多数的比特币脚本基本都很简单，而且还有白名单机制，不在名单的脚本，很多矿工在缺省情况下是不接受的。</p>
<p>现实中写合同，都是通过模板来写。</p>
<p>开源的好处，增加合约的公信力。增加接受程度。开源的另外一个好处是安全。</p>
<p>many eyeball fallacy（misbelieved） 真正有时间经历去看源代码的是很少的。</p>
<p>5、去中心化：寻找一个全新的管理模式。很多人认为又回到了一个中心化的管理结构。</p>
<p>what does decentralization mean？最后硬分叉能够成功，是因为绝大部分矿工升级了软件，执行了硬分叉。小部分沿着原来的旧链，继续挖，ETH团队也没办法强迫他们转过来。</p>
<p>分叉恰恰是去中心化的体现，你可以选择放弃，但是没办法选择分叉。用户不满意，就有选择分叉的权利。</p>
<p>美联储量化宽松，很多人不满意，但没有办法。</p>
<p>6、decentralized !&#x3D; distributed 去中心化，不等于分布式。但分布式是去中心化的前提。</p>
<p>distributed (分布式)的一般情况是让每台机器做不同的工作，然后将工作汇总起来。<em><strong>而不是像区块链这样，让许多机器都做相同的工作，只为保证状态的一致性。</strong></em></p>
<p>ETH和BTC都是 station meachine 状态机</p>
<p>状态机的目的是 mission critical application ：比如 air traffic control 、stock exchange 、space shuttle。 即便有一台机器出了问题也没有关系。只要其他好几台机器能够稳定工作即可。这样付出的代价是效率很低，因为要同步状态。所以传统应用状态机的数目是很少的。</p>
<p>像ETH，BTC上千台机器同步同一个操作，是很少的。</p>
<p>智能合约适用于编写控制逻辑的。只有需要共识的操作才需要智能合约。</p>
<h3 id="ETH-美链"><a href="#ETH-美链" class="headerlink" title="ETH-美链"></a>ETH-美链</h3><p>1、IPO：initial public offering。 ICO： initial coin offering。</p>
<p>这些代币没有自己的区块链，而是以智能合约的形式，运行在ETH的ECM平台上。发行这个代币的智能合约，对应的是ETH状态树上的一个节点，这个节点有它自己的账户余额，就相当这个智能合约一共有多少个ETH。在这个合约里，每个账户上有多少个代币，这个是作为存储数中的变量。存储在智能合约这个账户里。代币的发行，转账，存储，销毁都是调用智能合约里面的函数来实现的。这个也是跟ETH上的以太币不一样。代币里面的转账，只要调用里面的智能合约就能实现了。每个代币可以制定自己的发行规则。每个账户上有多少个代币信息都是发布在这个智能合约的存储树上面。ETH的平台的出现，给各种代币的发行提供了方便。</p>
<p>EOS：用的是DPOS权益证明形成的共识机制。在上线之前也是作为ETH上代币的一个形式出现的。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/BES%201.png"></p>
<p>ERC ：ethereum request for comments</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/BES%202.png"></p>
<p>这个问题出在_value如果很大，有可能 amount 会溢出，这样算出来的amount是一个很小的值，这样调用减去amount时，减去的就有可能是一个很小的值。这样的结果就是，系统中凭空多发行了很多的代币。 8*2&#x3D;16</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/BES%203.png"></p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/BES%204.png"></p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/BES%205.png"></p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/BES%206.png"></p>
<p>solidty对溢出的检测有个safemath的库，上面那个问题也在乘法那里不小心用了*，而没用safemath的库。</p>
<p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/BES%207.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、有人提议把保险理赔业务放到区块链上？觉得保险理赔太慢了。保险理赔的速度慢，问题不在于支付手段慢，重点在于理赔的内容需要人工审核。</p>
<p>2、区块链做防伪溯源。这个问题在于，是不是你通过区块链记录下来，就一定能保证货物是真的？区块链的不可篡改性只针对写上去的内容。</p>
<p>3、信任机制：区块链的共识机制，是在互补信任的实体之间形成共识。去中心化的体系中，无法在两个互补相识的个体之间，建立信任关系。在一个成功的商业模式中，既有中心化，也有去中心化的方式。</p>
<p>4、区块链目前的状态是缺乏监管的状态。没有司法监管，就没有司法保护。</p>
<p>支付方式并没有跟上Internet。现在金融体系缺乏能够全球范围流动的支付体系。有些人认为下一代互联网价值交换网络。现在只是信息交流网络。使得价值交换跟信息传播一样容易。</p>
<p>加密货币现在的能耗比较高。一些新的加密货币在交易方面，效率已经大大提高了。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://DestinyWei.github.io">浩烬</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://destinywei.github.io/post/BlockChainNote.html">https://destinywei.github.io/post/BlockChainNote.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://DestinyWei.github.io" target="_blank">浩烬的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a></div><div class="post_share"><div class="social-share" data-image="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/区块链.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/post/ActivityNote.html"><img class="next-cover" src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Java.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Activity工作流</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/头像3.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">浩烬</div><div class="author-info__description">坚持就是胜利</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/DestinyWei"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/DestinyWei" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1342348280@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的Blog频道，若有疑问，请联系我的QQ：1342348280</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#BTC%E9%83%A8%E5%88%86"><span class="toc-number">1.</span> <span class="toc-text">BTC部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BTC-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">BTC-密码学原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BTC-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">BTC-数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BTC-%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.3.</span> <span class="toc-text">BTC-协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BTC-%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.</span> <span class="toc-text">BTC-实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BTC-%E7%BD%91%E7%BB%9C"><span class="toc-number">1.5.</span> <span class="toc-text">BTC-网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BTC-%E6%8C%96%E7%9F%BF%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4"><span class="toc-number">1.6.</span> <span class="toc-text">BTC-挖矿难度调整</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BTC-%E6%8C%96%E7%9F%BF"><span class="toc-number">1.7.</span> <span class="toc-text">BTC-挖矿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BTC-%E6%AF%94%E7%89%B9%E5%B8%81%E8%84%9A%E6%9C%AC"><span class="toc-number">1.8.</span> <span class="toc-text">BTC-比特币脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BTC-%E5%88%86%E5%8F%89"><span class="toc-number">1.9.</span> <span class="toc-text">BTC-分叉</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BTC-%E9%97%AE%E7%AD%94"><span class="toc-number">1.10.</span> <span class="toc-text">BTC-问答</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BTC-%E5%8C%BF%E5%90%8D%E6%80%A7"><span class="toc-number">1.11.</span> <span class="toc-text">BTC-匿名性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BTC-%E6%80%9D%E8%80%83"><span class="toc-number">1.12.</span> <span class="toc-text">BTC-思考</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ETH%E9%83%A8%E5%88%86"><span class="toc-number">2.</span> <span class="toc-text">ETH部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ETH-%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">ETH-概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ETH-%E8%B4%A6%E6%88%B7"><span class="toc-number">2.2.</span> <span class="toc-text">ETH-账户</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ETH-%E7%8A%B6%E6%80%81%E6%A0%91"><span class="toc-number">2.3.</span> <span class="toc-text">ETH-状态树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ETH-%E4%BA%A4%E6%98%93%E6%A0%91%E5%92%8C%E6%94%B6%E6%8D%AE%E6%A0%91"><span class="toc-number">2.4.</span> <span class="toc-text">ETH-交易树和收据树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ETH-GHOST"><span class="toc-number">2.5.</span> <span class="toc-text">ETH-GHOST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ETH-%E6%8C%96%E7%9F%BF%E7%AE%97%E6%B3%95"><span class="toc-number">2.6.</span> <span class="toc-text">ETH-挖矿算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ETH-%E9%9A%BE%E5%BA%A6%E8%B0%83%E6%95%B4"><span class="toc-number">2.7.</span> <span class="toc-text">ETH-难度调整</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ETH-%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E"><span class="toc-number">2.8.</span> <span class="toc-text">ETH-权益证明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ETH-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6"><span class="toc-number">2.9.</span> <span class="toc-text">ETH-智能合约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ETH-TheDAO"><span class="toc-number">2.10.</span> <span class="toc-text">ETH-TheDAO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ETH-%E5%8F%8D%E6%80%9D"><span class="toc-number">2.11.</span> <span class="toc-text">ETH-反思</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ETH-%E7%BE%8E%E9%93%BE"><span class="toc-number">2.12.</span> <span class="toc-text">ETH-美链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.13.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/BlockChainNote.html" title="北京大学肖臻老师《区块链技术与应用》公开课"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/区块链.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="北京大学肖臻老师《区块链技术与应用》公开课"/></a><div class="content"><a class="title" href="/post/BlockChainNote.html" title="北京大学肖臻老师《区块链技术与应用》公开课">北京大学肖臻老师《区块链技术与应用》公开课</a><time datetime="2022-08-13T18:28:01.697Z" title="发表于 2022-08-14 02:28:01">2022-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/ActivityNote.html" title="Activity工作流"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Java.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Activity工作流"/></a><div class="content"><a class="title" href="/post/ActivityNote.html" title="Activity工作流">Activity工作流</a><time datetime="2022-08-13T18:24:58.426Z" title="发表于 2022-08-14 02:24:58">2022-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/MysqlNote.html" title="Mysql笔记"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/Mysql.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mysql笔记"/></a><div class="content"><a class="title" href="/post/MysqlNote.html" title="Mysql笔记">Mysql笔记</a><time datetime="2022-08-13T17:52:02.555Z" title="发表于 2022-08-14 01:52:02">2022-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/Introduction.html" title="写给各位看官老爷"><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/blog-picture.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="写给各位看官老爷"/></a><div class="content"><a class="title" href="/post/Introduction.html" title="写给各位看官老爷">写给各位看官老爷</a><time datetime="2022-08-13T17:52:02.552Z" title="发表于 2022-08-14 01:52:02">2022-08-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/6708/区块链.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 <i id="heartbeat" class="fa fas fa-heartbeat"></i> 浩烬</div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://npm.elemecdn.com/hexo-butterfly-clock/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_injector_config();
  }
  </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax src="https://npm.elemecdn.com/hexo-butterfly-clock/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>